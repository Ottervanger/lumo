(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.lumo = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';module.exports=earcut;function earcut(data,holeIndices,dim){dim=dim||2;var hasHoles=holeIndices&&holeIndices.length,outerLen=hasHoles?holeIndices[0]*dim:data.length,outerNode=linkedList(data,0,outerLen,dim,true),triangles=[];if(!outerNode)return triangles;var minX,minY,maxX,maxY,x,y,size;if(hasHoles)outerNode=eliminateHoles(data,holeIndices,outerNode,dim);// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
if(data.length>80*dim){minX=maxX=data[0];minY=maxY=data[1];for(var i=dim;i<outerLen;i+=dim){x=data[i];y=data[i+1];if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y;}// minX, minY and size are later used to transform coords into integers for z-order calculation
size=Math.max(maxX-minX,maxY-minY);}earcutLinked(outerNode,triangles,dim,minX,minY,size);return triangles;}// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data,start,end,dim,clockwise){var i,last;if(clockwise===signedArea(data,start,end,dim)>0){for(i=start;i<end;i+=dim){last=insertNode(i,data[i],data[i+1],last);}}else{for(i=end-dim;i>=start;i-=dim){last=insertNode(i,data[i],data[i+1],last);}}if(last&&equals(last,last.next)){removeNode(last);last=last.next;}return last;}// eliminate colinear or duplicate points
function filterPoints(start,end){if(!start)return start;if(!end)end=start;var p=start,again;do{again=false;if(!p.steiner&&(equals(p,p.next)||area(p.prev,p,p.next)===0)){removeNode(p);p=end=p.prev;if(p===p.next)return null;again=true;}else{p=p.next;}}while(again||p!==end);return end;}// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear,triangles,dim,minX,minY,size,pass){if(!ear)return;// interlink polygon nodes in z-order
if(!pass&&size)indexCurve(ear,minX,minY,size);var stop=ear,prev,next;// iterate through ears, slicing them one by one
while(ear.prev!==ear.next){prev=ear.prev;next=ear.next;if(size?isEarHashed(ear,minX,minY,size):isEar(ear)){// cut off the triangle
triangles.push(prev.i/dim);triangles.push(ear.i/dim);triangles.push(next.i/dim);removeNode(ear);// skipping the next vertice leads to less sliver triangles
ear=next.next;stop=next.next;continue;}ear=next;// if we looped through the whole remaining polygon and can't find any more ears
if(ear===stop){// try filtering points and slicing again
if(!pass){earcutLinked(filterPoints(ear),triangles,dim,minX,minY,size,1);// if this didn't work, try curing all small self-intersections locally
}else if(pass===1){ear=cureLocalIntersections(ear,triangles,dim);earcutLinked(ear,triangles,dim,minX,minY,size,2);// as a last resort, try splitting the remaining polygon into two
}else if(pass===2){splitEarcut(ear,triangles,dim,minX,minY,size);}break;}}}// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear){var a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return false;// reflex, can't be an ear
// now make sure we don't have other points inside the potential ear
var p=ear.next.next;while(p!==ear.prev){if(pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.next;}return true;}function isEarHashed(ear,minX,minY,size){var a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return false;// reflex, can't be an ear
// triangle bbox; min & max are calculated like this for speed
var minTX=a.x<b.x?a.x<c.x?a.x:c.x:b.x<c.x?b.x:c.x,minTY=a.y<b.y?a.y<c.y?a.y:c.y:b.y<c.y?b.y:c.y,maxTX=a.x>b.x?a.x>c.x?a.x:c.x:b.x>c.x?b.x:c.x,maxTY=a.y>b.y?a.y>c.y?a.y:c.y:b.y>c.y?b.y:c.y;// z-order range for the current triangle bbox;
var minZ=zOrder(minTX,minTY,minX,minY,size),maxZ=zOrder(maxTX,maxTY,minX,minY,size);// first look for points inside the triangle in increasing z-order
var p=ear.nextZ;while(p&&p.z<=maxZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.nextZ;}// then look for points in decreasing z-order
p=ear.prevZ;while(p&&p.z>=minZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.prevZ;}return true;}// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start,triangles,dim){var p=start;do{var a=p.prev,b=p.next.next;if(!equals(a,b)&&intersects(a,p,p.next,b)&&locallyInside(a,b)&&locallyInside(b,a)){triangles.push(a.i/dim);triangles.push(p.i/dim);triangles.push(b.i/dim);// remove two nodes involved
removeNode(p);removeNode(p.next);p=start=b;}p=p.next;}while(p!==start);return p;}// try splitting polygon into two and triangulate them independently
function splitEarcut(start,triangles,dim,minX,minY,size){// look for a valid diagonal that divides the polygon into two
var a=start;do{var b=a.next.next;while(b!==a.prev){if(a.i!==b.i&&isValidDiagonal(a,b)){// split the polygon in two by the diagonal
var c=splitPolygon(a,b);// filter colinear points around the cuts
a=filterPoints(a,a.next);c=filterPoints(c,c.next);// run earcut on each half
earcutLinked(a,triangles,dim,minX,minY,size);earcutLinked(c,triangles,dim,minX,minY,size);return;}b=b.next;}a=a.next;}while(a!==start);}// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data,holeIndices,outerNode,dim){var queue=[],i,len,start,end,list;for(i=0,len=holeIndices.length;i<len;i++){start=holeIndices[i]*dim;end=i<len-1?holeIndices[i+1]*dim:data.length;list=linkedList(data,start,end,dim,false);if(list===list.next)list.steiner=true;queue.push(getLeftmost(list));}queue.sort(compareX);// process holes from left to right
for(i=0;i<queue.length;i++){eliminateHole(queue[i],outerNode);outerNode=filterPoints(outerNode,outerNode.next);}return outerNode;}function compareX(a,b){return a.x-b.x;}// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole,outerNode){outerNode=findHoleBridge(hole,outerNode);if(outerNode){var b=splitPolygon(outerNode,hole);filterPoints(b,b.next);}}// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole,outerNode){var p=outerNode,hx=hole.x,hy=hole.y,qx=-Infinity,m;// find a segment intersected by a ray from the hole's leftmost point to the left;
// segment's endpoint with lesser x will be potential connection point
do{if(hy<=p.y&&hy>=p.next.y){var x=p.x+(hy-p.y)*(p.next.x-p.x)/(p.next.y-p.y);if(x<=hx&&x>qx){qx=x;if(x===hx){if(hy===p.y)return p;if(hy===p.next.y)return p.next;}m=p.x<p.next.x?p:p.next;}}p=p.next;}while(p!==outerNode);if(!m)return null;if(hx===qx)return m.prev;// hole touches outer segment; pick lower endpoint
// look for points inside the triangle of hole point, segment intersection and endpoint;
// if there are no points found, we have a valid connection;
// otherwise choose the point of the minimum angle with the ray as connection point
var stop=m,mx=m.x,my=m.y,tanMin=Infinity,tan;p=m.next;while(p!==stop){if(hx>=p.x&&p.x>=mx&&pointInTriangle(hy<my?hx:qx,hy,mx,my,hy<my?qx:hx,hy,p.x,p.y)){tan=Math.abs(hy-p.y)/(hx-p.x);// tangential
if((tan<tanMin||tan===tanMin&&p.x>m.x)&&locallyInside(p,hole)){m=p;tanMin=tan;}}p=p.next;}return m;}// interlink polygon nodes in z-order
function indexCurve(start,minX,minY,size){var p=start;do{if(p.z===null)p.z=zOrder(p.x,p.y,minX,minY,size);p.prevZ=p.prev;p.nextZ=p.next;p=p.next;}while(p!==start);p.prevZ.nextZ=null;p.prevZ=null;sortLinked(p);}// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list){var i,p,q,e,tail,numMerges,pSize,qSize,inSize=1;do{p=list;list=null;tail=null;numMerges=0;while(p){numMerges++;q=p;pSize=0;for(i=0;i<inSize;i++){pSize++;q=q.nextZ;if(!q)break;}qSize=inSize;while(pSize>0||qSize>0&&q){if(pSize===0){e=q;q=q.nextZ;qSize--;}else if(qSize===0||!q){e=p;p=p.nextZ;pSize--;}else if(p.z<=q.z){e=p;p=p.nextZ;pSize--;}else{e=q;q=q.nextZ;qSize--;}if(tail)tail.nextZ=e;else list=e;e.prevZ=tail;tail=e;}p=q;}tail.nextZ=null;inSize*=2;}while(numMerges>1);return list;}// z-order of a point given coords and size of the data bounding box
function zOrder(x,y,minX,minY,size){// coords are transformed into non-negative 15-bit integer range
x=32767*(x-minX)/size;y=32767*(y-minY)/size;x=(x|x<<8)&0x00FF00FF;x=(x|x<<4)&0x0F0F0F0F;x=(x|x<<2)&0x33333333;x=(x|x<<1)&0x55555555;y=(y|y<<8)&0x00FF00FF;y=(y|y<<4)&0x0F0F0F0F;y=(y|y<<2)&0x33333333;y=(y|y<<1)&0x55555555;return x|y<<1;}// find the leftmost node of a polygon ring
function getLeftmost(start){var p=start,leftmost=start;do{if(p.x<leftmost.x)leftmost=p;p=p.next;}while(p!==start);return leftmost;}// check if a point lies within a convex triangle
function pointInTriangle(ax,ay,bx,by,cx,cy,px,py){return(cx-px)*(ay-py)-(ax-px)*(cy-py)>=0&&(ax-px)*(by-py)-(bx-px)*(ay-py)>=0&&(bx-px)*(cy-py)-(cx-px)*(by-py)>=0;}// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a,b){return a.next.i!==b.i&&a.prev.i!==b.i&&!intersectsPolygon(a,b)&&locallyInside(a,b)&&locallyInside(b,a)&&middleInside(a,b);}// signed area of a triangle
function area(p,q,r){return(q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y);}// check if two points are equal
function equals(p1,p2){return p1.x===p2.x&&p1.y===p2.y;}// check if two segments intersect
function intersects(p1,q1,p2,q2){if(equals(p1,q1)&&equals(p2,q2)||equals(p1,q2)&&equals(p2,q1))return true;return area(p1,q1,p2)>0!==area(p1,q1,q2)>0&&area(p2,q2,p1)>0!==area(p2,q2,q1)>0;}// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a,b){var p=a;do{if(p.i!==a.i&&p.next.i!==a.i&&p.i!==b.i&&p.next.i!==b.i&&intersects(p,p.next,a,b))return true;p=p.next;}while(p!==a);return false;}// check if a polygon diagonal is locally inside the polygon
function locallyInside(a,b){return area(a.prev,a,a.next)<0?area(a,b,a.next)>=0&&area(a,a.prev,b)>=0:area(a,b,a.prev)<0||area(a,a.next,b)<0;}// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a,b){var p=a,inside=false,px=(a.x+b.x)/2,py=(a.y+b.y)/2;do{if(p.y>py!==p.next.y>py&&px<(p.next.x-p.x)*(py-p.y)/(p.next.y-p.y)+p.x)inside=!inside;p=p.next;}while(p!==a);return inside;}// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a,b){var a2=new Node(a.i,a.x,a.y),b2=new Node(b.i,b.x,b.y),an=a.next,bp=b.prev;a.next=b;b.prev=a;a2.next=an;an.prev=a2;b2.next=a2;a2.prev=b2;bp.next=b2;b2.prev=bp;return b2;}// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i,x,y,last){var p=new Node(i,x,y);if(!last){p.prev=p;p.next=p;}else{p.next=last.next;p.prev=last;last.next.prev=p;last.next=p;}return p;}function removeNode(p){p.next.prev=p.prev;p.prev.next=p.next;if(p.prevZ)p.prevZ.nextZ=p.nextZ;if(p.nextZ)p.nextZ.prevZ=p.prevZ;}function Node(i,x,y){// vertice index in coordinates array
this.i=i;// vertex coordinates
this.x=x;this.y=y;// previous and next vertice nodes in a polygon ring
this.prev=null;this.next=null;// z-order curve value
this.z=null;// previous and next nodes in z-order
this.prevZ=null;this.nextZ=null;// indicates whether this is a steiner point
this.steiner=false;}// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation=function(data,holeIndices,dim,triangles){var hasHoles=holeIndices&&holeIndices.length;var outerLen=hasHoles?holeIndices[0]*dim:data.length;var polygonArea=Math.abs(signedArea(data,0,outerLen,dim));if(hasHoles){for(var i=0,len=holeIndices.length;i<len;i++){var start=holeIndices[i]*dim;var end=i<len-1?holeIndices[i+1]*dim:data.length;polygonArea-=Math.abs(signedArea(data,start,end,dim));}}var trianglesArea=0;for(i=0;i<triangles.length;i+=3){var a=triangles[i]*dim;var b=triangles[i+1]*dim;var c=triangles[i+2]*dim;trianglesArea+=Math.abs((data[a]-data[c])*(data[b+1]-data[a+1])-(data[a]-data[b])*(data[c+1]-data[a+1]));}return polygonArea===0&&trianglesArea===0?0:Math.abs((trianglesArea-polygonArea)/polygonArea);};function signedArea(data,start,end,dim){var sum=0;for(var i=start,j=end-dim;i<end;i+=dim){sum+=(data[j]-data[i])*(data[i+1]+data[j+1]);j=i;}return sum;}// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten=function(data){var dim=data[0][0].length,result={vertices:[],holes:[],dimensions:dim},holeIndex=0;for(var i=0;i<data.length;i++){for(var j=0;j<data[i].length;j++){for(var d=0;d<dim;d++){result.vertices.push(data[i][j][d]);}}if(i>0){holeIndex+=data[i-1].length;result.holes.push(holeIndex);}}return result;};

},{}],2:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
function EventEmitter(){this._events=this._events||{};this._maxListeners=this._maxListeners||undefined;}module.exports=EventEmitter;// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter=EventEmitter;EventEmitter.prototype._events=undefined;EventEmitter.prototype._maxListeners=undefined;// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners=10;// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners=function(n){if(!isNumber(n)||n<0||isNaN(n))throw TypeError('n must be a positive number');this._maxListeners=n;return this;};EventEmitter.prototype.emit=function(type){var er,handler,len,args,i,listeners;if(!this._events)this._events={};// If there is no 'error' event listener then throw.
if(type==='error'){if(!this._events.error||isObject(this._events.error)&&!this._events.error.length){er=arguments[1];if(er instanceof Error){throw er;// Unhandled 'error' event
}else{// At least give some kind of context to the user
var err=new Error('Uncaught, unspecified "error" event. ('+er+')');err.context=er;throw err;}}}handler=this._events[type];if(isUndefined(handler))return false;if(isFunction(handler)){switch(arguments.length){// fast cases
case 1:handler.call(this);break;case 2:handler.call(this,arguments[1]);break;case 3:handler.call(this,arguments[1],arguments[2]);break;// slower
default:args=Array.prototype.slice.call(arguments,1);handler.apply(this,args);}}else if(isObject(handler)){args=Array.prototype.slice.call(arguments,1);listeners=handler.slice();len=listeners.length;for(i=0;i<len;i++){listeners[i].apply(this,args);}}return true;};EventEmitter.prototype.addListener=function(type,listener){var m;if(!isFunction(listener))throw TypeError('listener must be a function');if(!this._events)this._events={};// To avoid recursion in the case that type === "newListener"! Before
// adding it to the listeners, first emit "newListener".
if(this._events.newListener)this.emit('newListener',type,isFunction(listener.listener)?listener.listener:listener);if(!this._events[type])// Optimize the case of one listener. Don't need the extra array object.
this._events[type]=listener;else if(isObject(this._events[type]))// If we've already got an array, just append.
this._events[type].push(listener);else// Adding the second element, need to change to array.
this._events[type]=[this._events[type],listener];// Check for listener leak
if(isObject(this._events[type])&&!this._events[type].warned){if(!isUndefined(this._maxListeners)){m=this._maxListeners;}else{m=EventEmitter.defaultMaxListeners;}if(m&&m>0&&this._events[type].length>m){this._events[type].warned=true;console.error('(node) warning: possible EventEmitter memory '+'leak detected. %d listeners added. '+'Use emitter.setMaxListeners() to increase limit.',this._events[type].length);if(typeof console.trace==='function'){// not supported in IE 10
console.trace();}}}return this;};EventEmitter.prototype.on=EventEmitter.prototype.addListener;EventEmitter.prototype.once=function(type,listener){if(!isFunction(listener))throw TypeError('listener must be a function');var fired=false;function g(){this.removeListener(type,g);if(!fired){fired=true;listener.apply(this,arguments);}}g.listener=listener;this.on(type,g);return this;};// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener=function(type,listener){var list,position,length,i;if(!isFunction(listener))throw TypeError('listener must be a function');if(!this._events||!this._events[type])return this;list=this._events[type];length=list.length;position=-1;if(list===listener||isFunction(list.listener)&&list.listener===listener){delete this._events[type];if(this._events.removeListener)this.emit('removeListener',type,listener);}else if(isObject(list)){for(i=length;i-->0;){if(list[i]===listener||list[i].listener&&list[i].listener===listener){position=i;break;}}if(position<0)return this;if(list.length===1){list.length=0;delete this._events[type];}else{list.splice(position,1);}if(this._events.removeListener)this.emit('removeListener',type,listener);}return this;};EventEmitter.prototype.removeAllListeners=function(type){var key,listeners;if(!this._events)return this;// not listening for removeListener, no need to emit
if(!this._events.removeListener){if(arguments.length===0)this._events={};else if(this._events[type])delete this._events[type];return this;}// emit removeListener for all listeners on all events
if(arguments.length===0){for(key in this._events){if(key==='removeListener')continue;this.removeAllListeners(key);}this.removeAllListeners('removeListener');this._events={};return this;}listeners=this._events[type];if(isFunction(listeners)){this.removeListener(type,listeners);}else if(listeners){// LIFO order
while(listeners.length){this.removeListener(type,listeners[listeners.length-1]);}}delete this._events[type];return this;};EventEmitter.prototype.listeners=function(type){var ret;if(!this._events||!this._events[type])ret=[];else if(isFunction(this._events[type]))ret=[this._events[type]];else ret=this._events[type].slice();return ret;};EventEmitter.prototype.listenerCount=function(type){if(this._events){var evlistener=this._events[type];if(isFunction(evlistener))return 1;else if(evlistener)return evlistener.length;}return 0;};EventEmitter.listenerCount=function(emitter,type){return emitter.listenerCount(type);};function isFunction(arg){return typeof arg==='function';}function isNumber(arg){return typeof arg==='number';}function isObject(arg){return(typeof arg==='undefined'?'undefined':_typeof(arg))==='object'&&arg!==null;}function isUndefined(arg){return arg===void 0;}

},{}],3:[function(require,module,exports){
'use strict';var getNative=require('./_getNative'),root=require('./_root');/* Built-in method references that are verified to be native. */var DataView=getNative(root,'DataView');module.exports=DataView;

},{"./_getNative":59,"./_root":95}],4:[function(require,module,exports){
'use strict';var hashClear=require('./_hashClear'),hashDelete=require('./_hashDelete'),hashGet=require('./_hashGet'),hashHas=require('./_hashHas'),hashSet=require('./_hashSet');/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;module.exports=Hash;

},{"./_hashClear":65,"./_hashDelete":66,"./_hashGet":67,"./_hashHas":68,"./_hashSet":69}],5:[function(require,module,exports){
'use strict';var listCacheClear=require('./_listCacheClear'),listCacheDelete=require('./_listCacheDelete'),listCacheGet=require('./_listCacheGet'),listCacheHas=require('./_listCacheHas'),listCacheSet=require('./_listCacheSet');/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;module.exports=ListCache;

},{"./_listCacheClear":76,"./_listCacheDelete":77,"./_listCacheGet":78,"./_listCacheHas":79,"./_listCacheSet":80}],6:[function(require,module,exports){
'use strict';var getNative=require('./_getNative'),root=require('./_root');/* Built-in method references that are verified to be native. */var Map=getNative(root,'Map');module.exports=Map;

},{"./_getNative":59,"./_root":95}],7:[function(require,module,exports){
'use strict';var mapCacheClear=require('./_mapCacheClear'),mapCacheDelete=require('./_mapCacheDelete'),mapCacheGet=require('./_mapCacheGet'),mapCacheHas=require('./_mapCacheHas'),mapCacheSet=require('./_mapCacheSet');/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;module.exports=MapCache;

},{"./_mapCacheClear":81,"./_mapCacheDelete":82,"./_mapCacheGet":83,"./_mapCacheHas":84,"./_mapCacheSet":85}],8:[function(require,module,exports){
'use strict';var getNative=require('./_getNative'),root=require('./_root');/* Built-in method references that are verified to be native. */var Promise=getNative(root,'Promise');module.exports=Promise;

},{"./_getNative":59,"./_root":95}],9:[function(require,module,exports){
'use strict';var getNative=require('./_getNative'),root=require('./_root');/* Built-in method references that are verified to be native. */var Set=getNative(root,'Set');module.exports=Set;

},{"./_getNative":59,"./_root":95}],10:[function(require,module,exports){
'use strict';var MapCache=require('./_MapCache'),setCacheAdd=require('./_setCacheAdd'),setCacheHas=require('./_setCacheHas');/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}// Add methods to `SetCache`.
SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;module.exports=SetCache;

},{"./_MapCache":7,"./_setCacheAdd":96,"./_setCacheHas":97}],11:[function(require,module,exports){
'use strict';var ListCache=require('./_ListCache'),stackClear=require('./_stackClear'),stackDelete=require('./_stackDelete'),stackGet=require('./_stackGet'),stackHas=require('./_stackHas'),stackSet=require('./_stackSet');/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;module.exports=Stack;

},{"./_ListCache":5,"./_stackClear":99,"./_stackDelete":100,"./_stackGet":101,"./_stackHas":102,"./_stackSet":103}],12:[function(require,module,exports){
'use strict';var root=require('./_root');/** Built-in value references. */var _Symbol=root.Symbol;module.exports=_Symbol;

},{"./_root":95}],13:[function(require,module,exports){
'use strict';var root=require('./_root');/** Built-in value references. */var Uint8Array=root.Uint8Array;module.exports=Uint8Array;

},{"./_root":95}],14:[function(require,module,exports){
'use strict';var getNative=require('./_getNative'),root=require('./_root');/* Built-in method references that are verified to be native. */var WeakMap=getNative(root,'WeakMap');module.exports=WeakMap;

},{"./_getNative":59,"./_root":95}],15:[function(require,module,exports){
"use strict";/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}module.exports=arrayFilter;

},{}],16:[function(require,module,exports){
'use strict';var baseTimes=require('./_baseTimes'),isArguments=require('./isArguments'),isArray=require('./isArray'),isBuffer=require('./isBuffer'),isIndex=require('./_isIndex'),isTypedArray=require('./isTypedArray');/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
isIndex(key,length)))){result.push(key);}}return result;}module.exports=arrayLikeKeys;

},{"./_baseTimes":43,"./_isIndex":70,"./isArguments":115,"./isArray":116,"./isBuffer":118,"./isTypedArray":124}],17:[function(require,module,exports){
"use strict";/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}module.exports=arrayMap;

},{}],18:[function(require,module,exports){
"use strict";/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}module.exports=arrayPush;

},{}],19:[function(require,module,exports){
"use strict";/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}module.exports=arraySome;

},{}],20:[function(require,module,exports){
'use strict';var eq=require('./eq');/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}module.exports=assocIndexOf;

},{"./eq":110}],21:[function(require,module,exports){
"use strict";/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}module.exports=baseClamp;

},{}],22:[function(require,module,exports){
'use strict';var baseForOwn=require('./_baseForOwn'),createBaseEach=require('./_createBaseEach');/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */var baseEach=createBaseEach(baseForOwn);module.exports=baseEach;

},{"./_baseForOwn":24,"./_createBaseEach":50}],23:[function(require,module,exports){
'use strict';var createBaseFor=require('./_createBaseFor');/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */var baseFor=createBaseFor();module.exports=baseFor;

},{"./_createBaseFor":51}],24:[function(require,module,exports){
'use strict';var baseFor=require('./_baseFor'),keys=require('./keys');/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}module.exports=baseForOwn;

},{"./_baseFor":23,"./keys":125}],25:[function(require,module,exports){
'use strict';var castPath=require('./_castPath'),toKey=require('./_toKey');/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined;}module.exports=baseGet;

},{"./_castPath":48,"./_toKey":105}],26:[function(require,module,exports){
'use strict';var arrayPush=require('./_arrayPush'),isArray=require('./isArray');/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}module.exports=baseGetAllKeys;

},{"./_arrayPush":18,"./isArray":116}],27:[function(require,module,exports){
'use strict';var _Symbol=require('./_Symbol'),getRawTag=require('./_getRawTag'),objectToString=require('./_objectToString');/** `Object#toString` result references. */var nullTag='[object Null]',undefinedTag='[object Undefined]';/** Built-in value references. */var symToStringTag=_Symbol?_Symbol.toStringTag:undefined;/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */function baseGetTag(value){if(value==null){return value===undefined?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}module.exports=baseGetTag;

},{"./_Symbol":12,"./_getRawTag":60,"./_objectToString":93}],28:[function(require,module,exports){
"use strict";/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */function baseHasIn(object,key){return object!=null&&key in Object(object);}module.exports=baseHasIn;

},{}],29:[function(require,module,exports){
'use strict';var baseGetTag=require('./_baseGetTag'),isObjectLike=require('./isObjectLike');/** `Object#toString` result references. */var argsTag='[object Arguments]';/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}module.exports=baseIsArguments;

},{"./_baseGetTag":27,"./isObjectLike":122}],30:[function(require,module,exports){
'use strict';var baseIsEqualDeep=require('./_baseIsEqualDeep'),isObjectLike=require('./isObjectLike');/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}module.exports=baseIsEqual;

},{"./_baseIsEqualDeep":31,"./isObjectLike":122}],31:[function(require,module,exports){
'use strict';var Stack=require('./_Stack'),equalArrays=require('./_equalArrays'),equalByTag=require('./_equalByTag'),equalObjects=require('./_equalObjects'),getTag=require('./_getTag'),isArray=require('./isArray'),isBuffer=require('./isBuffer'),isTypedArray=require('./isTypedArray');/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1;/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',objectTag='[object Object]';/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}module.exports=baseIsEqualDeep;

},{"./_Stack":11,"./_equalArrays":52,"./_equalByTag":53,"./_equalObjects":54,"./_getTag":62,"./isArray":116,"./isBuffer":118,"./isTypedArray":124}],32:[function(require,module,exports){
'use strict';var Stack=require('./_Stack'),baseIsEqual=require('./_baseIsEqual');/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return!length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined&&!(key in object)){return false;}}else{var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}module.exports=baseIsMatch;

},{"./_Stack":11,"./_baseIsEqual":30}],33:[function(require,module,exports){
'use strict';var isFunction=require('./isFunction'),isMasked=require('./_isMasked'),isObject=require('./isObject'),toSource=require('./_toSource');/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used for built-in method references. */var funcProto=Function.prototype,objectProto=Object.prototype;/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}module.exports=baseIsNative;

},{"./_isMasked":73,"./_toSource":106,"./isFunction":119,"./isObject":121}],34:[function(require,module,exports){
'use strict';var baseGetTag=require('./_baseGetTag'),isLength=require('./isLength'),isObjectLike=require('./isObjectLike');/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',boolTag='[object Boolean]',dateTag='[object Date]',errorTag='[object Error]',funcTag='[object Function]',mapTag='[object Map]',numberTag='[object Number]',objectTag='[object Object]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',weakMapTag='[object WeakMap]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}module.exports=baseIsTypedArray;

},{"./_baseGetTag":27,"./isLength":120,"./isObjectLike":122}],35:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var baseMatches=require('./_baseMatches'),baseMatchesProperty=require('./_baseMatchesProperty'),identity=require('./identity'),isArray=require('./isArray'),property=require('./property');/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
if(typeof value=='function'){return value;}if(value==null){return identity;}if((typeof value==='undefined'?'undefined':_typeof(value))=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}module.exports=baseIteratee;

},{"./_baseMatches":39,"./_baseMatchesProperty":40,"./identity":114,"./isArray":116,"./property":130}],36:[function(require,module,exports){
'use strict';var isPrototype=require('./_isPrototype'),nativeKeys=require('./_nativeKeys');/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}module.exports=baseKeys;

},{"./_isPrototype":74,"./_nativeKeys":90}],37:[function(require,module,exports){
'use strict';var isObject=require('./isObject'),isPrototype=require('./_isPrototype'),nativeKeysIn=require('./_nativeKeysIn');/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}module.exports=baseKeysIn;

},{"./_isPrototype":74,"./_nativeKeysIn":91,"./isObject":121}],38:[function(require,module,exports){
'use strict';var baseEach=require('./_baseEach'),isArrayLike=require('./isArrayLike');/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}module.exports=baseMap;

},{"./_baseEach":22,"./isArrayLike":117}],39:[function(require,module,exports){
'use strict';var baseIsMatch=require('./_baseIsMatch'),getMatchData=require('./_getMatchData'),matchesStrictComparable=require('./_matchesStrictComparable');/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}module.exports=baseMatches;

},{"./_baseIsMatch":32,"./_getMatchData":58,"./_matchesStrictComparable":87}],40:[function(require,module,exports){
'use strict';var baseIsEqual=require('./_baseIsEqual'),get=require('./get'),hasIn=require('./hasIn'),isKey=require('./_isKey'),isStrictComparable=require('./_isStrictComparable'),matchesStrictComparable=require('./_matchesStrictComparable'),toKey=require('./_toKey');/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}module.exports=baseMatchesProperty;

},{"./_baseIsEqual":30,"./_isKey":71,"./_isStrictComparable":75,"./_matchesStrictComparable":87,"./_toKey":105,"./get":112,"./hasIn":113}],41:[function(require,module,exports){
"use strict";/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */function baseProperty(key){return function(object){return object==null?undefined:object[key];};}module.exports=baseProperty;

},{}],42:[function(require,module,exports){
'use strict';var baseGet=require('./_baseGet');/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}module.exports=basePropertyDeep;

},{"./_baseGet":25}],43:[function(require,module,exports){
"use strict";/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}module.exports=baseTimes;

},{}],44:[function(require,module,exports){
'use strict';var _Symbol=require('./_Symbol'),arrayMap=require('./_arrayMap'),isArray=require('./isArray'),isSymbol=require('./isSymbol');/** Used as references for various `Number` constants. */var INFINITY=1/0;/** Used to convert symbols to primitives and strings. */var symbolProto=_Symbol?_Symbol.prototype:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}module.exports=baseToString;

},{"./_Symbol":12,"./_arrayMap":17,"./isArray":116,"./isSymbol":123}],45:[function(require,module,exports){
"use strict";/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */function baseUnary(func){return function(value){return func(value);};}module.exports=baseUnary;

},{}],46:[function(require,module,exports){
"use strict";/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function cacheHas(cache,key){return cache.has(key);}module.exports=cacheHas;

},{}],47:[function(require,module,exports){
'use strict';var identity=require('./identity');/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */function castFunction(value){return typeof value=='function'?value:identity;}module.exports=castFunction;

},{"./identity":114}],48:[function(require,module,exports){
'use strict';var isArray=require('./isArray'),isKey=require('./_isKey'),stringToPath=require('./_stringToPath'),toString=require('./toString');/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}module.exports=castPath;

},{"./_isKey":71,"./_stringToPath":104,"./isArray":116,"./toString":135}],49:[function(require,module,exports){
'use strict';var root=require('./_root');/** Used to detect overreaching core-js shims. */var coreJsData=root['__core-js_shared__'];module.exports=coreJsData;

},{"./_root":95}],50:[function(require,module,exports){
'use strict';var isArrayLike=require('./isArrayLike');/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}module.exports=createBaseEach;

},{"./isArrayLike":117}],51:[function(require,module,exports){
"use strict";/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}module.exports=createBaseFor;

},{}],52:[function(require,module,exports){
'use strict';var SetCache=require('./_SetCache'),arraySome=require('./_arraySome'),cacheHas=require('./_cacheHas');/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Assume cyclic values are equal.
var stacked=stack.get(array);if(stacked&&stack.get(other)){return stacked==other;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}module.exports=equalArrays;

},{"./_SetCache":10,"./_arraySome":19,"./_cacheHas":46}],53:[function(require,module,exports){
'use strict';var _Symbol=require('./_Symbol'),Uint8Array=require('./_Uint8Array'),eq=require('./eq'),equalArrays=require('./_equalArrays'),mapToArray=require('./_mapToArray'),setToArray=require('./_setToArray');/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** `Object#toString` result references. */var boolTag='[object Boolean]',dateTag='[object Date]',errorTag='[object Error]',mapTag='[object Map]',numberTag='[object Number]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]';/** Used to convert symbols to primitives and strings. */var symbolProto=_Symbol?_Symbol.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined;/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
// Invalid dates are coerced to `NaN`.
return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
// for more details.
return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}module.exports=equalByTag;

},{"./_Symbol":12,"./_Uint8Array":13,"./_equalArrays":52,"./_mapToArray":86,"./_setToArray":98,"./eq":110}],54:[function(require,module,exports){
'use strict';var getAllKeys=require('./_getAllKeys');/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1;/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked&&stack.get(other)){return stacked==other;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
if(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}module.exports=equalObjects;

},{"./_getAllKeys":56}],55:[function(require,module,exports){
(function (global){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};/** Detect free variable `global` from Node.js. */var freeGlobal=(typeof global==='undefined'?'undefined':_typeof(global))=='object'&&global&&global.Object===Object&&global;module.exports=freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],56:[function(require,module,exports){
'use strict';var baseGetAllKeys=require('./_baseGetAllKeys'),getSymbols=require('./_getSymbols'),keys=require('./keys');/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}module.exports=getAllKeys;

},{"./_baseGetAllKeys":26,"./_getSymbols":61,"./keys":125}],57:[function(require,module,exports){
'use strict';var isKeyable=require('./_isKeyable');/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}module.exports=getMapData;

},{"./_isKeyable":72}],58:[function(require,module,exports){
'use strict';var isStrictComparable=require('./_isStrictComparable'),keys=require('./keys');/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}module.exports=getMatchData;

},{"./_isStrictComparable":75,"./keys":125}],59:[function(require,module,exports){
'use strict';var baseIsNative=require('./_baseIsNative'),getValue=require('./_getValue');/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}module.exports=getNative;

},{"./_baseIsNative":33,"./_getValue":63}],60:[function(require,module,exports){
'use strict';var _Symbol=require('./_Symbol');/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */var nativeObjectToString=objectProto.toString;/** Built-in value references. */var symToStringTag=_Symbol?_Symbol.toStringTag:undefined;/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else{delete value[symToStringTag];}}return result;}module.exports=getRawTag;

},{"./_Symbol":12}],61:[function(require,module,exports){
'use strict';var arrayFilter=require('./_arrayFilter'),stubArray=require('./stubArray');/** Used for built-in method references. */var objectProto=Object.prototype;/** Built-in value references. */var propertyIsEnumerable=objectProto.propertyIsEnumerable;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeGetSymbols=Object.getOwnPropertySymbols;/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return[];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};module.exports=getSymbols;

},{"./_arrayFilter":15,"./stubArray":131}],62:[function(require,module,exports){
'use strict';var DataView=require('./_DataView'),Map=require('./_Map'),Promise=require('./_Promise'),Set=require('./_Set'),WeakMap=require('./_WeakMap'),baseGetTag=require('./_baseGetTag'),toSource=require('./_toSource');/** `Object#toString` result references. */var mapTag='[object Map]',objectTag='[object Object]',promiseTag='[object Promise]',setTag='[object Set]',weakMapTag='[object WeakMap]';var dataViewTag='[object DataView]';/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function getTag(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}module.exports=getTag;

},{"./_DataView":3,"./_Map":6,"./_Promise":8,"./_Set":9,"./_WeakMap":14,"./_baseGetTag":27,"./_toSource":106}],63:[function(require,module,exports){
"use strict";/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */function getValue(object,key){return object==null?undefined:object[key];}module.exports=getValue;

},{}],64:[function(require,module,exports){
'use strict';var castPath=require('./_castPath'),isArguments=require('./isArguments'),isArray=require('./isArray'),isIndex=require('./_isIndex'),isLength=require('./isLength'),toKey=require('./_toKey');/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return!!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}module.exports=hasPath;

},{"./_castPath":48,"./_isIndex":70,"./_toKey":105,"./isArguments":115,"./isArray":116,"./isLength":120}],65:[function(require,module,exports){
'use strict';var nativeCreate=require('./_nativeCreate');/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}module.exports=hashClear;

},{"./_nativeCreate":89}],66:[function(require,module,exports){
"use strict";/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}module.exports=hashDelete;

},{}],67:[function(require,module,exports){
'use strict';var nativeCreate=require('./_nativeCreate');/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}module.exports=hashGet;

},{"./_nativeCreate":89}],68:[function(require,module,exports){
'use strict';var nativeCreate=require('./_nativeCreate');/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}module.exports=hashHas;

},{"./_nativeCreate":89}],69:[function(require,module,exports){
'use strict';var nativeCreate=require('./_nativeCreate');/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}module.exports=hashSet;

},{"./_nativeCreate":89}],70:[function(require,module,exports){
'use strict';/** Used as references for various `Number` constants. */var MAX_SAFE_INTEGER=9007199254740991;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */function isIndex(value,length){length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(typeof value=='number'||reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}module.exports=isIndex;

},{}],71:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var isArray=require('./isArray'),isSymbol=require('./isSymbol');/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/;/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */function isKey(value,object){if(isArray(value)){return false;}var type=typeof value==='undefined'?'undefined':_typeof(value);if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}module.exports=isKey;

},{"./isArray":116,"./isSymbol":123}],72:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */function isKeyable(value){var type=typeof value==='undefined'?'undefined':_typeof(value);return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}module.exports=isKeyable;

},{}],73:[function(require,module,exports){
'use strict';var coreJsData=require('./_coreJsData');/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}module.exports=isMasked;

},{"./_coreJsData":49}],74:[function(require,module,exports){
'use strict';/** Used for built-in method references. */var objectProto=Object.prototype;/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}module.exports=isPrototype;

},{}],75:[function(require,module,exports){
'use strict';var isObject=require('./isObject');/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */function isStrictComparable(value){return value===value&&!isObject(value);}module.exports=isStrictComparable;

},{"./isObject":121}],76:[function(require,module,exports){
"use strict";/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */function listCacheClear(){this.__data__=[];this.size=0;}module.exports=listCacheClear;

},{}],77:[function(require,module,exports){
'use strict';var assocIndexOf=require('./_assocIndexOf');/** Used for built-in method references. */var arrayProto=Array.prototype;/** Built-in value references. */var splice=arrayProto.splice;/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}module.exports=listCacheDelete;

},{"./_assocIndexOf":20}],78:[function(require,module,exports){
'use strict';var assocIndexOf=require('./_assocIndexOf');/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}module.exports=listCacheGet;

},{"./_assocIndexOf":20}],79:[function(require,module,exports){
'use strict';var assocIndexOf=require('./_assocIndexOf');/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}module.exports=listCacheHas;

},{"./_assocIndexOf":20}],80:[function(require,module,exports){
'use strict';var assocIndexOf=require('./_assocIndexOf');/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}module.exports=listCacheSet;

},{"./_assocIndexOf":20}],81:[function(require,module,exports){
'use strict';var Hash=require('./_Hash'),ListCache=require('./_ListCache'),Map=require('./_Map');/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}module.exports=mapCacheClear;

},{"./_Hash":4,"./_ListCache":5,"./_Map":6}],82:[function(require,module,exports){
'use strict';var getMapData=require('./_getMapData');/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}module.exports=mapCacheDelete;

},{"./_getMapData":57}],83:[function(require,module,exports){
'use strict';var getMapData=require('./_getMapData');/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function mapCacheGet(key){return getMapData(this,key).get(key);}module.exports=mapCacheGet;

},{"./_getMapData":57}],84:[function(require,module,exports){
'use strict';var getMapData=require('./_getMapData');/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function mapCacheHas(key){return getMapData(this,key).has(key);}module.exports=mapCacheHas;

},{"./_getMapData":57}],85:[function(require,module,exports){
'use strict';var getMapData=require('./_getMapData');/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}module.exports=mapCacheSet;

},{"./_getMapData":57}],86:[function(require,module,exports){
"use strict";/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}module.exports=mapToArray;

},{}],87:[function(require,module,exports){
"use strict";/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined||key in Object(object));};}module.exports=matchesStrictComparable;

},{}],88:[function(require,module,exports){
'use strict';var memoize=require('./memoize');/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}module.exports=memoizeCapped;

},{"./memoize":128}],89:[function(require,module,exports){
'use strict';var getNative=require('./_getNative');/* Built-in method references that are verified to be native. */var nativeCreate=getNative(Object,'create');module.exports=nativeCreate;

},{"./_getNative":59}],90:[function(require,module,exports){
'use strict';var overArg=require('./_overArg');/* Built-in method references for those with the same name as other `lodash` methods. */var nativeKeys=overArg(Object.keys,Object);module.exports=nativeKeys;

},{"./_overArg":94}],91:[function(require,module,exports){
"use strict";/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}module.exports=nativeKeysIn;

},{}],92:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var freeGlobal=require('./_freeGlobal');/** Detect free variable `exports`. */var freeExports=(typeof exports==='undefined'?'undefined':_typeof(exports))=='object'&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&(typeof module==='undefined'?'undefined':_typeof(module))=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();module.exports=nodeUtil;

},{"./_freeGlobal":55}],93:[function(require,module,exports){
"use strict";/** Used for built-in method references. */var objectProto=Object.prototype;/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */var nativeObjectToString=objectProto.toString;/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */function objectToString(value){return nativeObjectToString.call(value);}module.exports=objectToString;

},{}],94:[function(require,module,exports){
"use strict";/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */function overArg(func,transform){return function(arg){return func(transform(arg));};}module.exports=overArg;

},{}],95:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var freeGlobal=require('./_freeGlobal');/** Detect free variable `self`. */var freeSelf=(typeof self==='undefined'?'undefined':_typeof(self))=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();module.exports=root;

},{"./_freeGlobal":55}],96:[function(require,module,exports){
'use strict';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}module.exports=setCacheAdd;

},{}],97:[function(require,module,exports){
"use strict";/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */function setCacheHas(value){return this.__data__.has(value);}module.exports=setCacheHas;

},{}],98:[function(require,module,exports){
"use strict";/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}module.exports=setToArray;

},{}],99:[function(require,module,exports){
'use strict';var ListCache=require('./_ListCache');/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */function stackClear(){this.__data__=new ListCache();this.size=0;}module.exports=stackClear;

},{"./_ListCache":5}],100:[function(require,module,exports){
'use strict';/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}module.exports=stackDelete;

},{}],101:[function(require,module,exports){
"use strict";/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function stackGet(key){return this.__data__.get(key);}module.exports=stackGet;

},{}],102:[function(require,module,exports){
"use strict";/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function stackHas(key){return this.__data__.has(key);}module.exports=stackHas;

},{}],103:[function(require,module,exports){
'use strict';var ListCache=require('./_ListCache'),Map=require('./_Map'),MapCache=require('./_MapCache');/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}module.exports=stackSet;

},{"./_ListCache":5,"./_Map":6,"./_MapCache":7}],104:[function(require,module,exports){
'use strict';var memoizeCapped=require('./_memoizeCapped');/** Used to match property names within property paths. */var reLeadingDot=/^\./,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */var stringToPath=memoizeCapped(function(string){var result=[];if(reLeadingDot.test(string)){result.push('');}string.replace(rePropName,function(match,number,quote,string){result.push(quote?string.replace(reEscapeChar,'$1'):number||match);});return result;});module.exports=stringToPath;

},{"./_memoizeCapped":88}],105:[function(require,module,exports){
'use strict';var isSymbol=require('./isSymbol');/** Used as references for various `Number` constants. */var INFINITY=1/0;/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}module.exports=toKey;

},{"./isSymbol":123}],106:[function(require,module,exports){
'use strict';/** Used for built-in method references. */var funcProto=Function.prototype;/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}module.exports=toSource;

},{}],107:[function(require,module,exports){
'use strict';var baseClamp=require('./_baseClamp'),toNumber=require('./toNumber');/**
 * Clamps `number` within the inclusive `lower` and `upper` bounds.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Number
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 * @example
 *
 * _.clamp(-10, -5, 5);
 * // => -5
 *
 * _.clamp(10, -5, 5);
 * // => 5
 */function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}module.exports=clamp;

},{"./_baseClamp":21,"./toNumber":134}],108:[function(require,module,exports){
'use strict';var isObject=require('./isObject'),now=require('./now'),toNumber=require('./toNumber');/** Error message constants. */var FUNC_ERROR_TEXT='Expected a function';/* Built-in method references for those with the same name as other `lodash` methods. */var nativeMax=Math.max,nativeMin=Math.min;/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
lastInvokeTime=time;// Start the timer for the trailing edge.
timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,result=wait-timeSinceLastCall;return maxing?nativeMin(result,maxWait-timeSinceLastInvoke):result;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
// trailing edge, the system time has gone backwards and we're treating
// it as the trailing edge, or we've hit the `maxWait` limit.
return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;// Only invoke if we have `lastArgs` which means `func` has been
// debounced at least once.
if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}module.exports=debounce;

},{"./isObject":121,"./now":129,"./toNumber":134}],109:[function(require,module,exports){
"use strict";/**
 * Checks `value` to determine whether a default value should be returned in
 * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
 * or `undefined`.
 *
 * @static
 * @memberOf _
 * @since 4.14.0
 * @category Util
 * @param {*} value The value to check.
 * @param {*} defaultValue The default value.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * _.defaultTo(1, 10);
 * // => 1
 *
 * _.defaultTo(undefined, 10);
 * // => 10
 */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}module.exports=defaultTo;

},{}],110:[function(require,module,exports){
"use strict";/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */function eq(value,other){return value===other||value!==value&&other!==other;}module.exports=eq;

},{}],111:[function(require,module,exports){
'use strict';var baseFor=require('./_baseFor'),castFunction=require('./_castFunction'),keysIn=require('./keysIn');/**
 * Iterates over own and inherited enumerable string keyed properties of an
 * object and invokes `iteratee` for each property. The iteratee is invoked
 * with three arguments: (value, key, object). Iteratee functions may exit
 * iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forInRight
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forIn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
 */function forIn(object,iteratee){return object==null?object:baseFor(object,castFunction(iteratee),keysIn);}module.exports=forIn;

},{"./_baseFor":23,"./_castFunction":47,"./keysIn":126}],112:[function(require,module,exports){
'use strict';var baseGet=require('./_baseGet');/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */function get(object,path,defaultValue){var result=object==null?undefined:baseGet(object,path);return result===undefined?defaultValue:result;}module.exports=get;

},{"./_baseGet":25}],113:[function(require,module,exports){
'use strict';var baseHasIn=require('./_baseHasIn'),hasPath=require('./_hasPath');/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}module.exports=hasIn;

},{"./_baseHasIn":28,"./_hasPath":64}],114:[function(require,module,exports){
"use strict";/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */function identity(value){return value;}module.exports=identity;

},{}],115:[function(require,module,exports){
'use strict';var baseIsArguments=require('./_baseIsArguments'),isObjectLike=require('./isObjectLike');/** Used for built-in method references. */var objectProto=Object.prototype;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Built-in value references. */var propertyIsEnumerable=objectProto.propertyIsEnumerable;/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};module.exports=isArguments;

},{"./_baseIsArguments":29,"./isObjectLike":122}],116:[function(require,module,exports){
"use strict";/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */var isArray=Array.isArray;module.exports=isArray;

},{}],117:[function(require,module,exports){
'use strict';var isFunction=require('./isFunction'),isLength=require('./isLength');/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}module.exports=isArrayLike;

},{"./isFunction":119,"./isLength":120}],118:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var root=require('./_root'),stubFalse=require('./stubFalse');/** Detect free variable `exports`. */var freeExports=(typeof exports==='undefined'?'undefined':_typeof(exports))=='object'&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&(typeof module==='undefined'?'undefined':_typeof(module))=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Built-in value references. */var Buffer=moduleExports?root.Buffer:undefined;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeIsBuffer=Buffer?Buffer.isBuffer:undefined;/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */var isBuffer=nativeIsBuffer||stubFalse;module.exports=isBuffer;

},{"./_root":95,"./stubFalse":132}],119:[function(require,module,exports){
'use strict';var baseGetTag=require('./_baseGetTag'),isObject=require('./isObject');/** `Object#toString` result references. */var asyncTag='[object AsyncFunction]',funcTag='[object Function]',genTag='[object GeneratorFunction]',proxyTag='[object Proxy]';/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 9 which returns 'object' for typed arrays and other constructors.
var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}module.exports=isFunction;

},{"./_baseGetTag":27,"./isObject":121}],120:[function(require,module,exports){
'use strict';/** Used as references for various `Number` constants. */var MAX_SAFE_INTEGER=9007199254740991;/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}module.exports=isLength;

},{}],121:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */function isObject(value){var type=typeof value==='undefined'?'undefined':_typeof(value);return value!=null&&(type=='object'||type=='function');}module.exports=isObject;

},{}],122:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */function isObjectLike(value){return value!=null&&(typeof value==='undefined'?'undefined':_typeof(value))=='object';}module.exports=isObjectLike;

},{}],123:[function(require,module,exports){
'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var baseGetTag=require('./_baseGetTag'),isObjectLike=require('./isObjectLike');/** `Object#toString` result references. */var symbolTag='[object Symbol]';/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */function isSymbol(value){return(typeof value==='undefined'?'undefined':_typeof(value))=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}module.exports=isSymbol;

},{"./_baseGetTag":27,"./isObjectLike":122}],124:[function(require,module,exports){
'use strict';var baseIsTypedArray=require('./_baseIsTypedArray'),baseUnary=require('./_baseUnary'),nodeUtil=require('./_nodeUtil');/* Node.js helper references. */var nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;module.exports=isTypedArray;

},{"./_baseIsTypedArray":34,"./_baseUnary":45,"./_nodeUtil":92}],125:[function(require,module,exports){
'use strict';var arrayLikeKeys=require('./_arrayLikeKeys'),baseKeys=require('./_baseKeys'),isArrayLike=require('./isArrayLike');/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}module.exports=keys;

},{"./_arrayLikeKeys":16,"./_baseKeys":36,"./isArrayLike":117}],126:[function(require,module,exports){
'use strict';var arrayLikeKeys=require('./_arrayLikeKeys'),baseKeysIn=require('./_baseKeysIn'),isArrayLike=require('./isArrayLike');/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}module.exports=keysIn;

},{"./_arrayLikeKeys":16,"./_baseKeysIn":37,"./isArrayLike":117}],127:[function(require,module,exports){
'use strict';var arrayMap=require('./_arrayMap'),baseIteratee=require('./_baseIteratee'),baseMap=require('./_baseMap'),isArray=require('./isArray');/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,baseIteratee(iteratee,3));}module.exports=map;

},{"./_arrayMap":17,"./_baseIteratee":35,"./_baseMap":38,"./isArray":116}],128:[function(require,module,exports){
'use strict';var MapCache=require('./_MapCache');/** Error message constants. */var FUNC_ERROR_TEXT='Expected a function';/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function memoized(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
memoize.Cache=MapCache;module.exports=memoize;

},{"./_MapCache":7}],129:[function(require,module,exports){
'use strict';var root=require('./_root');/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */var now=function now(){return root.Date.now();};module.exports=now;

},{"./_root":95}],130:[function(require,module,exports){
'use strict';var baseProperty=require('./_baseProperty'),basePropertyDeep=require('./_basePropertyDeep'),isKey=require('./_isKey'),toKey=require('./_toKey');/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}module.exports=property;

},{"./_baseProperty":41,"./_basePropertyDeep":42,"./_isKey":71,"./_toKey":105}],131:[function(require,module,exports){
"use strict";/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */function stubArray(){return[];}module.exports=stubArray;

},{}],132:[function(require,module,exports){
"use strict";/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */function stubFalse(){return false;}module.exports=stubFalse;

},{}],133:[function(require,module,exports){
'use strict';var debounce=require('./debounce'),isObject=require('./isObject');/** Error message constants. */var FUNC_ERROR_TEXT='Expected a function';/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}module.exports=throttle;

},{"./debounce":108,"./isObject":121}],134:[function(require,module,exports){
'use strict';var isObject=require('./isObject'),isSymbol=require('./isSymbol');/** Used as references for various `Number` constants. */var NAN=0/0;/** Used to match leading and trailing whitespace. */var reTrim=/^\s+|\s+$/g;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Built-in method references without a dependency on `root`. */var freeParseInt=parseInt;/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=value.replace(reTrim,'');var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}module.exports=toNumber;

},{"./isObject":121,"./isSymbol":123}],135:[function(require,module,exports){
'use strict';var baseToString=require('./_baseToString');/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */function toString(value){return value==null?'':baseToString(value);}module.exports=toString;

},{"./_baseToString":44}],136:[function(require,module,exports){
'use strict';module.exports=partialSort;// Floyd-Rivest selection algorithm:
// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];
// The k-th element will have the (k - left + 1)th smallest value in [left, right]
function partialSort(arr,k,left,right,compare){left=left||0;right=right||arr.length-1;compare=compare||defaultCompare;while(right>left){if(right-left>600){var n=right-left+1;var m=k-left+1;var z=Math.log(n);var s=0.5*Math.exp(2*z/3);var sd=0.5*Math.sqrt(z*s*(n-s)/n)*(m-n/2<0?-1:1);var newLeft=Math.max(left,Math.floor(k-m*s/n+sd));var newRight=Math.min(right,Math.floor(k+(n-m)*s/n+sd));partialSort(arr,k,newLeft,newRight,compare);}var t=arr[k];var i=left;var j=right;swap(arr,left,k);if(compare(arr[right],t)>0)swap(arr,left,right);while(i<j){swap(arr,i,j);i++;j--;while(compare(arr[i],t)<0){i++;}while(compare(arr[j],t)>0){j--;}}if(compare(arr[left],t)===0)swap(arr,left,j);else{j++;swap(arr,j,right);}if(j<=k)left=j+1;if(k<=j)right=j-1;}}function swap(arr,i,j){var tmp=arr[i];arr[i]=arr[j];arr[j]=tmp;}function defaultCompare(a,b){return a<b?-1:a>b?1:0;}

},{}],137:[function(require,module,exports){
'use strict';module.exports=rbush;var quickselect=require('quickselect');function rbush(maxEntries,format){if(!(this instanceof rbush))return new rbush(maxEntries,format);// max entries in a node is 9 by default; min node fill is 40% for best performance
this._maxEntries=Math.max(4,maxEntries||9);this._minEntries=Math.max(2,Math.ceil(this._maxEntries*0.4));if(format){this._initFormat(format);}this.clear();}rbush.prototype={all:function all(){return this._all(this.data,[]);},search:function search(bbox){var node=this.data,result=[],toBBox=this.toBBox;if(!intersects(bbox,node))return result;var nodesToSearch=[],i,len,child,childBBox;while(node){for(i=0,len=node.children.length;i<len;i++){child=node.children[i];childBBox=node.leaf?toBBox(child):child;if(intersects(bbox,childBBox)){if(node.leaf)result.push(child);else if(contains(bbox,childBBox))this._all(child,result);else nodesToSearch.push(child);}}node=nodesToSearch.pop();}return result;},collides:function collides(bbox){var node=this.data,toBBox=this.toBBox;if(!intersects(bbox,node))return false;var nodesToSearch=[],i,len,child,childBBox;while(node){for(i=0,len=node.children.length;i<len;i++){child=node.children[i];childBBox=node.leaf?toBBox(child):child;if(intersects(bbox,childBBox)){if(node.leaf||contains(bbox,childBBox))return true;nodesToSearch.push(child);}}node=nodesToSearch.pop();}return false;},load:function load(data){if(!(data&&data.length))return this;if(data.length<this._minEntries){for(var i=0,len=data.length;i<len;i++){this.insert(data[i]);}return this;}// recursively build the tree with the given data from stratch using OMT algorithm
var node=this._build(data.slice(),0,data.length-1,0);if(!this.data.children.length){// save as is if tree is empty
this.data=node;}else if(this.data.height===node.height){// split root if trees have the same height
this._splitRoot(this.data,node);}else{if(this.data.height<node.height){// swap trees if inserted one is bigger
var tmpNode=this.data;this.data=node;node=tmpNode;}// insert the small tree into the large tree at appropriate level
this._insert(node,this.data.height-node.height-1,true);}return this;},insert:function insert(item){if(item)this._insert(item,this.data.height-1);return this;},clear:function clear(){this.data=createNode([]);return this;},remove:function remove(item,equalsFn){if(!item)return this;var node=this.data,bbox=this.toBBox(item),path=[],indexes=[],i,parent,index,goingUp;// depth-first iterative tree traversal
while(node||path.length){if(!node){// go up
node=path.pop();parent=path[path.length-1];i=indexes.pop();goingUp=true;}if(node.leaf){// check current node
index=findItem(item,node.children,equalsFn);if(index!==-1){// item found, remove the item and condense tree upwards
node.children.splice(index,1);path.push(node);this._condense(path);return this;}}if(!goingUp&&!node.leaf&&contains(node,bbox)){// go down
path.push(node);indexes.push(i);i=0;parent=node;node=node.children[0];}else if(parent){// go right
i++;node=parent.children[i];goingUp=false;}else node=null;// nothing found
}return this;},toBBox:function toBBox(item){return item;},compareMinX:compareNodeMinX,compareMinY:compareNodeMinY,toJSON:function toJSON(){return this.data;},fromJSON:function fromJSON(data){this.data=data;return this;},_all:function _all(node,result){var nodesToSearch=[];while(node){if(node.leaf)result.push.apply(result,node.children);else nodesToSearch.push.apply(nodesToSearch,node.children);node=nodesToSearch.pop();}return result;},_build:function _build(items,left,right,height){var N=right-left+1,M=this._maxEntries,node;if(N<=M){// reached leaf level; return leaf
node=createNode(items.slice(left,right+1));calcBBox(node,this.toBBox);return node;}if(!height){// target height of the bulk-loaded tree
height=Math.ceil(Math.log(N)/Math.log(M));// target number of root entries to maximize storage utilization
M=Math.ceil(N/Math.pow(M,height-1));}node=createNode([]);node.leaf=false;node.height=height;// split the items into M mostly square tiles
var N2=Math.ceil(N/M),N1=N2*Math.ceil(Math.sqrt(M)),i,j,right2,right3;multiSelect(items,left,right,N1,this.compareMinX);for(i=left;i<=right;i+=N1){right2=Math.min(i+N1-1,right);multiSelect(items,i,right2,N2,this.compareMinY);for(j=i;j<=right2;j+=N2){right3=Math.min(j+N2-1,right2);// pack each entry recursively
node.children.push(this._build(items,j,right3,height-1));}}calcBBox(node,this.toBBox);return node;},_chooseSubtree:function _chooseSubtree(bbox,node,level,path){var i,len,child,targetNode,area,enlargement,minArea,minEnlargement;while(true){path.push(node);if(node.leaf||path.length-1===level)break;minArea=minEnlargement=Infinity;for(i=0,len=node.children.length;i<len;i++){child=node.children[i];area=bboxArea(child);enlargement=enlargedArea(bbox,child)-area;// choose entry with the least area enlargement
if(enlargement<minEnlargement){minEnlargement=enlargement;minArea=area<minArea?area:minArea;targetNode=child;}else if(enlargement===minEnlargement){// otherwise choose one with the smallest area
if(area<minArea){minArea=area;targetNode=child;}}}node=targetNode||node.children[0];}return node;},_insert:function _insert(item,level,isNode){var toBBox=this.toBBox,bbox=isNode?item:toBBox(item),insertPath=[];// find the best node for accommodating the item, saving all nodes along the path too
var node=this._chooseSubtree(bbox,this.data,level,insertPath);// put the item into the node
node.children.push(item);extend(node,bbox);// split on node overflow; propagate upwards if necessary
while(level>=0){if(insertPath[level].children.length>this._maxEntries){this._split(insertPath,level);level--;}else break;}// adjust bboxes along the insertion path
this._adjustParentBBoxes(bbox,insertPath,level);},// split overflowed node into two
_split:function _split(insertPath,level){var node=insertPath[level],M=node.children.length,m=this._minEntries;this._chooseSplitAxis(node,m,M);var splitIndex=this._chooseSplitIndex(node,m,M);var newNode=createNode(node.children.splice(splitIndex,node.children.length-splitIndex));newNode.height=node.height;newNode.leaf=node.leaf;calcBBox(node,this.toBBox);calcBBox(newNode,this.toBBox);if(level)insertPath[level-1].children.push(newNode);else this._splitRoot(node,newNode);},_splitRoot:function _splitRoot(node,newNode){// split root node
this.data=createNode([node,newNode]);this.data.height=node.height+1;this.data.leaf=false;calcBBox(this.data,this.toBBox);},_chooseSplitIndex:function _chooseSplitIndex(node,m,M){var i,bbox1,bbox2,overlap,area,minOverlap,minArea,index;minOverlap=minArea=Infinity;for(i=m;i<=M-m;i++){bbox1=distBBox(node,0,i,this.toBBox);bbox2=distBBox(node,i,M,this.toBBox);overlap=intersectionArea(bbox1,bbox2);area=bboxArea(bbox1)+bboxArea(bbox2);// choose distribution with minimum overlap
if(overlap<minOverlap){minOverlap=overlap;index=i;minArea=area<minArea?area:minArea;}else if(overlap===minOverlap){// otherwise choose distribution with minimum area
if(area<minArea){minArea=area;index=i;}}}return index;},// sorts node children by the best axis for split
_chooseSplitAxis:function _chooseSplitAxis(node,m,M){var compareMinX=node.leaf?this.compareMinX:compareNodeMinX,compareMinY=node.leaf?this.compareMinY:compareNodeMinY,xMargin=this._allDistMargin(node,m,M,compareMinX),yMargin=this._allDistMargin(node,m,M,compareMinY);// if total distributions margin value is minimal for x, sort by minX,
// otherwise it's already sorted by minY
if(xMargin<yMargin)node.children.sort(compareMinX);},// total margin of all possible split distributions where each node is at least m full
_allDistMargin:function _allDistMargin(node,m,M,compare){node.children.sort(compare);var toBBox=this.toBBox,leftBBox=distBBox(node,0,m,toBBox),rightBBox=distBBox(node,M-m,M,toBBox),margin=bboxMargin(leftBBox)+bboxMargin(rightBBox),i,child;for(i=m;i<M-m;i++){child=node.children[i];extend(leftBBox,node.leaf?toBBox(child):child);margin+=bboxMargin(leftBBox);}for(i=M-m-1;i>=m;i--){child=node.children[i];extend(rightBBox,node.leaf?toBBox(child):child);margin+=bboxMargin(rightBBox);}return margin;},_adjustParentBBoxes:function _adjustParentBBoxes(bbox,path,level){// adjust bboxes along the given tree path
for(var i=level;i>=0;i--){extend(path[i],bbox);}},_condense:function _condense(path){// go through the path, removing empty nodes and updating bboxes
for(var i=path.length-1,siblings;i>=0;i--){if(path[i].children.length===0){if(i>0){siblings=path[i-1].children;siblings.splice(siblings.indexOf(path[i]),1);}else this.clear();}else calcBBox(path[i],this.toBBox);}},_initFormat:function _initFormat(format){// data format (minX, minY, maxX, maxY accessors)
// uses eval-type function compilation instead of just accepting a toBBox function
// because the algorithms are very sensitive to sorting functions performance,
// so they should be dead simple and without inner calls
var compareArr=['return a',' - b',';'];this.compareMinX=new Function('a','b',compareArr.join(format[0]));this.compareMinY=new Function('a','b',compareArr.join(format[1]));this.toBBox=new Function('a','return {minX: a'+format[0]+', minY: a'+format[1]+', maxX: a'+format[2]+', maxY: a'+format[3]+'};');}};function findItem(item,items,equalsFn){if(!equalsFn)return items.indexOf(item);for(var i=0;i<items.length;i++){if(equalsFn(item,items[i]))return i;}return-1;}// calculate node's bbox from bboxes of its children
function calcBBox(node,toBBox){distBBox(node,0,node.children.length,toBBox,node);}// min bounding rectangle of node children from k to p-1
function distBBox(node,k,p,toBBox,destNode){if(!destNode)destNode=createNode(null);destNode.minX=Infinity;destNode.minY=Infinity;destNode.maxX=-Infinity;destNode.maxY=-Infinity;for(var i=k,child;i<p;i++){child=node.children[i];extend(destNode,node.leaf?toBBox(child):child);}return destNode;}function extend(a,b){a.minX=Math.min(a.minX,b.minX);a.minY=Math.min(a.minY,b.minY);a.maxX=Math.max(a.maxX,b.maxX);a.maxY=Math.max(a.maxY,b.maxY);return a;}function compareNodeMinX(a,b){return a.minX-b.minX;}function compareNodeMinY(a,b){return a.minY-b.minY;}function bboxArea(a){return(a.maxX-a.minX)*(a.maxY-a.minY);}function bboxMargin(a){return a.maxX-a.minX+(a.maxY-a.minY);}function enlargedArea(a,b){return(Math.max(b.maxX,a.maxX)-Math.min(b.minX,a.minX))*(Math.max(b.maxY,a.maxY)-Math.min(b.minY,a.minY));}function intersectionArea(a,b){var minX=Math.max(a.minX,b.minX),minY=Math.max(a.minY,b.minY),maxX=Math.min(a.maxX,b.maxX),maxY=Math.min(a.maxY,b.maxY);return Math.max(0,maxX-minX)*Math.max(0,maxY-minY);}function contains(a,b){return a.minX<=b.minX&&a.minY<=b.minY&&b.maxX<=a.maxX&&b.maxY<=a.maxY;}function intersects(a,b){return b.minX<=a.maxX&&b.minY<=a.maxY&&b.maxX>=a.minX&&b.maxY>=a.minY;}function createNode(children){return{children:children,height:1,leaf:true,minX:Infinity,minY:Infinity,maxX:-Infinity,maxY:-Infinity};}// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach
function multiSelect(arr,left,right,n,compare){var stack=[left,right],mid;while(stack.length){right=stack.pop();left=stack.pop();if(right-left<=n)continue;mid=left+Math.ceil((right-left)/n/2)*n;quickselect(arr,mid,left,right,compare);stack.push(left,mid,mid,right);}}

},{"quickselect":136}],138:[function(require,module,exports){
'use strict';/**
 * Class representing an event.
 */function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var Event=/**
	 * Instantiates a new Event object.
	 *
	 * @param {Object} target - The object that fired the event.
	 * @param {number} timestamp - The timestamp when the event was created. Optional.
	 */function Event(target){var timestamp=arguments.length>1&&arguments[1]!==undefined?arguments[1]:Date.now();_classCallCheck(this,Event);this.target=target;this.timestamp=timestamp;};module.exports=Event;

},{}],139:[function(require,module,exports){
'use strict';/**
 * Class representing an event broadcaster.
 * @private
 */var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var EventBroadcaster=function(){/**
	 * Instantiates a new EventBroadcaster object.
	 *
	 * @param {Plot} plot - The plot to attach the broadcaster to.
	 */function EventBroadcaster(plot){_classCallCheck(this,EventBroadcaster);this.plot=plot;}/**
	 * Broadcasts the provided event type to all children of the plot.
	 *
	 * @param {string} type - The event type to broadcast.
	 */_createClass(EventBroadcaster,[{key:'broadcast',value:function broadcast(type){var _this=this;this.plot.on(type,function(event){var children=_this.plot.getSortedLayers();for(var i=children.length-1;i>=0;i--){if(!children[i].isHidden()){children[i].emit(type,event);}}});}}]);return EventBroadcaster;}();module.exports=EventBroadcaster;

},{}],140:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _DELEGATION_FUNCS;function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}var EventType=require('./EventType');var MouseEvent=require('./MouseEvent');var setCursor=function setCursor(plot){plot.getContainer().style.cursor='pointer';};var resetCursor=function resetCursor(plot){plot.getContainer().style.cursor='inherit';};var copyEvent=function copyEvent(target,data,event){return new MouseEvent(target,event.originalEvent,{x:event.pos.x,y:event.pos.y},{x:event.px.x,y:event.px.y},data);};var delegateMouseMove=function delegateMouseMove(delegator,child,event,collision){// create events to delegate
var delegations=[];var prev=delegator.prevMouseover;if(!collision){//  no collision
// check for prev
if(prev){// clear cursor style
resetCursor(delegator.plot);// un-highlight previous target
prev.target.unhighlight();// `mouseout` on previous target
delegations.push({type:EventType.MOUSE_OUT,event:copyEvent(prev.target,prev.data,prev)});// unflag as prev `mouseover` target
delegator.prevMouseover=null;}}else{// collision
// check for prev
if(prev&&prev.data!==collision){// un-highlight previous target
prev.target.unhighlight();// `mouseout` on previous target
delegations.push({type:EventType.MOUSE_OUT,event:copyEvent(prev.target,prev.data,prev)});}// `mousemove` on current target
delegations.push({type:EventType.MOUSE_MOVE,event:copyEvent(child,collision,event)});// set cursor for hover
setCursor(delegator.plot);// highlight
child.highlight(collision);if(!prev||prev.data!==collision){// `mouseover` on current
delegations.push({type:EventType.MOUSE_OVER,event:copyEvent(child,collision,event)});}// flag as prev `mouseover`
delegator.prevMouseover=delegations[delegations.length-1].event;}return delegations;};var delegateMouseUp=function delegateMouseUp(delegator,child,event,collision){if(collision){return[{type:EventType.MOUSE_UP,event:copyEvent(child,collision,event)}];}return[];};var delegateMouseDown=function delegateMouseDown(delegator,child,event,collision){if(collision){return[{type:EventType.MOUSE_DOWN,event:copyEvent(child,collision,event)}];}return[];};var delegateClick=function delegateClick(delegator,child,event,collision){// check if multi-select is enabled
var multiSelect=event.originalEvent.ctrlKey||event.originalEvent.metaKey;if(collision){// select
if(!child.isSelected(collision)){if(!multiSelect){// if not multi-select, unselect the data prev selected data
delegator.prevClick.forEach(function(prev){prev.target.unselectAll();});delegator.prevClick=[];}// if not already selected, add to selection
child.select(collision,multiSelect);}else{if(multiSelect){// remove if already selected
child.unselect(collision);}}// `click` event
var delegation={type:EventType.CLICK,event:copyEvent(child,collision,event)};// flag as prev `click` target
delegator.prevClick.push(delegation.event);// return delegation
return[delegation];}else{if(delegator.prevClick.length>0){if(multiSelect){// if multi-select is held, don't clear selection, assume the
// user may have misclicked
return[];}// unselect the data
delegator.prevClick.forEach(function(prev){prev.target.unselectAll();});// unflag as prev `click` target
delegator.prevClick=[];}}return[];};var delegateDblClick=function delegateDblClick(delegator,child,event,collision){if(collision){return[{type:EventType.DBL_CLICK,event:copyEvent(child,collision,event)}];}return[];};var DELEGATION_FUNCS=(_DELEGATION_FUNCS={},_defineProperty(_DELEGATION_FUNCS,EventType.MOUSE_MOVE,delegateMouseMove),_defineProperty(_DELEGATION_FUNCS,EventType.MOUSE_UP,delegateMouseUp),_defineProperty(_DELEGATION_FUNCS,EventType.MOUSE_DOWN,delegateMouseDown),_defineProperty(_DELEGATION_FUNCS,EventType.CLICK,delegateClick),_defineProperty(_DELEGATION_FUNCS,EventType.DBL_CLICK,delegateDblClick),_DELEGATION_FUNCS);/**
 * Class representing an event delegator.
 * @private
 */var EventDelegator=function(){/**
	 * Instantiates a new EventDelegator object.
	 *
	 * @param {Plot} plot - The plot to attach the handler to.
	 */function EventDelegator(plot){_classCallCheck(this,EventDelegator);this.plot=plot;this.prevClick=[];this.prevMouseover=null;}/**
	 * Delegates the provided event type to all children of the plot.
	 *
	 * @param {string} type - The event type to delegate.
	 */_createClass(EventDelegator,[{key:'delegate',value:function delegate(type){var _this=this;// get appropriate delegation function
var func=DELEGATION_FUNCS[type];if(!func){throw'Delegation for event type '+type+' is not supported';}// attach delegation handler
this.plot.on(type,function(event){// get children sorted by z-index
var children=_this.plot.getSortedLayers();// pick children, by priority
var collision=null;var child=null;for(var i=children.length-1;i>=0;i--){if(!children[i].isHidden()){collision=children[i].pick(event.pos);if(collision){child=children[i];break;}}}// delegate using provided func
var delegations=func(_this,child,event,collision);// delegate the accumulated events
for(var _i=0;_i<delegations.length;_i++){var delegation=delegations[_i];delegation.event.target.emit(delegation.type,delegation.event);}});}}]);return EventDelegator;}();module.exports=EventDelegator;

},{"./EventType":141,"./MouseEvent":142}],141:[function(require,module,exports){
'use strict';/**
 * Event type string constants.
 */module.exports={/**
	 * Emitted when the plot is clicked.
	 * @constant {string}
	 */CLICK:'click',/**
	 * Emitted when the plot is double clicked.
	 * @constant {string}
	 */DBL_CLICK:'dblclick',/**
	 * Emitted when a mouse button is pressed.
	 * @constant {string}
	 */MOUSE_DOWN:'mousedown',/**
	 * Emitted when a mouse button is released.
	 * @constant {string}
	 */MOUSE_UP:'mouseup',/**
	 * Emitted when the mouse is moved on the target.
	 * @constant {string}
	 */MOUSE_MOVE:'mousemove',/**
	 * Emitted when the mouse is moved onto the target.
	 * @constant {string}
	 */MOUSE_OVER:'mouseover',/**
	 * Emitted when the mouse is moved out of the target.
	 * @constant {string}
	 */MOUSE_OUT:'mouseout',/**
	 * Emitted when a new pan event is handled.
	 * @constant {string}
	 */PAN_START:'panstart',/**
	 * Emitted during each frame of a pan animation.
	 * @constant {string}
	 */PAN:'pan',/**
	 * Emitted on the final frame of a pan animation.
	 * @constant {string}
	 */PAN_END:'panend',/**
	 * Emitted when a new zoom event is handled.
	 * @constant {string}
	 */ZOOM_START:'zoomstart',/**
	 * Emitted during each frame of a zoom animation.
	 * @constant {string}
	 */ZOOM:'zoom',/**
	 * Emitted on the final frame of a zoom animation.
	 * @constant {string}
	 */ZOOM_END:'zoomend',/**
	 * Emitted before processing a new frame.
	 * @constant {string}
	 */FRAME:'frame',/**
	 * Emitted when processing a resize event.
	 * @constant {string}
	 */RESIZE:'resize',/**
	 * Emitted when the viewing cell of the plot is updated.
	 * @constant {string}
	 */CELL_UPDATE:'cellupdate',/**
	 * Emitted when the layer is refreshed.
	 * @constant {string}
	 */REFRESH:'refresh',/**
	 * Emitted when an initial request for a tile is made, the tile is not
	 * yet part of the layer and has not yet been requested.
	 * @constant {string}
	 */TILE_REQUEST:'tilerequest',/**
	 * Emitted when a tile request completes unsuccessfully. The tile is not
	 * added to the layer.
	 * @constant {string}
	 */TILE_FAILURE:'tilefailure',/**
	 * Emitted when a tile request completes successfully. The tile is added
	 * to the layer.
	 * @constant {string}
	 */TILE_ADD:'tileadd',/**
	 * Emitted when a tile request completes successfully but the tile is no
	 * longer in view. The tile is not added to the layer.
	 * @constant {string}
	 */TILE_DISCARD:'tilediscard',/**
	 * Emitted when a tile is evicted from the internal LRU cache.
	 * @constant {string}
	 */TILE_REMOVE:'tileremove',/**
	 * Emitted when all visible tiles have been loaded for a layer.
	 * @constant {string}
	 */LOAD:'load'};

},{}],142:[function(require,module,exports){
'use strict';function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Event=require('./Event');/**
 * Class representing a mouse event.
 */var MouseEvent=function(_Event){_inherits(MouseEvent,_Event);/**
	 * Instantiates a new MouseEvent object.
	 *
	 * @param {Object} target - The object that fired the event.
	 * @param {string} event - The original DOM mouse event fired by the browser.
	 * @param {Object} pos - The position of the mouse event in plot coordinates.
	 * @param {Object} px - The position of the mouse event in viewport pixel coordinates.
	 * @param {Object} data - The data associated with the event.
	 */function MouseEvent(target,event,pos,px){var data=arguments.length>4&&arguments[4]!==undefined?arguments[4]:null;_classCallCheck(this,MouseEvent);var _this=_possibleConstructorReturn(this,(MouseEvent.__proto__||Object.getPrototypeOf(MouseEvent)).call(this,target));_this.originalEvent=event;_this.pos=pos;_this.px=px;_this.data=data;return _this;}return MouseEvent;}(Event);module.exports=MouseEvent;

},{"./Event":138}],143:[function(require,module,exports){
'use strict';function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Event=require('./Event');/**
 * Class representing a resize event.
 */var ResizeEvent=function(_Event){_inherits(ResizeEvent,_Event);/**
	 * Instantiates a new ResizeEvent object.
	 *
	 * @param {Object} target - The object that fired the event.
	 * @param {number} oldSize - The old size of the viewport.
	 * @param {number} newSize - The new size of the viewport.
	 */function ResizeEvent(target,oldSize,newSize){_classCallCheck(this,ResizeEvent);var _this=_possibleConstructorReturn(this,(ResizeEvent.__proto__||Object.getPrototypeOf(ResizeEvent)).call(this,target));_this.oldSize=oldSize;_this.newSize=newSize;return _this;}return ResizeEvent;}(Event);module.exports=ResizeEvent;

},{"./Event":138}],144:[function(require,module,exports){
'use strict';function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Event=require('./Event');/**
 * Class representing a tile event.
 */var TileEvent=function(_Event){_inherits(TileEvent,_Event);/**
	 * Instantiates a new TileEvent object.
	 *
	 * @param {Object} target - The object that fired the event.
	 * @param {number} tile - The tile object.
	 */function TileEvent(target,tile){_classCallCheck(this,TileEvent);var _this=_possibleConstructorReturn(this,(TileEvent.__proto__||Object.getPrototypeOf(TileEvent)).call(this,target));_this.tile=tile;return _this;}return TileEvent;}(Event);module.exports=TileEvent;

},{"./Event":138}],145:[function(require,module,exports){
'use strict';var EventType=require('./event/EventType');module.exports={// events
CLICK:EventType.CLICK,DBL_CLICK:EventType.DBL_CLICK,MOUSE_DOWN:EventType.MOUSE_DOWN,MOUSE_UP:EventType.MOUSE_UP,MOUSE_MOVE:EventType.MOUSE_MOVE,MOUSE_OVER:EventType.MOUSE_OVER,MOUSE_OUT:EventType.MOUSE_OUT,PAN_START:EventType.PAN_START,PAN:EventType.PAN,PAN_END:EventType.PAN_END,ZOOM_START:EventType.ZOOM_START,ZOOM:EventType.ZOOM,ZOOM_END:EventType.ZOOM_END,RESIZE:EventType.RESIZE,FRAME:EventType.FRAME,REFRESH:EventType.REFRESH,TILE_REQUEST:EventType.TILE_REQUEST,TILE_FAILURE:EventType.TILE_FAILURE,TILE_ADD:EventType.TILE_ADD,TILE_DISCARD:EventType.TILE_DISCARD,TILE_REMOVE:EventType.TILE_REMOVE,CELL_UPDATE:EventType.CELL_UPDATE,// event
Event:require('./event/Event'),MouseEvent:require('./event/MouseEvent'),ResizeEvent:require('./event/ResizeEvent'),TileEvent:require('./event/TileEvent'),// geometry
Bounds:require('./geometry/Bounds'),RTree:require('./geometry/RTree'),RTreePyramid:require('./geometry/RTreePyramid'),CircleCollidable:require('./geometry/CircleCollidable'),RectangleCollidable:require('./geometry/RectangleCollidable'),RingCollidable:require('./geometry/RingCollidable'),// plot
Plot:require('./plot/Plot'),// layer
Layer:require('./layer/Layer'),// tile layer
TileLayer:require('./layer/tile/TileLayer'),// overlay layer
Overlay:require('./layer/overlay/Overlay'),PointOverlay:require('./layer/overlay/PointOverlay'),PolylineOverlay:require('./layer/overlay/PolylineOverlay'),PolygonOverlay:require('./layer/overlay/PolygonOverlay'),// renderer
Renderer:require('./renderer/Renderer'),// tile renderer
TileRenderer:require('./renderer/tile/TileRenderer'),// webgl tile renderer
WebGLTileRenderer:require('./renderer/tile/WebGLTileRenderer'),ImageTileRenderer:require('./renderer/tile/sample/ImageTileRenderer'),InteractiveTileRenderer:require('./renderer/tile/sample/InteractiveTileRenderer'),PointTileRenderer:require('./renderer/tile/sample/PointTileRenderer'),InstancedTileRenderer:require('./renderer/tile/sample/InstancedTileRenderer'),// overlay renderer
OverlayRenderer:require('./renderer/overlay/OverlayRenderer'),// webgl overlay renderer
WebGLOverlayRenderer:require('./renderer/overlay/WebGLOverlayRenderer'),PointOverlayRenderer:require('./renderer/overlay/sample/PointOverlayRenderer'),PolylineOverlayRenderer:require('./renderer/overlay/sample/PolylineOverlayRenderer'),PolygonOverlayRenderer:require('./renderer/overlay/sample/PolygonOverlayRenderer'),// webgl shader
Shader:require('./webgl/shader/Shader'),// webgl texture
Texture:require('./webgl/texture/Texture'),TextureArray:require('./webgl/texture/TextureArray'),// webgl vertex
VertexAtlas:require('./webgl/vertex/VertexAtlas'),VertexBuffer:require('./webgl/vertex/VertexBuffer'),IndexBuffer:require('./webgl/vertex/IndexBuffer'),// util
loadBuffer:require('./util/loadBuffer'),loadImage:require('./util/loadImage')};

},{"./event/Event":138,"./event/EventType":141,"./event/MouseEvent":142,"./event/ResizeEvent":143,"./event/TileEvent":144,"./geometry/Bounds":146,"./geometry/CircleCollidable":147,"./geometry/RTree":148,"./geometry/RTreePyramid":149,"./geometry/RectangleCollidable":150,"./geometry/RingCollidable":151,"./layer/Layer":152,"./layer/overlay/Overlay":153,"./layer/overlay/PointOverlay":154,"./layer/overlay/PolygonOverlay":155,"./layer/overlay/PolylineOverlay":156,"./layer/tile/TileLayer":159,"./plot/Plot":163,"./renderer/Renderer":173,"./renderer/overlay/OverlayRenderer":174,"./renderer/overlay/WebGLOverlayRenderer":175,"./renderer/overlay/sample/PointOverlayRenderer":176,"./renderer/overlay/sample/PolygonOverlayRenderer":177,"./renderer/overlay/sample/PolylineOverlayRenderer":178,"./renderer/tile/TileRenderer":180,"./renderer/tile/WebGLTileRenderer":181,"./renderer/tile/sample/ImageTileRenderer":182,"./renderer/tile/sample/InstancedTileRenderer":183,"./renderer/tile/sample/InteractiveTileRenderer":184,"./renderer/tile/sample/PointTileRenderer":185,"./util/loadBuffer":189,"./util/loadImage":190,"./webgl/shader/Shader":192,"./webgl/texture/Texture":195,"./webgl/texture/TextureArray":196,"./webgl/vertex/IndexBuffer":197,"./webgl/vertex/VertexAtlas":198,"./webgl/vertex/VertexBuffer":199}],146:[function(require,module,exports){
'use strict';// Constants
var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var INSIDE=0x00;// 0000
var LEFT=0x01;// 0001
var RIGHT=0x02;// 0010
var BOTTOM=0x04;// 0100
var TOP=0x08;// 1000
var computeCode=function computeCode(bounds,x,y){var code=INSIDE;if(x<bounds.left){// to the left of clip window
code|=LEFT;}else if(x>bounds.right){// to the right of clip window
code|=RIGHT;}if(y<bounds.bottom){// below the clip window
code|=BOTTOM;}else if(y>bounds.top){// above the clip window
code|=TOP;}return code;};var sutherlandHodgemanClip=function sutherlandHodgemanClip(bounds,points){// Sutherland-Hodgeman clipping algorithm clips a polygon against a
// rectangle.
var result=void 0;for(var code=1;code<=8;code*=2){result=[];var prev=points[points.length-1];var prevInside=!(computeCode(bounds,prev.x,prev.y)&code);for(var i=0;i<points.length;i++){var p=points[i];var inside=!(computeCode(bounds,p.x,p.y)&code);// if segment goes through the clip window, add an intersection
if(inside!==prevInside){var ax=prev.x;var ay=prev.y;var bx=p.x;var by=p.y;var x=void 0,y=0;if(code&TOP){// point is above the clip rectangle
x=ax+(bx-ax)*(bounds.top-ay)/(by-ay);y=bounds.top;}else if(code&BOTTOM){// point is below the clip rectangle
x=ax+(bx-ax)*(bounds.bottom-ay)/(by-ay);y=bounds.bottom;}else if(code&RIGHT){// point is to the right of clip rectangle
y=ay+(by-ay)*(bounds.right-ax)/(bx-ax);x=bounds.right;}else{//if (code & LEFT) {
// point is to the left of clip rectangle
y=ay+(by-ay)*(bounds.left-ax)/(bx-ax);x=bounds.left;}result.push({x:x,y:y});}if(inside){// add a point if it's inside
result.push(p);}prev=p;prevInside=inside;}points=result;if(!points.length){break;}}return result.length>0?result:null;};var cohenSutherlandClip=function cohenSutherlandClip(bounds,a,b){// Cohen–Sutherland clipping algorithm clips a line against a rectangle.
// copy so we don't change in-place
var ax=a.x;var ay=a.y;var bx=b.x;var by=b.y;// compute outcodes for P0, P1, and whatever point lies outside the clip rectangle
var aCode=computeCode(bounds,ax,ay);var bCode=computeCode(bounds,bx,by);var accept=false;// normal alg has infiinite while loop, cap at 8 iterations just in case
var MAX_ITERATIONS=8;var iter=0;while(iter<MAX_ITERATIONS){if(!(aCode|bCode)){// bitwise OR is 0. Trivially accept and get out of loop
accept=true;break;}else if(aCode&bCode){// bitwise AND is not 0. (implies both end points are in the same
// region outside the window). Reject and get out of loop
break;}else{// failed both tests, so calculate the line segment to clip
// from an outside point to an intersection with clip edge
var x=void 0,y=0;// At least one endpoint is outside the clip rectangle; pick it.
var code=aCode?aCode:bCode;// Now find the intersection point;
// use formulas
// y = ay + slope * (x - ax), x = ax + (1 / slope) * (y - ay)
if(code&TOP){// point is above the clip rectangle
x=ax+(bx-ax)*(bounds.top-ay)/(by-ay);y=bounds.top;}else if(code&BOTTOM){// point is below the clip rectangle
x=ax+(bx-ax)*(bounds.bottom-ay)/(by-ay);y=bounds.bottom;}else if(code&RIGHT){// point is to the right of clip rectangle
y=ay+(by-ay)*(bounds.right-ax)/(bx-ax);x=bounds.right;}else{//if (code & LEFT) {
// point is to the left of clip rectangle
y=ay+(by-ay)*(bounds.left-ax)/(bx-ax);x=bounds.left;}// now we move outside point to intersection point to clip
// and get ready for next pass.
if(code===aCode){ax=x;ay=y;aCode=computeCode(bounds,ax,ay);}else{bx=x;by=y;bCode=computeCode(bounds,bx,by);}}iter++;}if(accept){return[{x:ax,y:ay},{x:bx,y:by}];}return null;};/**
 * Class representing a set of bounds.
 */var Bounds=function(){/**
	 * Instantiates a new Bounds object.
	 *
	 * @param {number} left - The left bound.
	 * @param {number} right - The right bound.
	 * @param {number} bottom - The bottom bound.
	 * @param {number} top - The top bound.
	 */function Bounds(left,right,bottom,top){_classCallCheck(this,Bounds);this.left=left;this.right=right;this.bottom=bottom;this.top=top;}/**
	 * Get the width of the bounds.
	 *
	 * @returns {number} The width of the bounds.
	 */_createClass(Bounds,[{key:'getWidth',value:function getWidth(){return this.right-this.left;}/**
	 * Get the height of the bounds.
	 *
	 * @returns {number} The height of the bounds.
	 */},{key:'getHeight',value:function getHeight(){return this.top-this.bottom;}/**
	 * Extends the bounds by the provided point or bounds object.
	 *
	 * @param {Object|Bounds} arg - The point or bounds to extend the bounds by.
	 *
	 * @returns {Bounds} The bounds object, for chaining.
	 */},{key:'extend',value:function extend(arg){if(arg.left!==undefined&&arg.right!==undefined&&arg.bottom!==undefined&&arg.top!==undefined){// bounds
if(arg.left<this.left){this.left=arg.left;}if(arg.right>this.right){this.right=arg.right;}if(arg.bottom<this.bottom){this.bottom=arg.bottom;}if(arg.top>this.top){this.top=arg.top;}}else{// point
if(arg.x<this.left){this.left=arg.x;}if(arg.x>this.right){this.right=arg.x;}if(arg.y<this.bottom){this.bottom=arg.y;}if(arg.y>this.top){this.top=arg.y;}}}/**
	 * Get the center coordinate of the bounds.
	 *
	 * @returns {Object} The center coordinate of the bounds.
	 */},{key:'getCenter',value:function getCenter(){return{x:this.left+this.getWidth()/2,y:this.bottom+this.getHeight()/2};}/**
	 * Test if the bounds equals another.
	 *
	 * @param {Bounds} bounds - The bounds object to test.
	 *
	 * @returns {boolean} Whether or not the bounds objects are equal.
	 */},{key:'equals',value:function equals(bounds){return this.left===bounds.left&&this.right===bounds.right&&this.bottom===bounds.bottom&&this.top===bounds.top;}/**
	 * Test if the bounds overlaps another. Test is inclusive of edges.
	 *
	 * @param {Bounds} bounds - The bounds object to test.
	 *
	 * @returns {boolean} Whether or not the bounds overlap eachother.
	 */},{key:'overlaps',value:function overlaps(bounds){// NOTE: inclusive of edges
return!(this.left>bounds.right||this.right<bounds.left||this.top<bounds.bottom||this.bottom>bounds.top);}/**
	 * Return the intersection of the bounds. Test is inclusive of edges. If
	 * the bounds do not intersect, returns undefined.
	 *
	 * @param {Bounds} bounds - The bounds object to intersect.
	 *
	 * @returns {Bounds} The intersection of both bounds.
	 */},{key:'intersection',value:function intersection(bounds){// NOTE: inclusive of edges
if(!this.overlaps(bounds)){return undefined;}return new Bounds(Math.max(this.left,bounds.left),Math.min(this.right,bounds.right),Math.max(this.bottom,bounds.bottom),Math.min(this.top,bounds.top));}/**
	 * Clips the provided line segment to within the dimensions of the bounds.
	 * Test is inclusive of edges.
	 *
	 * @param {Array} line - The line.
	 *
	 * @returns {Array} The clipped line, or null if it is outside the bounds.
	 */},{key:'clipLine',value:function clipLine(line){if(!line||line.length!==2){return null;}return cohenSutherlandClip(this,line[0],line[1]);}/**
	 * Clips the provided polyline to within the dimensions of the bounds. Will
	 * return an array of clipped polylines as result.
	 * Test is inclusive of edges.
	 *
	 * @param {Array} polyline - The polyline.
	 *
	 * @returns {Array} The resulting clipped polylines, or null if it is outside the bounds.
	 */},{key:'clipPolyline',value:function clipPolyline(polyline){if(!polyline||polyline.length<2){return null;}var clipped=[];var current=[];for(var i=1;i<polyline.length;i++){var a=polyline[i-1];var b=polyline[i];// clip the line
var line=cohenSutherlandClip(this,a,b);// no line in bounds
if(!line){continue;}var clippedA=line[0];var clippedB=line[1];// add src point
current.push(clippedA);if(clippedB.x!==b.x&&clippedB.y!==b.y||i===polyline.length-1){// only add destination point if it was clipped, or is last
// point
current.push(clippedB);// then break the polyline
clipped.push(current);current=[];}}return clipped.length>0?clipped:null;}/**
	 * Clips the provided points to those within the dimensions of the bounds.
	 * Test is inclusive of edges.
	 *
	 * @param {Array} points - The points to clip.
	 *
	 * @returns {Array} The clipped points, or null if none are within the bounds.
	 */},{key:'clipPoints',value:function clipPoints(points){if(!points){return null;}var clipped=[];for(var i=0;i<points.length;i++){var point=points[i];if(point.x>=this.left&&point.x<=this.right&&point.y>=this.bottom&&point.y<=this.top){clipped.push(point);}}return clipped.length>0?clipped:null;}/**
	 * Clips the provided polygon to those within the dimensions of the bounds.
	 * Test is inclusive of edges.
	 *
	 * @param {Array} polygon - The points of the polygon to clip.
	 *
	 * @returns {Array} The clipped points of the polygon, or null if it is not within the bounds.
	 */},{key:'clipPolygon',value:function clipPolygon(polygon){if(!polygon||polygon.length<3){return null;}return sutherlandHodgemanClip(this,polygon);}}]);return Bounds;}();module.exports=Bounds;

},{}],147:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var clamp=require('lodash/clamp');/**
 * Class representing a circle collidable.
 */var CircleCollidable=function(){/**
	 * Instantiates a new CircleCollidable object.
	 *
	 * @param {number} x - The tile x pixel coordinate.
	 * @param {number} y - The tile y pixel coordinate.
	 * @param {number} radius - The radius in pixels.
	 * @param {number} xOffset - The tile x offset in pixels.
	 * @param {number} yOffset - The tile y offset in pixels.
	 * @param {Tile} tile - The tile object.
	 * @param {Object} data - Any arbitrary user data.
	 */function CircleCollidable(x,y,radius,xOffset,yOffset,tile,data){_classCallCheck(this,CircleCollidable);this.x=x;this.y=y;this.radius=radius;this.minX=x+xOffset-radius;this.maxX=x+xOffset+radius;this.minY=y+yOffset-radius;this.maxY=y+yOffset+radius;this.tile=tile;this.data=data;}/**
	 * Test if the provided position is within the inner shape of the collidable.
	 *
	 * @param {number} x - The x position to test.
	 * @param {number} y - The y position to test.
	 *
	 * @returns {bool} Whether or not there is an intersection.
	 */_createClass(CircleCollidable,[{key:'testPoint',value:function testPoint(x,y){// center pos
var cx=(this.minX+this.maxX)*0.5;var cy=(this.minY+this.maxY)*0.5;// distance to point
var dx=cx-x;var dy=cy-y;return dx*dx+dy*dy<=this.radius*this.radius;}/**
	 * Test if the provided rectangle is within the inner shape of the
	 * collidable.
	 *
	 * @param {number} minX - The minimum x component.
	 * @param {number} maxX - The maximum x component.
	 * @param {number} minY - The minimum y component.
	 * @param {number} maxY - The maximum y component.
	 *
	 * @returns {bool} Whether or not there is an intersection.
	 */},{key:'testRectangle',value:function testRectangle(minX,maxX,minY,maxY){// circle pos
var cx=(this.minX+this.maxX)*0.5;var cy=(this.minY+this.maxY)*0.5;// find closest point in rectangle to circle
var nearestX=clamp(cx,minX,maxX);var nearestY=clamp(cy,minY,maxY);// test distance
var dx=cx-nearestX;var dy=cy-nearestY;return dx*dx+dy*dy<this.radius*this.radius;}}]);return CircleCollidable;}();module.exports=CircleCollidable;

},{"lodash/clamp":107}],148:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var rbush=require('rbush');var defaultTo=require('lodash/defaultTo');/**
 * Class representing an r-tree.
 */var RTree=function(){/**
	 * Instantiates a new RTree object.
	 *
	 * @param {Object} options - The options object.
	 * @param {boolean} options.nodeCapacity - The node capacity of the r-tree.
	 */function RTree(options){_classCallCheck(this,RTree);this.tree=rbush(defaultTo(options.nodeCapacity,32));}/**
	 * Inserts an array of collidables into the r-tree.
	 *
	 * @param {Array} collidables - The array of collidables to insert.
	 */_createClass(RTree,[{key:'insert',value:function insert(collidables){this.tree.load(collidables);}/**
	 * Removes an array of collidables from the r-tree.
	 *
	 * @param {Array} collidables - The array of collidables to remove.
	 */},{key:'remove',value:function remove(collidables){var tree=this.tree;for(var i=0;i<collidables.length;i++){tree.remove(collidables[i]);}}/**
	 * Searchs the r-tree using a point.
	 *
	 * @param {number} x - The x component.
	 * @param {number} y - The y component.
	 *
	 * @returns {Object} The collision object.
	 */},{key:'searchPoint',value:function searchPoint(x,y){var collisions=this.tree.search({minX:x,maxX:x,minY:y,maxY:y});if(collisions.length===0){return null;}// inner shape test
for(var i=0;i<collisions.length;i++){var collision=collisions[i];if(collision.testPoint(x,y)){return collision;}}return null;}/**
	 * Searchs the r-tree using a rectangle.
	 *
	 * @param {number} minX - The minimum x component.
	 * @param {number} maxX - The maximum x component.
	 * @param {number} minY - The minimum y component.
	 * @param {number} maxY - The maximum y component.
	 *
	 * @returns {Object} The collision object.
	 */},{key:'searchRectangle',value:function searchRectangle(minX,maxX,minY,maxY){var collisions=this.tree.search({minX:minX,maxX:maxX,minY:minY,maxY:maxY});if(collisions.length===0){return null;}// inner shape test
for(var i=0;i<collisions.length;i++){var collision=collisions[i];if(collision.testRectangle(minX,maxX,minY,maxY)){return collision;}}return null;}}]);return RTree;}();module.exports=RTree;

},{"lodash/defaultTo":109,"rbush":137}],149:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var defaultTo=require('lodash/defaultTo');var RTree=require('./RTree');/**
 * Class representing a pyramid of r-trees.
 */var RTreePyramid=function(){/**
	 * Instantiates a new RTreePyramid object.
	 *
	 * @param {Object} options - The options object.
	 * @param {boolean} options.nodeCapacity - The node capacity of the r-tree.
	 */function RTreePyramid(options){_classCallCheck(this,RTreePyramid);this.trees=new Map();this.collidables=new Map();this.nodeCapacity=defaultTo(options.nodeCapacity,32);}/**
	 * Inserts an array of collidables into the r-tree for the provided coord.
	 *
	 * @param {TileCoord} coord - The coord of the tile.
	 * @param {Array} collidables - The array of collidables to insert.
	 *
	 * @returns {RTreePyramid} The RTreePyramid object, for chaining.
	 */_createClass(RTreePyramid,[{key:'insert',value:function insert(coord,collidables){if(!this.trees.has(coord.z)){this.trees.set(coord.z,new RTree({nodeCapacity:this.nodeCapacity}));}this.trees.get(coord.z).insert(collidables);this.collidables.set(coord.hash,collidables);return this;}/**
	 * Removes an array of collidables from the r-tree for the provided coord.
	 *
	 * @param {TileCoord} coord - The coord of the tile.
	 *
	 * @returns {RTreePyramid} The RTreePyramid object, for chaining.
	 */},{key:'remove',value:function remove(coord){var collidables=this.collidables.get(coord.hash);this.trees.get(coord.z).remove(collidables);this.collidables.delete(coord.hash);return this;}/**
	 * Searchs the r-tree using a point.
	 *
	 * @param {number} x - The x component.
	 * @param {number} y - The y component.
	 * @param {number} zoom - The zoom level of the plot.
	 * @param {number} extent - The pixel extent of the plot zoom.
	 *
	 * @returns {Object} The collision object.
	 */},{key:'searchPoint',value:function searchPoint(x,y,zoom,extent){// points are stored in un-scaled coordinates, unscale the point
var tileZoom=Math.round(zoom);// get the tree for the zoom
var tree=this.trees.get(tileZoom);if(!tree){// no data for tile
return null;}var scale=Math.pow(2,tileZoom-zoom);// unscaled points
var sx=x*extent*scale;var sy=y*extent*scale;// get collision
return tree.searchPoint(sx,sy);}/**
	 * Searchs the r-tree using a rectangle.
	 *
	 * @param {number} minX - The minimum x component.
	 * @param {number} maxX - The maximum x component.
	 * @param {number} minY - The minimum y component.
	 * @param {number} maxY - The maximum y component.
	 * @param {number} zoom - The zoom level of the plot.
	 * @param {number} extent - The pixel extent of the plot zoom.
	 *
	 * @returns {Object} The collision object.
	 */},{key:'searchRectangle',value:function searchRectangle(minX,maxX,minY,maxY,zoom,extent){// points are stored in un-scaled coordinates, unscale the point
var tileZoom=Math.round(zoom);// get the tree for the zoom
var tree=this.trees.get(tileZoom);if(!tree){// no data for tile
return null;}var scale=Math.pow(2,tileZoom-zoom);// unscaled points
var sminX=minX*extent*scale;var smaxX=maxX*extent*scale;var sminY=minY*extent*scale;var smaxY=maxY*extent*scale;// get collision
return tree.searchRectangle(sminX,smaxX,sminY,smaxY);}}]);return RTreePyramid;}();module.exports=RTreePyramid;

},{"./RTree":148,"lodash/defaultTo":109}],150:[function(require,module,exports){
'use strict';/**
 * Class representing a rectangle collidable.
 */var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var RectangleCollidable=function(){/**
	 * Instantiates a new RectangleCollidable object.
	 *
	 * @param {number} minX - The left bound in pixels.
	 * @param {number} maxX - The right bound in pixels.
	 * @param {number} minY - The bottom bound in pixels.
	 * @param {number} maxY - The top bound in pixels.
	 * @param {number} xOffset - The tile x offset in pixels.
	 * @param {number} yOffset - The tile y offset in pixels.
	 * @param {Tile} tile - The tile object.
	 * @param {Object} data - Any arbitrary user data.
	 */function RectangleCollidable(minX,maxX,minY,maxY,xOffset,yOffset,tile,data){_classCallCheck(this,RectangleCollidable);this.minX=minX+xOffset;this.maxX=maxX+xOffset;this.minY=minY+yOffset;this.maxY=maxY+yOffset;this.tile=tile;this.data=data;}/**
	 * Test if the provided position is within the inner shape of the collidable.
	 *
	 * @param {number} x - The x position to test.
	 * @param {number} y - The y position to test.
	 *
	 * @returns {bool} Whether or not there is an intersection.
	 *//* eslint-disable no-unused-vars */_createClass(RectangleCollidable,[{key:'testPoint',value:function testPoint(x,y){return true;}/**
	 * Test if the provided rectangle is within the inner shape of the
	 * collidable.
	 *
	 * @param {number} minX - The minimum x component.
	 * @param {number} maxX - The maximum x component.
	 * @param {number} minY - The minimum y component.
	 * @param {number} maxY - The maximum y component.
	 *
	 * @returns {bool} Whether or not there is an intersection.
	 *//* eslint-disable no-unused-vars */},{key:'testRectangle',value:function testRectangle(minX,maxX,minY,maxY){return true;}}]);return RectangleCollidable;}();module.exports=RectangleCollidable;

},{}],151:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var clamp=require('lodash/clamp');/**
 * Class representing a circle collidable.
 */var RingCollidable=function(){/**
	 * Instantiates a new RingCollidable object.
	 *
	 * @param {number} x - The tile x pixel coordinate.
	 * @param {number} y - The tile y pixel coordinate.
	 * @param {number} radius - The radius in pixels.
	 * @param {number} width - The radius buffer in pixels (additional hit-area beyond radius)
	 * @param {number} xOffset - The tile x offset in pixels.
	 * @param {number} yOffset - The tile y offset in pixels.
	 * @param {Tile} tile - The tile object.
	 * @param {Object} data - Any arbitrary user data.
	 */function RingCollidable(x,y,radius,width,xOffset,yOffset,tile,data){_classCallCheck(this,RingCollidable);this.x=x;this.y=y;this.radius=radius;this.width=width;var halfWidth=width*0.5;this.minX=x+xOffset-radius-halfWidth;this.maxX=x+xOffset+radius+halfWidth;this.minY=y+yOffset-radius-halfWidth;this.maxY=y+yOffset+radius+halfWidth;this.tile=tile;this.data=data;}/**
	 * Test if the provided position is within the inner shape of the collidable.
	 *
	 * @param {number} x - The x position to test.
	 * @param {number} y - The y position to test.
	 *
	 * @returns {bool} Whether or not there is an intersection.
	 */_createClass(RingCollidable,[{key:'testPoint',value:function testPoint(x,y){// center pos
var cx=(this.minX+this.maxX)*0.5;var cy=(this.minY+this.maxY)*0.5;// distance to point
var dx=cx-x;var dy=cy-y;var distanceSqr=dx*dx+dy*dy;var halfWidth=this.width*0.5;var innerRadius=this.radius-halfWidth;var outerRadius=this.radius+halfWidth;return distanceSqr<=outerRadius*outerRadius&&distanceSqr>=innerRadius*innerRadius;}/**
	 * Test if the provided rectangle is within the inner shape of the
	 * collidable.
	 *
	 * @param {number} minX - The minimum x component.
	 * @param {number} maxX - The maximum x component.
	 * @param {number} minY - The minimum y component.
	 * @param {number} maxY - The maximum y component.
	 *
	 * @returns {bool} Whether or not there is an intersection.
	 */},{key:'testRectangle',value:function testRectangle(minX,maxX,minY,maxY){// circle pos
var cx=(this.minX+this.maxX)*0.5;var cy=(this.minY+this.maxY)*0.5;// find the furthest points on rectangle from the circle
var furthestX=void 0,furthestY=0;if(Math.abs(cx-minX)<Math.abs(cx-maxX)){furthestX=maxX;}else{furthestX=minX;}if(Math.abs(cy-minY)<Math.abs(cy-maxY)){furthestY=maxY;}else{furthestY=minY;}// check if there is any intersection with the inner circle
var fx=cx-furthestX;var fy=cy-furthestY;var halfWidth=this.width*0.5;var innerRadius=this.radius-halfWidth;if(fx*fx+fy*fy<innerRadius*innerRadius){// rectangle is completely inside the ring and cannot intersect
return false;}// otherwise just do a circle - aabb test for outer circle
// find closest point in rectangle to circle
var nearestX=clamp(cx,minX,maxX);var nearestY=clamp(cy,minY,maxY);// test distance
var dx=cx-nearestX;var dy=cy-nearestY;var outerRadius=this.radius+halfWidth;return dx*dx+dy*dy<outerRadius*outerRadius;}}]);return RingCollidable;}();module.exports=RingCollidable;

},{"lodash/clamp":107}],152:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var clamp=require('lodash/clamp');var defaultTo=require('lodash/defaultTo');var EventEmitter=require('events');var Event=require('../event/Event');var EventType=require('../event/EventType');/**
 * Class representing a layer component.
 */var Layer=function(_EventEmitter){_inherits(Layer,_EventEmitter);/**
	 * Instantiates a new Layer object.
	 *
	 * @param {Object} options - The options.
	 * @param {number} options.opacity - The layer opacity.
	 * @param {number} options.zIndex - The layer z-index.
	 * @param {boolean} options.hidden - Whether or not the layer is visible.
	 */function Layer(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,Layer);var _this=_possibleConstructorReturn(this,(Layer.__proto__||Object.getPrototypeOf(Layer)).call(this));_this.opacity=defaultTo(options.opacity,1.0);_this.hidden=defaultTo(options.hidden,false);_this.zIndex=defaultTo(options.zIndex,0);_this.renderer=defaultTo(options.renderer,null);_this.highlighted=null;_this.selected=[];_this.plot=null;return _this;}/**
	 * Executed when the layer is attached to a plot.
	 *
	 * @param {Plot} plot - The plot to attach the layer to.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */_createClass(Layer,[{key:'onAdd',value:function onAdd(plot){if(!plot){throw'No plot argument provided';}// set plot
this.plot=plot;// flag as dirty
this.plot.setDirty();// execute renderer hook
if(this.renderer){this.renderer.onAdd(this);}return this;}/**
	 * Executed when the layer is removed from a plot.
	 *
	 * @param {Plot} plot - The plot to remove the layer from.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(plot){if(!plot){throw'No plot argument provided';}// execute renderer hook
if(this.renderer){this.renderer.onRemove(this);}// clear state
this.clear();// flag as dirty
this.plot.setDirty();// remove plot
this.plot=null;return this;}/**
	 * Add a renderer to the layer.
	 *
	 * @param {Renderer} renderer - The renderer to add to the layer.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'setRenderer',value:function setRenderer(renderer){if(!renderer){throw'No renderer argument provided';}if(this.renderer&&this.plot){this.renderer.onRemove(this);}this.renderer=renderer;if(this.plot){this.renderer.onAdd(this);}return this;}/**
	 * Remove the renderer from the layer.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'removeRenderer',value:function removeRenderer(){if(!this.renderer){throw'No renderer is currently attached to the layer';}if(this.plot){this.renderer.onRemove(this);}this.renderer=null;return this;}/**
	 * Returns the renderer of the layer.
	 *
	 * @returns {Renderer} The renderer object.
	 */},{key:'getRenderer',value:function getRenderer(){return this.renderer;}/**
	 * Set the opacity of the layer.
	 *
	 * @param {number} opacity - The opacity to set.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'setOpacity',value:function setOpacity(opacity){opacity=clamp(opacity,0,1);if(this.opacity!==opacity){this.opacity=opacity;if(this.plot){this.plot.setDirty();}}return this;}/**
	 * Get the opacity of the layer.
	 *
	 * @returns {number} The opacity of the layer object,.
	 */},{key:'getOpacity',value:function getOpacity(){return this.opacity;}/**
	 * Set the z-index of the layer.
	 *
	 * @param {number} zIndex - The z-index to set.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'setZIndex',value:function setZIndex(zIndex){if(this.zIndex!==zIndex){this.zIndex=zIndex;if(this.plot){this.plot.setDirty();}}return this;}/**
	 * Get the z-index of the layer.
	 *
	 * @returns {number} The zIndex of the layer object,.
	 */},{key:'getZIndex',value:function getZIndex(){return this.zIndex;}/**
	 * Make the layer visible.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'show',value:function show(){if(this.hidden){this.hidden=false;if(this.plot){this.plot.setDirty();}}return this;}/**
	 * Make the layer invisible.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'hide',value:function hide(){if(!this.hidden){this.hidden=true;if(this.renderer){this.renderer.clear();}if(this.plot){this.plot.setDirty();}}return this;}/**
	 * Returns true if the layer is hidden.
	 *
	 * @returns {boolean} Whether or not the layer is hidden.
	 */},{key:'isHidden',value:function isHidden(){return this.hidden;}/**
	 * Pick a position of the layer for a collision with any rendered objects.
	 *
	 * @param {Object} pos - The plot position to pick at.
	 *
	 * @returns {Object} The collision, or null.
	 */},{key:'pick',value:function pick(pos){if(this.renderer){return this.renderer.pick(pos);}return null;}/**
	 * Highlights the provided data.
	 *
	 * @param {Object} data - The data to highlight.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'highlight',value:function highlight(data){if(this.highlighted!==data){this.highlighted=data;if(this.plot){this.plot.setDirty();}}return this;}/**
	 * Clears any current highlight.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'unhighlight',value:function unhighlight(){if(this.highlighted!==null){this.highlighted=null;if(this.plot){this.plot.setDirty();}}return this;}/**
	 * Returns any highlighted data.
	 *
	 * @returns {Object} The highlighted data.
	 */},{key:'getHighlighted',value:function getHighlighted(){return this.highlighted;}/**
	 * Returns true if the provided argument is highlighted.
	 *
	 * @param {Object} data - The data to test.
	 *
	 * @returns {boolean} Whether or not there is highlighted data.
	 */},{key:'isHighlighted',value:function isHighlighted(data){return this.highlighted===data;}/**
	 * Selects the provided data.
	 *
	 * @param {Object} data - The data to select.
	 * @param {Object} multiSelect - Whether mutli-select is enabled.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'select',value:function select(data,multiSelect){var changed=false;if(multiSelect){// add to collection if multi-selection is enabled
var index=this.selected.indexOf(data);if(index===-1){// select point
this.selected.push(data);changed=true;}}else{// clear selection, adding only the latest entry
if(this.selected.length!==1||this.selected[0]!==data){this.selected=[data];changed=true;}}if(this.plot&&changed){this.plot.setDirty();}return this;}/**
	 * Remove the provided data from the current selection.
	 *
	 * @param {Object} data - The data to unselect.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'unselect',value:function unselect(data){var index=this.selected.indexOf(data);if(index!==-1){// unselect point
this.selected.splice(index,1);if(this.plot){this.plot.setDirty();}}return this;}/**
	 * Clears the current selection.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'unselectAll',value:function unselectAll(){if(this.selected.length>0){// unselect all
this.selected=[];if(this.plot){this.plot.setDirty();}}return this;}/**
	 * Returns any selected data.
	 *
	 * @returns {Array} The selected data.
	 */},{key:'getSelected',value:function getSelected(){return this.selected;}/**
	 * Returns true if the provided argument is selected.
	 *
	 * @param {Object} data - The data to test.
	 *
	 * @returns {boolean} Whether or not the data is selected.
	 */},{key:'isSelected',value:function isSelected(data){return this.selected.indexOf(data)!==-1;}/**
	 * Draw the layer for the frame.
	 *
	 * @param {number} timestamp - The frame timestamp.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'draw',value:function draw(timestamp){if(this.renderer){this.renderer.draw(timestamp);}return this;}/**
	 * Clears any persisted state in the layer.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'clear',value:function clear(){// clear selected / highlighted
if(this.highlighted||this.selected.length>0){this.highlighted=null;this.selected=[];}// clear renderer state
if(this.renderer){this.renderer.clear();}// flag as dirty
if(this.plot){this.plot.setDirty();}return this;}/**
	 * Clears any persisted state in the layer and refreshes the underlying
	 * data.
	 *
	 * @returns {Layer} The layer object, for chaining.
	 */},{key:'refresh',value:function refresh(){// clear the layer state
this.clear();// emit refresh event
this.emit(EventType.REFRESH,new Event(this));return this;}}]);return Layer;}(EventEmitter);module.exports=Layer;

},{"../event/Event":138,"../event/EventType":141,"events":2,"lodash/clamp":107,"lodash/defaultTo":109}],153:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var EventType=require('../../event/EventType');var Layer=require('../Layer');// Constants
/**
 * Cell update event handler symbol.
 * @private
 * @constant {Symbol}
 */var CELL_UPDATE=Symbol();/**
 * Clipped geometry symbol.
 * @private
 * @constant {Symbol}
 */var CLIPPED=Symbol();/**
 * Class representing an overlay layer.
 */var Overlay=function(_Layer){_inherits(Overlay,_Layer);/**
	 * Instantiates a new Overlay object.
	 *
	 * @param {Object} options - The overlay options.
	 * @param {number} options.opacity - The overlay opacity.
	 * @param {number} options.zIndex - The overlay z-index.
	 * @param {boolean} options.hidden - Whether or not the overlay is visible.
	 */function Overlay(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,Overlay);var _this=_possibleConstructorReturn(this,(Overlay.__proto__||Object.getPrototypeOf(Overlay)).call(this,options));_this[CLIPPED]=null;_this[CELL_UPDATE]=null;return _this;}/**
	 * Executed when the overlay is attached to a plot.
	 *
	 * @param {Plot} plot - The plot to attach the overlay to.
	 *
	 * @returns {Overlay} The overlay object, for chaining.
	 */_createClass(Overlay,[{key:'onAdd',value:function onAdd(plot){var _this2=this;_get(Overlay.prototype.__proto__||Object.getPrototypeOf(Overlay.prototype),'onAdd',this).call(this,plot);// clip existing geometry
this.refresh();// create cell update handler
this[CELL_UPDATE]=function(){_this2.refresh();};// attach handler
this.plot.on(EventType.CELL_UPDATE,this[CELL_UPDATE]);return this;}/**
	 * Executed when the overlay is removed from a plot.
	 *
	 * @param {Plot} plot - The plot to remove the overlay from.
	 *
	 * @returns {Overlay} The overlay object, for chaining.
	 */},{key:'onRemove',value:function onRemove(plot){// remove clipped geometry
this[CLIPPED]=null;// remove handler
this.plot.removeListener(EventType.CELL_UPDATE,this[CELL_UPDATE]);// create refresh handler
this[CELL_UPDATE]=null;_get(Overlay.prototype.__proto__||Object.getPrototypeOf(Overlay.prototype),'onRemove',this).call(this,plot);return this;}/**
	 * Unmutes and shows the overlay.
	 *
	 * @returns {Overlay} The overlay object, for chaining.
	 */},{key:'enable',value:function enable(){this.show();return this;}/**
	 * Mutes and hides the overlay.
	 *
	 * @returns {Overlay} The overlay object, for chaining.
	 */},{key:'disable',value:function disable(){this.hide();return this;}/**
	 * Returns true if the overlay is disabled.
	 *
	 * @returns {boolean} Whether or not the overlay is disabled.
	 */},{key:'isDisabled',value:function isDisabled(){return this.isHidden();}/**
	 * Clears any persisted state in the overlay and refreshes the underlying
	 * data. This involves refreshing the stored clipped geometry of the
	 * overlay based the current rendering cell of the plot.
	 *
	 * @returns {Overlay} The overlay object, for chaining.
	 */},{key:'refresh',value:function refresh(){if(this.plot){this[CLIPPED]=this.clipGeometry(this.plot.cell);}_get(Overlay.prototype.__proto__||Object.getPrototypeOf(Overlay.prototype),'refresh',this).call(this);return this;}/**
	 * Given an array of point based geometry, return the clipped geometry.
	 *
	 * @param {Cell} cell - The rendering cell.
	 *
	 * @returns {Array} The array of clipped geometry.
	 *//* eslint-disable no-unused-vars */},{key:'clipGeometry',value:function clipGeometry(cell){throw'`clipGeometry` must be overridden';}/**
	 * Returns the clipped geometry for the overlay.
	 *
	 * @returns {Array} The array of clipped geometry.
	 */},{key:'getClippedGeometry',value:function getClippedGeometry(){return this[CLIPPED];}}]);return Overlay;}(Layer);module.exports=Overlay;

},{"../../event/EventType":141,"../Layer":152}],154:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Overlay=require('./Overlay');// Private Methods
var clipPoints=function clipPoints(cell,points){var clipped=[];points.forEach(function(pts){var clippedPoints=cell.bounds.clipPoints(pts);if(!clippedPoints){return;}for(var i=0;i<clippedPoints.length;i++){clipped.push(cell.project(clippedPoints[i]));}});return clipped;};/**
 * Class representing a point overlay.
 */var PointOverlay=function(_Overlay){_inherits(PointOverlay,_Overlay);/**
	 * Instantiates a new PointOverlay object.
	 *
	 * @param {Object} options - The layer options.
	 * @param {number} options.opacity - The layer opacity.
	 * @param {number} options.zIndex - The layer z-index.
	 */function PointOverlay(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,PointOverlay);var _this=_possibleConstructorReturn(this,(PointOverlay.__proto__||Object.getPrototypeOf(PointOverlay)).call(this,options));_this.points=new Map();return _this;}/**
	 * Add a set of points to render.
	 *
	 * @param {string} id - The id to store the points under.
	 * @param {Array} points - The points.
	 *
	 * @returns {PointOverlay} The overlay object, for chaining.
	 */_createClass(PointOverlay,[{key:'addPoints',value:function addPoints(id,points){this.points.set(id,points);if(this.plot){this.refresh();}return this;}/**
	 * Remove a set of points by id from the overlay.
	 *
	 * @param {string} id - The id to store the points under.
	 *
	 * @returns {PointOverlay} The overlay object, for chaining.
	 */},{key:'removePoints',value:function removePoints(id){this.points.delete(id);if(this.plot){this.refresh();}return this;}/**
	 * Remove all points from the layer.
	 *
	 * @returns {PointOverlay} The overlay object, for chaining.
	 */},{key:'clearPoints',value:function clearPoints(){this.clear();this.points=new Map();if(this.plot){this.refresh();}return this;}/**
	 * Given an array of point based geometry, return the clipped geometry.
	 *
	 * @param {Cell} cell - The rendering cell.
	 *
	 * @returns {Array} The array of clipped geometry.
	 */},{key:'clipGeometry',value:function clipGeometry(cell){return clipPoints(cell,this.points);}}]);return PointOverlay;}(Overlay);module.exports=PointOverlay;

},{"./Overlay":153}],155:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Overlay=require('./Overlay');// Private Methods
var clipPolygons=function clipPolygons(cell,polygons){var clipped=[];polygons.forEach(function(polygon){var clippedPolygon=cell.bounds.clipPolygon(polygon);if(!clippedPolygon){return;}var result=new Array(clippedPolygon.length);for(var i=0;i<clippedPolygon.length;i++){result[i]=cell.project(clippedPolygon[i]);}clipped.push(result);});return clipped;};/**
 * Class representing a polygon overlay.
 */var PolygonOverlay=function(_Overlay){_inherits(PolygonOverlay,_Overlay);/**
	 * Instantiates a new PolygonOverlay object.
	 *
	 * @param {Object} options - The layer options.
	 * @param {Renderer} options.renderer - The layer renderer.
	 * @param {number} options.opacity - The layer opacity.
	 * @param {number} options.zIndex - The layer z-index.
	 */function PolygonOverlay(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,PolygonOverlay);var _this=_possibleConstructorReturn(this,(PolygonOverlay.__proto__||Object.getPrototypeOf(PolygonOverlay)).call(this,options));_this.polygons=new Map();return _this;}/**
	 * Add a set of points to render as a single polygon.
	 *
	 * @param {string} id - The id to store the polygon under.
	 * @param {Array} points - The polygon points.
	 *
	 * @returns {PolygonOverlay} The overlay object, for chaining.
	 */_createClass(PolygonOverlay,[{key:'addPolygon',value:function addPolygon(id,points){this.polygons.set(id,points);if(this.plot){this.refresh();}return this;}/**
	 * Remove a polygon by id from the overlay.
	 *
	 * @param {string} id - The id to store the polygon under.
	 *
	 * @returns {PolygonOverlay} The overlay object, for chaining.
	 */},{key:'removePolygon',value:function removePolygon(id){this.polygons.delete(id);if(this.plot){this.refresh();}return this;}/**
	 * Remove all polygons from the layer.
	 *
	 * @returns {PolygonOverlay} The overlay object, for chaining.
	 */},{key:'clearPolylines',value:function clearPolylines(){this.clear();this.polygons=new Map();if(this.plot){this.refresh();}return this;}/**
	 * Given an array of point based geometry, return the clipped geometry.
	 *
	 * @param {Cell} cell - The rendering cell.
	 *
	 * @returns {Array} The array of clipped geometry.
	 */},{key:'clipGeometry',value:function clipGeometry(cell){return clipPolygons(cell,this.polygons);}}]);return PolygonOverlay;}(Overlay);module.exports=PolygonOverlay;

},{"./Overlay":153}],156:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Overlay=require('./Overlay');// Private Methods
var clipPolylines=function clipPolylines(cell,polylines){var clipped=[];polylines.forEach(function(polyline){// clip the polyline, resulting in multiple clipped polylines
var clippedPolylines=cell.bounds.clipPolyline(polyline);if(!clippedPolylines){return;}for(var i=0;i<clippedPolylines.length;i++){var clippedPolyline=clippedPolylines[i];for(var j=0;j<clippedPolyline.length;j++){// project in place
clippedPolyline[j]=cell.project(clippedPolyline[j]);}clipped.push(clippedPolyline);}});return clipped;};/**
 * Class representing a polyline overlay.
 */var PolylineOverlay=function(_Overlay){_inherits(PolylineOverlay,_Overlay);/**
	 * Instantiates a new PolylineOverlay object.
	 *
	 * @param {Object} options - The layer options.
	 * @param {Renderer} options.renderer - The layer renderer.
	 * @param {number} options.opacity - The layer opacity.
	 * @param {number} options.zIndex - The layer z-index.
	 */function PolylineOverlay(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,PolylineOverlay);var _this=_possibleConstructorReturn(this,(PolylineOverlay.__proto__||Object.getPrototypeOf(PolylineOverlay)).call(this,options));_this.polylines=new Map();return _this;}/**
	 * Add a set of points to render as a single polyline.
	 *
	 * @param {string} id - The id to store the polyline under.
	 * @param {Array} points - The polyline points.
	 *
	 * @returns {PolylineOverlay} The overlay object, for chaining.
	 */_createClass(PolylineOverlay,[{key:'addPolyline',value:function addPolyline(id,points){this.polylines.set(id,points);if(this.plot){this.refresh();}return this;}/**
	 * Remove a polyline by id from the overlay.
	 *
	 * @param {string} id - The id to store the polyline under.
	 *
	 * @returns {PolylineOverlay} The overlay object, for chaining.
	 */},{key:'removePolyline',value:function removePolyline(id){this.polylines.delete(id);if(this.plot){this.refresh();}return this;}/**
	 * Remove all polylines from the layer.
	 *
	 * @returns {PolylineOverlay} The overlay object, for chaining.
	 */},{key:'clearPolylines',value:function clearPolylines(){this.clear();this.polylines=new Map();if(this.plot){this.refresh();}return this;}/**
	 * Given an array of point based geometry, return the clipped geometry.
	 *
	 * @param {Cell} cell - The rendering cell.
	 *
	 * @returns {Array} The array of clipped geometry.
	 */},{key:'clipGeometry',value:function clipGeometry(cell){return clipPolylines(cell,this.polylines);}}]);return PolylineOverlay;}(Overlay);module.exports=PolylineOverlay;

},{"./Overlay":153}],157:[function(require,module,exports){
'use strict';// Constants
/**
 * Maximum safe integer.
 * @private
 * @constant {number}
 */function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var MAX_SAFE_INT=Math.pow(2,53)-1;// Private Methods
var uid=1;var getUID=function getUID(){uid=(uid+1)%MAX_SAFE_INT;return uid;};/**
 * Class representing a tile.
 */var Tile=/**
	 * Instantiates a new Tile object.
	 *
	 * @param {TileCoord} coord - The coord of the tile.
	 */function Tile(coord){_classCallCheck(this,Tile);this.coord=coord;this.uid=getUID();this.data=null;this.err=null;};module.exports=Tile;

},{}],158:[function(require,module,exports){
'use strict';// Private Methods
var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var mod=function mod(n,m){return(n%m+m)%m;};/**
 * Class representing a tile coordinate.
 */var TileCoord=function(){/**
	 * Instantiates a new TileCoord object.
	 *
	 * @param {number} z - The z component of the tile coordinate.
	 * @param {number} x - The x component of the tile coordinate.
	 * @param {number} y - The y component of the tile coordinate.
	 */function TileCoord(z,x,y){_classCallCheck(this,TileCoord);this.z=z;this.x=x;this.y=y;this.hash=this.z+':'+this.x+':'+this.y;}/**
	 * Returns the XYZ URL string.
	 *
	 * @returns {string} The XYZ URL string.
	 */_createClass(TileCoord,[{key:'xyz',value:function xyz(){var dim=Math.pow(2,this.z);return this.z+'/'+this.x+'/'+(dim-1-this.y);}/**
	 * Returns the TMS URL string.
	 *
	 * @returns {string} The TMS URL string.
	 */},{key:'tms',value:function tms(){return this.z+'/'+this.x+'/'+this.y;}/**
	 * Test if the bounds equals another.
	 *
	 * @param {TileCoord} coord - The coord object to test.
	 *
	 * @returns {boolean} Whether or not the coord objects are equal.
	 */},{key:'equals',value:function equals(coord){return this.z===coord.z&&this.x===coord.x&&this.y===coord.y;}/**
	 * Get the ancestor coord.
	 *
	 * @param {number} offset - The offset of the ancestor from the coord. Optional.
	 *
	 * @returns {TileCoord} The ancestor coord.
	 */},{key:'getAncestor',value:function getAncestor(){var offset=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var scale=Math.pow(2,offset);return new TileCoord(this.z-offset,Math.floor(this.x/scale),Math.floor(this.y/scale));}/**
	 * Get the descendants of the coord.
	 *
	 * @param {number} offset - The offset of the descendants from the coord. Optional.
	 *
	 * @returns {Array} The array of descendant coords.
	 */},{key:'getDescendants',value:function getDescendants(){var offset=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var scale=Math.pow(2,offset);var coords=new Array(scale*scale);for(var x=0;x<scale;x++){var stride=x*scale;for(var y=0;y<scale;y++){coords[stride+y]=new TileCoord(this.z+offset,this.x*scale+x,this.y*scale+y);}}return coords;}/**
	 * Test if the coord is an ancestor of the provided coord.
	 *
	 * @param {TileCoord} coord - The coord object to test.
	 *
	 * @returns {boolean} Whether or not the provided coord is an ancestor.
	 */},{key:'isAncestorOf',value:function isAncestorOf(coord){if(this.z>=coord.z){return false;}var diff=coord.z-this.z;var scale=Math.pow(2,diff);var x=Math.floor(coord.x/scale);if(this.x!==x){return false;}var y=Math.floor(coord.y/scale);return this.y===y;}/**
	 * Test if the coord is a descendant of the provided coord.
	 *
	 * @param {TileCoord} coord - The coord object to test.
	 *
	 * @returns {boolean} Whether or not the provided coord is a descendant.
	 */},{key:'isDescendantOf',value:function isDescendantOf(coord){return coord.isAncestorOf(this);}/**
	 * Returns the normalized coord.
	 *
	 * @returns {TileCoord} The normalized coord.
	 */},{key:'normalize',value:function normalize(){var dim=Math.pow(2,this.z);return new TileCoord(this.z,mod(this.x,dim),mod(this.y,dim));}/**
	 * Returns the plot coordinate for the bottom-left corner of the coord.
	 *
	 * @returns {Object} The plot position of the coord.
	 */},{key:'getPosition',value:function getPosition(){var dim=Math.pow(2,this.z);return{x:this.x/dim,y:this.y/dim};}/**
	 * Returns the plot coordinate for the center of the coord.
	 *
	 * @returns {Object} The plot position of the center.
	 */},{key:'getCenter',value:function getCenter(){var dim=Math.pow(2,this.z);return{x:(this.x+0.5)/dim,y:(this.y+0.5)/dim};}}]);return TileCoord;}();module.exports=TileCoord;

},{}],159:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var defaultTo=require('lodash/defaultTo');var Layer=require('../Layer');var TilePyramid=require('./TilePyramid');// Private Methods
var requestVisibleTiles=function requestVisibleTiles(layer){// get visible coords
var coords=layer.plot.getTargetVisibleCoords();// request tiles
layer.requestTiles(coords);};/**
 * Class representing a tile-based layer.
 */var TileLayer=function(_Layer){_inherits(TileLayer,_Layer);/**
	 * Instantiates a new TileLayer object.
	 *
	 * @param {Object} options - The layer options.
	 * @param {number} options.opacity - The layer opacity.
	 * @param {number} options.zIndex - The layer z-index.
	 * @param {boolean} options.hidden - Whether or not the layer is visible.
	 * @param {boolean} options.muted - Whether or not the layer is muted.
	 * @param {number} options.cacheSize - The size of the temporary tile cache.
	 * @param {number} options.numPersistentLevels - The number of persistent levels in the tile pyramid.
	 */function TileLayer(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,TileLayer);var _this=_possibleConstructorReturn(this,(TileLayer.__proto__||Object.getPrototypeOf(TileLayer)).call(this,options));_this.muted=defaultTo(options.muted,false);_this.pyramid=new TilePyramid(_this,options);return _this;}/**
	 * Executed when the layer is attached to a plot.
	 *
	 * @param {Plot} plot - The plot to attach the layer to.
	 *
	 * @returns {TileLayer} The layer object, for chaining.
	 */_createClass(TileLayer,[{key:'onAdd',value:function onAdd(plot){_get(TileLayer.prototype.__proto__||Object.getPrototypeOf(TileLayer.prototype),'onAdd',this).call(this,plot);// request tiles if not muted
if(!this.isMuted()){requestVisibleTiles(this);}return this;}/**
	 * Executed when the layer is removed from a plot.
	 *
	 * @param {Plot} plot - The plot to remove the layer from.
	 *
	 * @returns {TileLayer} The layer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(plot){// clear the underlying pyramid
this.pyramid.clear();_get(TileLayer.prototype.__proto__||Object.getPrototypeOf(TileLayer.prototype),'onRemove',this).call(this,plot);return this;}/**
	 * Returns the tile pyramid of the layer.
	 *
	 * @returns {TilePyramid} The tile pyramid object.
	 */},{key:'getPyramid',value:function getPyramid(){return this.pyramid;}/**
	 * Make the layer invisible.
	 *
	 * @returns {TileLayer} The layer object, for chaining.
	 */},{key:'hide',value:function hide(){_get(TileLayer.prototype.__proto__||Object.getPrototypeOf(TileLayer.prototype),'hide',this).call(this);return this;}/**
	 * Mutes the layer, it will no longer send any tile requests.
	 *
	 * @returns {TileLayer} The layer object, for chaining.
	 */},{key:'mute',value:function mute(){this.muted=true;return this;}/**
	 * Unmutes the layer and immediately requests all visible tiles.
	 *
	 * @returns {TileLayer} The layer object, for chaining.
	 */},{key:'unmute',value:function unmute(){if(this.isMuted()){this.muted=false;if(this.plot){// request visible tiles
requestVisibleTiles(this);}}return this;}/**
	 * Returns true if the layer is muted.
	 *
	 * @returns {boolean} Whether or not the layer is muted.
	 */},{key:'isMuted',value:function isMuted(){return this.muted;}/**
	 * Unmutes and shows the layer.
	 *
	 * @returns {TileLayer} The layer object, for chaining.
	 */},{key:'enable',value:function enable(){this.show();this.unmute();return this;}/**
	 * Mutes and hides the layer.
	 *
	 * @returns {TileLayer} The layer object, for chaining.
	 */},{key:'disable',value:function disable(){this.hide();this.mute();return this;}/**
	 * Returns true if the layer is disabled (muted and hidden).
	 *
	 * @returns {boolean} Whether or not the layer is disabled.
	 */},{key:'isDisabled',value:function isDisabled(){return this.isMuted()&&this.isHidden();}/**
	 * Clears any persisted state in the layer and refreshes the underlying
	 * data. This involves emptying the tile pyramid and re-requesting all the
	 * tiles.
	 *
	 * @returns {TileLayer} The layer object, for chaining.
	 *//**
 	 * Clears any persisted state in the layer and refreshes the underlying
 	 * data.
 	 */},{key:'refresh',value:function refresh(){// clear the underlying pyramid
this.pyramid.clear();// request if attached and not muted
if(this.plot&&!this.isMuted()){// request visible tiles
requestVisibleTiles(this);}_get(TileLayer.prototype.__proto__||Object.getPrototypeOf(TileLayer.prototype),'refresh',this).call(this);return this;}/**
	 * Request a specific tile.
	 *
	 * @param {TileCoord} coord - The coord of the tile to request.
	 * @param {Function} done - The callback function to execute upon completion.
	 */},{key:'requestTile',value:function requestTile(coord,done){done(null,null);}/**
	 * Request an array of tiles.
	 *
	 * @param {Array} coords - The coords of the tiles to request.
	 *
	 * @returns {TileLayer} The layer object, for chaining.
	 */},{key:'requestTiles',value:function requestTiles(coords){if(this.isMuted()){return this;}this.pyramid.requestTiles(coords);return this;}}]);return TileLayer;}(Layer);module.exports=TileLayer;

},{"../Layer":152,"./TilePyramid":161,"lodash/defaultTo":109}],160:[function(require,module,exports){
'use strict';/**
 * Class representing a partial tile.
 */var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var TilePartial=function(){/**
	 * Instantiates a new TilePartial object.
	 *
	 * A TilePartial is used to render at least a portion of a missing tile at
	 * the closest available level-of-detail. There are three cases of
	 * instantiation.
	 *
	 * A) Closest available level-of-detail is an ancestor tile.
	 *    - The "target" tile is completely covered by a portion of the "found"
	 *      tile.
	 *    - There is no positional offset nor scaling of the "found" tile, it
	 *      will cover the "target" tile in its entirely.
	 *    - There is a uv offset to render the relevant portion of the "found"
	 *      tile.
	 *
	 * B) Closest available level-of-detail is a descendant tile.
	 *    - The "target" tile is partially covered by the "found" tile.
	 *    - There is a positional offset and scale of the "found" tile relative
	 *      to the "target" tile.
	 *    - There is no uv offset, the "found" tile is rendered in its entirety.
	 *
	 * C) Closest available level-of-detail is an ancestor of the "target", but
	 *    is used to cover a missing descendant. This occurs when one or more
	 *    descendant tiles cover a portion of the "target" tile, but an ancestor
	 *    is required to fill in a missing descendant.
	 *    - The "target" tile is partially covered by the "found" tile.
	 *    - There is a positional offset and scale of the "found" tile relative
	 *      to the descendant the tile is covering.
	 *    - There is a uv offset to render the relevant portion of the "found"
	 *      tile which covers the descendant.
	 *
	 * @param {Coord} target - The coordinate of the tile that is being substituted.
	 * @param {Tile} tile - The tile data of the partial found.
	 * @param {Coord} relative - The coordinate of the tile to position the found tile relative to.
	 */function TilePartial(target,tile,relative){_classCallCheck(this,TilePartial);this.target=target;this.tile=tile;this.relative=relative;}/**
	 * Instantiate a TilePartial object from the tile itself.
	 *
	 * @param {Tile} tile - The tile data of the partial.
	 *
	 * @returns {TilePartial} The TilePartial object.
	 */_createClass(TilePartial,null,[{key:'fromTile',value:function fromTile(tile){return new TilePartial(tile,tile,null);}/**
	 * Instantiate a TilePartial object from an ancestor.
	 *
	 * @param {Coord} target - The coordinate of the tile that is being substituted.
	 * @param {Tile} tile - The tile ancestor data of the partial.
	 * @param {Coord} relative - The coordinate of the tile to position the found tile relative to.
	 *
	 * @returns {TilePartial} The TilePartial object.
	 */},{key:'fromAncestor',value:function fromAncestor(target,tile,relative){return new TilePartial(target,tile,relative);}/**
	 * Instantiate a TilePartial object from a descendant.
	 *
	 * @param {Coord} target - The coordinate of the tile that is being substituted.
	 * @param {Tile} tile - The tile ancestor data of the partial.
	 *
	 * @returns {TilePartial} The TilePartial object.
	 */},{key:'fromDescendant',value:function fromDescendant(target,tile){return new TilePartial(target,tile,null);}}]);return TilePartial;}();module.exports=TilePartial;

},{}],161:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var defaultTo=require('lodash/defaultTo');var throttle=require('lodash/throttle');var EventType=require('../../event/EventType');var TileEvent=require('../../event/TileEvent');var LRUCache=require('../../util/LRUCache');var Tile=require('./Tile');var TilePartial=require('./TilePartial');// Constants
/**
 * number of the tiles held in the pyramid.
 * @private
 * @constant {number}
 */var CACHE_SIZE=256;/**
 * number of persistent zoom levels held in the pyramids.
 * @private
 * @constant {number}
 */var PERSISTANT_LEVELS=4;/**
 * Loaded event throttle in milliseconds.
 * @private
 * @constant {number}
 */var LOADED_THROTTLE_MS=200;/**
 * The maximum distance to traverse when checking for tile descendants.
 * @private
 * @constant {number}
 */var MAX_DESCENDENT_DIST=4;// Private Methods
var add=function add(pyramid,tile){if(tile.coord.z<pyramid.numPersistentLevels){// persistent tiles
if(pyramid.persistents.has(tile.coord.hash)){throw'Tile of coord '+tile.coord.hash+' already exists in the pyramid';}pyramid.persistents.set(tile.coord.hash,tile);}else{// non-persistent tiles
if(pyramid.tiles.has(tile.coord.hash)){throw'Tile of coord '+tile.coord.hash+' already exists in the pyramid';}pyramid.tiles.set(tile.coord.hash,tile);}// store in level arrays
if(!pyramid.levels.has(tile.coord.z)){pyramid.levels.set(tile.coord.z,[]);}pyramid.levels.get(tile.coord.z).push(tile);// emit add
pyramid.layer.emit(EventType.TILE_ADD,new TileEvent(pyramid.layer,tile));};var remove=function remove(pyramid,tile){// only check for persistent since we it will already be removed from lru
// cache
if(tile.coord.z<pyramid.numPersistentLevels){if(!pyramid.persistents.has(tile.coord.hash)){throw'Tile of coord '+tile.coord.hash+' does not exists in the pyramid';}pyramid.persistents.delete(tile.coord.hash);}// remove from levels
var level=pyramid.levels.get(tile.coord.z);level.splice(level.indexOf(tile),1);if(level.length===0){pyramid.levels.delete(tile.coord.z);}// emit remove
pyramid.layer.emit(EventType.TILE_REMOVE,new TileEvent(pyramid.layer,tile));};var sumPowerOfFour=function sumPowerOfFour(n){return 1/3*(Math.pow(4,n)-1);};var checkIfLoaded=function checkIfLoaded(pyramid){// if no more pending tiles, emit load
if(pyramid.pending.size===0){pyramid.emitLoad(new TileEvent(pyramid.layer,null));}};var sortAroundCenter=function sortAroundCenter(plot,pairs){// get the plot center position
var center=plot.getTargetViewportCenter();// sort the requests by distance from center tile
pairs.sort(function(a,b){var aCenter=a.coord.getCenter();var bCenter=b.coord.getCenter();var dax=center.x-aCenter.x;var day=center.y-aCenter.y;var dbx=center.x-bCenter.x;var dby=center.y-bCenter.y;var da=dax*dax+day*day;var db=dbx*dbx+dby*dby;return da-db;});return pairs;};var removeDuplicates=function removeDuplicates(pairs){var seen=new Map();return pairs.filter(function(pair){var hash=pair.ncoord.hash;return seen.has(hash)?false:seen.set(hash,true);});};var removePendingOrExisting=function removePendingOrExisting(pyramid,pairs){return pairs.filter(function(pair){// we already have the tile, or it's currently pending
// NOTE: use `get` here to update the recentness of the tile in LRU
return!pyramid.get(pair.ncoord)&&!pyramid.isPending(pair.ncoord);});};var flagTileAsStale=function flagTileAsStale(pyramid,tile){var hash=tile.coord.hash;var uids=pyramid.stale.get(hash);if(!uids){uids=new Map();pyramid.stale.set(hash,uids);}uids.set(tile.uid,true);};var isTileStale=function isTileStale(pyramid,tile){var hash=tile.coord.hash;// check if uid is flagged as stale
var uids=pyramid.stale.get(hash);if(uids&&uids.has(tile.uid)){// tile is stale
uids.delete(tile.uid);if(uids.size===0){pyramid.stale.delete(hash);}return true;}return false;};var shouldDiscard=function shouldDiscard(pyramid,tile){var plot=pyramid.layer.plot;if(!plot){// layer has been removed from plot, discard tile
// NOTE: this should _NEVER_ happen, since when a layer is remove from
// the plot, the pending tiles are all flagged as stale.
return true;}// check if tile is in view, if not, discard
var viewport=plot.getTargetViewport();return!viewport.isInView(tile.coord,plot.wraparound);};/**
 * Class representing a pyramid of tiles.
 */var TilePyramid=function(){/**
	 * Instantiates a new TilePyramid object.
	 *
	 * @param {Layer} layer - The layer object.
	 * @param {Object} options - The pyramid options.
	 * @param {number} options.cacheSize - The size of the tile cache.
	 * @param {number} options.numPersistentLevels - The number of persistent levels in the pyramid.
	 */function TilePyramid(layer){var _this=this;var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,TilePyramid);if(!layer){throw'No layer parameter provided';}this.cacheSize=defaultTo(options.cacheSize,CACHE_SIZE);this.numPersistentLevels=defaultTo(options.numPersistentLevels,PERSISTANT_LEVELS);this.layer=layer;this.levels=new Map();this.persistents=new Map();this.pending=new Map();this.stale=new Map();this.tiles=new LRUCache({capacity:this.cacheSize,onRemove:function onRemove(tile){remove(_this,tile);}});// create throttled emit load event for this layer
this.emitLoad=throttle(function(event){_this.layer.emit(EventType.LOAD,event);},LOADED_THROTTLE_MS);}/**
	 * Returns the total capacity of the tile pyramid.
	 *
	 * @returns {number} The total capacity of the pyramid.
	 */_createClass(TilePyramid,[{key:'getCapacity',value:function getCapacity(){return this.cacheSize+sumPowerOfFour(this.numPersistentLevels);}/**
	 * Empties the current pyramid of all tiles, flags any pending tiles as
	 * stale.
	 */},{key:'clear',value:function clear(){var _this2=this;// any pending tiles are now flagged as stale
this.pending.forEach(function(tile){// flag uid as stale
flagTileAsStale(_this2,tile);});this.pending=new Map();// fresh map
// clear persistent tiles
this.persistents.forEach(function(tile){remove(_this2,tile);});this.persistents.clear();// clear lru cache
this.tiles.clear();}/**
	 * Test whether or not a coord is held in cache in the pyramid.
	 *
	 * @param {TileCoord} ncoord - The normalized coord to test.
	 *
	 * @returns {boolean} Whether or not the coord exists in the pyramid.
	 */},{key:'has',value:function has(ncoord){if(ncoord.z<this.numPersistentLevels){return this.persistents.has(ncoord.hash);}return this.tiles.has(ncoord.hash);}/**
	 * Iterates over and executes the provided function for all tiles.
	 *
	 * @param {Function} fn - The function to execute on each tile.
	 */},{key:'forEach',value:function forEach(fn){this.persistents.forEach(fn);this.tiles.forEach(fn);}/**
	 * Test whether or not a coord is currently pending.
	 *
	 * @param {TileCoord} ncoord - The normalized coord to test.
	 *
	 * @returns {boolean} Whether or not the coord is currently pending.
	 */},{key:'isPending',value:function isPending(ncoord){return this.pending.has(ncoord.hash);}/**
	 * Returns the tile matching the provided coord. If the tile does not
	 * exist, returns undefined.
	 *
	 * @param {TileCoord} ncoord - The normalized coord of the tile to return.
	 *
	 * @returns {Tile} The tile object.
	 */},{key:'get',value:function get(ncoord){if(ncoord.z<this.numPersistentLevels){return this.persistents.get(ncoord.hash);}return this.tiles.get(ncoord.hash);}/**
	 * Returns the ancestor tile of the coord at the provided offset. If no
	 * tile exists in the pyramid, returns undefined.
	 *
	 * @param {TileCoord} ncoord - The normalized coord of the tile.
	 * @param {number} dist - The offset from the tile.
	 *
	 * @returns {Tile} The ancestor tile of the provided coord.
	 */},{key:'getAncestor',value:function getAncestor(ncoord,dist){var ancestor=ncoord.getAncestor(dist);return this.get(ancestor);}/**
	 * Returns the descendant tiles of the coord at the provided offset. If at
	 * least one tile exists in the pyramid, an array of size 4^dist will be
	 * returned. Each element will either be a tile (in the case that it exists)
	 * or a coord (in the case that it does not exist). If no descendant tiles
	 * are found in the pyramid, returns undefined.
	 *
	 * @param {TileCoord} ncoord - The normalized coord of the tile.
	 * @param {number} dist - The offset from the tile.
	 *
	 * @returns {Array} The descendant tiles and or coordinates of the provided coord.
	 */},{key:'getDescendants',value:function getDescendants(ncoord,dist){// get coord descendants
var descendants=ncoord.getDescendants(dist);// check if we have any
var found=false;for(var i=0;i<descendants.length;i++){if(this.has(descendants[i])){found=true;break;}}// if so return what we have
if(found){var res=new Array(descendants.length);for(var _i=0;_i<descendants.length;_i++){var descendant=descendants[_i];// add tile if it exists, coord if it doesn't
res[_i]=this.get(descendant)||descendant;}return res;}return undefined;}/**
	 * Requests tiles for the provided coords. If the tiles already exist
	 * in the pyramid or is currently pending no request is made.
	 *
	 * @param {Array} coords - The array of coords to request.
	 */},{key:'requestTiles',value:function requestTiles(coords){var _this3=this;// we need both the normalized an un-normalized coords.
// normalized coords are used for requests while un-normalized are used
// to sort them around the viewport center
var pairs=coords.map(function(coord){return{coord:coord,ncoord:coord.normalize()};});// remove any duplicates
pairs=removeDuplicates(pairs);// remove any tiles we already have or that are currently pending
pairs=removePendingOrExisting(this,pairs);// sort coords by distance from viewport center
pairs=sortAroundCenter(this.layer.plot,pairs);// generate tiles and flag as pending
// NOTE: we flag them all now incase a `clear` is called inside the
// `requestTile` call.
var tiles=pairs.map(function(pair){var tile=new Tile(pair.ncoord);// add tile to pending array
_this3.pending.set(tile.coord.hash,tile);return tile;});// request the tiles
var _loop=function _loop(i){var tile=tiles[i];// emit request
_this3.layer.emit(EventType.TILE_REQUEST,new TileEvent(_this3.layer,tile));// request tile
_this3.layer.requestTile(tile.coord,function(err,data){// check if stale, clears tiles any flagged as stale
var isStale=isTileStale(_this3,tile);// if not stale remove tile from pending
if(!isStale){_this3.pending.delete(tile.coord.hash);}// check err
if(err!==null){// add err
tile.err=err;// emit failure
_this3.layer.emit(EventType.TILE_FAILURE,new TileEvent(_this3.layer,tile));// if not stale, check if loaded
if(!isStale){checkIfLoaded(_this3);}return;}// add data to the tile
tile.data=data;// check if tile should be discarded
if(isStale||shouldDiscard(_this3,tile)){// emit discard
_this3.layer.emit(EventType.TILE_DISCARD,new TileEvent(_this3.layer,tile));// if not stale, check if loaded
if(!isStale){checkIfLoaded(_this3);}return;}// add to tile pyramid
add(_this3,tile);// check if loaded
checkIfLoaded(_this3);// flag as dirty
_this3.layer.plot.setDirty();});};for(var i=0;i<tiles.length;i++){_loop(i);}}/**
	 * If the tile exists in the pyramid, return it. Otherwise return the
	 * closest available level-of-detail for tile, this may be a single ancestor
	 * or multiple descendants, or a combination of both.
	 *
	 * If no ancestor or descendants exist, return undefined.
	 *
	 * @param {TileCoord} ncoord - The normalized coord of the tile.
	 *
	 * @returns {Array} The array of tile partials that closest match the provided coord.
	 */},{key:'getAvailableLOD',value:function getAvailableLOD(ncoord){// check if we have the tile
var tile=this.get(ncoord);if(tile){// if exists, return it
return[TilePartial.fromTile(tile)];}// if not, find the closest available level-of-detail
// first, get the available levels of detail, ascending in distance
// from the original coord zoom
var zoom=ncoord.z;var levels=[];this.levels.forEach(function(_,key){if(key!==zoom){levels.push(key);}});levels.sort(function(a,b){// give priority to ancestor levels since they are cheaper
var da=a>zoom?a-zoom:zoom-a-0.5;var db=b>zoom?b-zoom:zoom-b-0.5;return da-db;});var results=[];var queue=[];var current=ncoord;var level=levels.shift();// second, iterate through available levels searching for the closest
// level-of-detail for the current head of the queue
while(current!==undefined&&level!==undefined){if(level<current.z){// try to find ancestor
var dist=current.z-level;var ancestor=this.getAncestor(current,dist);if(ancestor){// tile found, create a tile partial from the ancestor
results.push(TilePartial.fromAncestor(ncoord,// target
ancestor,// tile
current));// relative
// pop next coord to search off the queue
current=queue.shift();continue;}}else{// descendant checks are much more expensive, so limit this
// based on distance to the original coord zoom
// NOTE: this distance calculation is safe because it is always
// true that "current.z >= zoom" because only descendant coords
// are appended to the queue.
// therefore in the case that "level >= current.z", then
// "level >= zoom" must be true as well.
var ndist=level-zoom;if(ndist<MAX_DESCENDENT_DIST){// try to find descendant
var _dist=level-current.z;var descendants=this.getDescendants(current,_dist);if(descendants){for(var j=0;j<descendants.length;j++){var descendant=descendants[j];if(descendant.coord){// tile found,  create a tile partial from the
// descendant
results.push(TilePartial.fromDescendant(ncoord,// target
descendant));// tile
}else{// no tile found, descendant is a coord
queue.push(descendant);}continue;}current=queue.shift();}}}// nothing found in level, we can safely remove it from the search
level=levels.shift();}return results.length>0?results:undefined;}}]);return TilePyramid;}();module.exports=TilePyramid;

},{"../../event/EventType":141,"../../event/TileEvent":144,"../../util/LRUCache":187,"./Tile":157,"./TilePartial":160,"lodash/defaultTo":109,"lodash/throttle":133}],162:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var Bounds=require('../geometry/Bounds');/**
 * The size of the cell, in pixels.
 * @private
 * @constant {number}
 */var CELL_SIZE=Math.pow(2,16);/**
 * The half size of the cell, in pixels.
 * @private
 * @constant {number}
 */var CELL_HALF_SIZE=CELL_SIZE/2;/**
 * Class representing a cell for clipping a rendering space.
 * @private
 */var Cell=function(){/**
	 * Instantiates a new Cell object.
	 *
	 * @param {number} zoom - The zoom the the cells is generated for.
	 * @param {Object} center - The plot position of the center of the cell.
	 * @param {number} extent - The pixel extent of the plot at the time of generation.
	 */function Cell(zoom,center,extent){_classCallCheck(this,Cell);var halfSize=CELL_HALF_SIZE/extent;var offset={x:center.x-halfSize,y:center.y-halfSize};this.zoom=zoom;this.halfSize=halfSize;this.center=center;this.offset=offset;this.extent=extent;this.bounds=new Bounds(center.x-halfSize,center.x+halfSize,center.y-halfSize,center.y+halfSize);}/**
	 * Project a normalized plot coordinate to the pixel space of the cell.
	 *
	 * @param {Object} pos - The normalized plot coordinate.
	 * @param {number} zoom - The zoom of the plot pixel space to project to. Optional.
	 *
	 * @returns {Object} The coordinate in cell pixel space.
	 */_createClass(Cell,[{key:'project',value:function project(pos){var zoom=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.zoom;var scale=Math.pow(2,zoom-this.zoom)*this.extent;return{x:(pos.x-this.offset.x)*scale,y:(pos.y-this.offset.y)*scale};}/**
	 * Unproject a coordinate from the pixel space of the cell to a normalized
	 * plot coordinate.
	 *
	 * @param {Object} px - The plot pixel coordinate.
	 * @param {number} zoom - The zoom of the plot pixel space to unproject from. Optional.
	 *
	 * @returns {Object} The normalized plot coordinate.
	 */},{key:'unproject',value:function unproject(px){var zoom=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.zoom;var scale=Math.pow(2,zoom-this.zoom)*this.extent;return{x:px.x/scale+this.offset.x,y:px.y/scale+this.offset.y};}}]);return Cell;}();module.exports=Cell;

},{"../geometry/Bounds":146}],163:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var clamp=require('lodash/clamp');var defaultTo=require('lodash/defaultTo');var throttle=require('lodash/throttle');var EventEmitter=require('events');var EventType=require('../event/EventType');var EventBroadcaster=require('../event/EventBroadcaster');var EventDelegator=require('../event/EventDelegator');var Event=require('../event/Event');var ResizeEvent=require('../event/ResizeEvent');var RenderBuffer=require('../webgl/RenderBuffer');var ClickHandler=require('./handler/ClickHandler');var MouseHandler=require('./handler/MouseHandler');var PanHandler=require('./handler/PanHandler');var ZoomHandler=require('./handler/ZoomHandler');var Cell=require('./Cell');var Viewport=require('./Viewport');// Constants
/**
 * Pan request throttle in milliseconds.
 * @private
 * @constant {number}
 */var PAN_THROTTLE_MS=100;/**
 * Resize request throttle in milliseconds.
 * @private
 * @constant {number}
 */var RESIZE_THROTTLE_MS=200;/**
 * Zoom request throttle in milliseconds.
 * @private
 * @constant {number}
 */var ZOOM_THROTTLE_MS=400;/**
 * The maximum zoom delta until a cell update event.
 * @private
 * @constant {number}
 */var CELL_ZOOM_DELTA=1.0;/**
 * The maximum zoom level supported.
 * @private
 * @constant {number}
 */var MAX_ZOOM=24;/**
 * Click handler symbol.
 * @private
 * @constant {Symbol}
 */var CLICK=Symbol();/**
 * Mouse handler symbol.
 * @private
 * @constant {Symbol}
 */var MOUSE=Symbol();/**
 * Pan handler symbol.
 * @private
 * @constant {Symbol}
 */var PAN=Symbol();/**
 * Zoom handler symbol.
 * @private
 * @constant {Symbol}
 */var ZOOM=Symbol();/**
 * Event handlers symbol.
 * @private
 * @constant {Symbol}
 */var HANDLERS=Symbol();/**
 * Event delegators symbol.
 * @private
 * @constant {Symbol}
 */var DELEGATOR=Symbol();/**
 * Event broadcasters symbol.
 * @private
 * @constant {Symbol}
 */var BROADCASTER=Symbol();/**
 * Dirty plot symbol.
 * @private
 * @constant {Symbol}
 */var DIRTY=Symbol();// Private Methods
var requestTiles=function requestTiles(){// get all visible coords in the target viewport
var coords=this.getTargetVisibleCoords();// for each layer
this.layers.forEach(function(layer){if(layer.requestTiles){// request tiles
layer.requestTiles(coords);}});return this;};var resize=function resize(plot){var current={width:plot.container.offsetWidth,height:plot.container.offsetHeight};var prev=plot.getViewportPixelSize();var center=plot.viewport.getCenter();if(prev.width!==current.width||prev.height!==current.height||plot.pixelRatio!==window.devicePixelRatio){// store device pixel ratio
plot.pixelRatio=window.devicePixelRatio;// resize canvas
plot.canvas.style.width=current.width+'px';plot.canvas.style.height=current.height+'px';plot.canvas.width=current.width*plot.pixelRatio;plot.canvas.height=current.height*plot.pixelRatio;// resize renderbuffer
plot.renderBuffer.resize(current.width*plot.pixelRatio,current.height*plot.pixelRatio);// update viewport
var extent=plot.getPixelExtent();plot.viewport.width=current.width/extent;plot.viewport.height=current.height/extent;// re-center viewport
plot.viewport.centerOn(center);// request tiles
plot.resizeRequest();// emit resize
plot.setDirty();plot.emit(EventType.RESIZE,new ResizeEvent(plot,prev,current));}};var updateCell=function updateCell(plot){var zoom=plot.getTargetZoom();var center=plot.getTargetViewportCenter();var extent=plot.getTargetPixelExtent();var size=plot.getViewportPixelSize();var cell=new Cell(zoom,center,extent);var refresh=false;// check if no cell exists
if(!plot.cell){refresh=true;}else{// check if we are outside of one zoom level from last
var zoomDist=Math.abs(plot.cell.zoom-cell.zoom);if(zoomDist>=CELL_ZOOM_DELTA){refresh=true;}else{// check if we are withing buffer distance of the cell bounds
var xDist=plot.cell.halfSize-size.width/plot.cell.extent;var yDist=plot.cell.halfSize-size.height/plot.cell.extent;if(Math.abs(cell.center.x-plot.cell.center.x)>xDist||Math.abs(cell.center.y-plot.cell.center.y)>yDist){refresh=true;}}}if(refresh){// update cell
plot.cell=cell;// emit cell refresh
plot.emit(EventType.CELL_UPDATE,new Event(cell));}};var reset=function reset(plot){if(!plot.wraparound){// if there is no wraparound, do not reset
return;}// resets the position of the viewport relative to the plot such that
// the plot native coordinate range is within the viewports bounds.
// get viewport width in plot coords
var width=Math.ceil(plot.viewport.width/1.0);// past the left bound of the viewport
if(plot.viewport.x>1.0){plot.viewport.x-=width;if(plot.isPanning()){plot.panAnimation.start.x-=width;}}// past the right bound of the viewport
if(plot.viewport.x+plot.viewport.width<0){plot.viewport.x+=width;if(plot.isPanning()){plot.panAnimation.start.x+=width;}}};var frame=function frame(plot){// get frame timestamp
var timestamp=Date.now();// emit frame event
plot.emit(EventType.FRAME,new Event(plot,timestamp));// update size
resize(plot);if(!plot.dirtyChecking||plot.isDirty()){// clear flag now, this way layers that may be animating can signal
// that the animation is not complete by flagging as dirty during the
// draw call.
plot.clearDirty();// apply the zoom animation
if(plot.isZooming()){if(plot.zoomAnimation.update(timestamp)){plot.zoomAnimation=null;}}// apply the pan animation
if(plot.isPanning()){if(plot.panAnimation.update(timestamp)){plot.panAnimation=null;}plot.panRequest();}// reset viewport / plot
reset(plot);// update cell
updateCell(plot);// get context
var gl=plot.getRenderingContext();// clear the backbuffer
gl.clearColor(0,0,0,0);gl.clear(gl.COLOR_BUFFER_BIT);// set the viewport
var size=plot.getViewportPixelSize();gl.viewport(0,0,size.width*plot.pixelRatio,size.height*plot.pixelRatio);// sort layers by z-index
var layers=plot.getSortedLayers();// render each layer
layers.forEach(function(layer){if(!layer.isHidden()){layer.draw(timestamp);}});}// request next frame
plot.frameRequest=requestAnimationFrame(function(){frame(plot);});};/**
 * Class representing a plot.
 */var Plot=function(_EventEmitter){_inherits(Plot,_EventEmitter);/**
	 * Instantiates a new Plot object.
	 *
	 * @param {string} selector - The selector for the container element.
	 * @param {Object} options - The plot options.
	 * @param {number} options.tileSize - The dimension in pixels of a tile.
	 * @param {number} options.zoom - The zoom of the plot.
	 * @param {number} options.minZoom - The minimum zoom of the plot.
	 * @param {number} options.maxZoom - The maximum zoom of the plot.
	 * @param {Object} options.center - The center of the plot, in plot pixels.
	 * @param {boolean} options.wraparound - Whether or not the plot wraps around.
	 * @param {boolean} options.context - The rendering context type, defaults to `webgl`.
	 * @param {boolean} options.contextAttributes - The rendering context attribtues argument. Optional.
	 * @param {boolean} options.dirtyChecking - Whether or not the plot uses dirty checking or renders every frame.
	 *
	 * @param {number} options.panThrottle - Pan request throttle timeout in ms.
	 * @param {number} options.resizeThrottle - Resize request throttle timeout in ms.
	 * @param {number} options.zoomThrottle - Zoom request throttle timeout in ms.
	 *
	 * @param {number} options.inertia - Whether or not pan inertia is enabled.
	 * @param {number} options.inertiaEasing - The inertia easing factor.
	 * @param {number} options.inertiaDeceleration - The inertia deceleration factor.
	 *
	 * @param {number} options.continuousZoom - Whether or not continuous zoom is enabled.
	 * @param {number} options.zoomDuration - The duration of the zoom animation.
	 * @param {number} options.maxConcurrentZooms - The maximum concurrent zooms in a single batch.
	 * @param {number} options.deltaPerZoom - The scroll delta required per zoom level.
	 * @param {number} options.zoomDebounce - The debounce duration of the zoom in ms.
	 */function Plot(selector){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Plot);var _this=_possibleConstructorReturn(this,(Plot.__proto__||Object.getPrototypeOf(Plot)).call(this));_this.container=document.querySelector(selector);if(!_this.container){throw'Element could not be found for selector '+selector;}// set pixel ratio
_this.pixelRatio=window.devicePixelRatio;// create canvas element
_this.canvas=document.createElement('canvas');_this.canvas.style.width=_this.container.offsetWidth+'px';_this.canvas.style.height=_this.container.offsetHeight+'px';_this.canvas.width=_this.container.offsetWidth*_this.pixelRatio;_this.canvas.height=_this.container.offsetHeight*_this.pixelRatio;_this.container.appendChild(_this.canvas);// get rendering context
_this.ctx=_this.canvas.getContext('webgl',options.contextAttributes);if(!_this.ctx){throw'Unable to create a WebGLRenderingContext, please ensure your browser supports WebGL';}// create renderbuffer
_this.renderBuffer=new RenderBuffer(_this.ctx,_this.canvas.width,_this.canvas.height);// tile size in pixels
_this.tileSize=defaultTo(options.tileSize,256);// min and max zoom of the plot
_this.minZoom=defaultTo(options.minZoom,0);_this.maxZoom=defaultTo(options.maxZoom,MAX_ZOOM);// current zoom of the plot
_this.zoom=defaultTo(options.zoom,0);_this.zoom=clamp(_this.zoom,_this.minZoom,_this.maxZoom);// set viewport
var span=Math.pow(2,_this.zoom);var width=_this.canvas.offsetWidth/span;var height=_this.canvas.offsetHeight/span;_this.viewport=new Viewport(0,0,width,height);// center the plot
var center=defaultTo(options.center,{x:0.5,y:0.5});_this.viewport.centerOn(center);// generate cell
_this.cell=null;updateCell(_this);// wraparound
_this.wraparound=defaultTo(options.wraparound,false);// throttled request methods
var panThrottle=defaultTo(options.panThrottle,PAN_THROTTLE_MS);var resizeThrottle=defaultTo(options.resizeThrottle,RESIZE_THROTTLE_MS);var zoomThrottle=defaultTo(options.zoomThrottle,ZOOM_THROTTLE_MS);_this.panRequest=throttle(requestTiles,panThrottle,{leading:false// invoke only on trailing edge
});_this.resizeRequest=throttle(requestTiles,resizeThrottle,{leading:false// invoke only on trailing edge
});_this.zoomRequest=throttle(requestTiles,zoomThrottle,{leading:false// invoke only on trailing edge
});// layers
_this.layers=[];// frame request
_this.frameRequest=null;// create and enable handlers
_this[HANDLERS]=new Map();_this[HANDLERS].set(CLICK,new ClickHandler(_this,options));_this[HANDLERS].set(MOUSE,new MouseHandler(_this,options));_this[HANDLERS].set(PAN,new PanHandler(_this,options));_this[HANDLERS].set(ZOOM,new ZoomHandler(_this,options));_this[HANDLERS].forEach(function(handler){handler.enable();});// delegator
_this[DELEGATOR]=new EventDelegator(_this);// delegate mouse / click events to layers
_this[DELEGATOR].delegate(EventType.CLICK);_this[DELEGATOR].delegate(EventType.DBL_CLICK);_this[DELEGATOR].delegate(EventType.MOUSE_MOVE);_this[DELEGATOR].delegate(EventType.MOUSE_UP);_this[DELEGATOR].delegate(EventType.MOUSE_DOWN);// broadcaster
_this[BROADCASTER]=new EventBroadcaster(_this);// broadcast zoom / pan events to layers
_this[BROADCASTER].broadcast(EventType.ZOOM_START);_this[BROADCASTER].broadcast(EventType.ZOOM);_this[BROADCASTER].broadcast(EventType.ZOOM_END);_this[BROADCASTER].broadcast(EventType.PAN_START);_this[BROADCASTER].broadcast(EventType.PAN);_this[BROADCASTER].broadcast(EventType.PAN_END);// whether or not to use dirty checking
_this.dirtyChecking=defaultTo(options.dirtyChecking,true);// flag as dirty
_this[DIRTY]=true;// begin frame loop
frame(_this);return _this;}/**
	 * Destroys the plots association with the underlying canvas element and
	 * disables all event handlers.
	 *
	 * @returns {Plot} The plot object, for chaining.
	 */_createClass(Plot,[{key:'destroy',value:function destroy(){var _this2=this;// stop animation loop
cancelAnimationFrame(this.frameRequest);this.frameRequest=null;// disable handlers
this[HANDLERS].forEach(function(handler){handler.disable();});// remove layers
this.layers.forEach(function(layer){_this2.remove(layer);});// destroy context
this.ctx=null;// remove canvas
this.container.removeChild(this.canvas);this.canvas=null;this.container=null;this.renderBuffer=null;return this;}/**
	 * Flags the plot as dirty singalling that it should be redrawn in the next
	 * frame.
	 */},{key:'setDirty',value:function setDirty(){this[DIRTY]=true;}/**
	 * Check if the plot is dirty and requires a redraw.
	 *
	 * @returns {boolean} Whether or not the plot should be redrawn.
 	*/},{key:'isDirty',value:function isDirty(){return this[DIRTY]||this.isPanning()||this.isZooming();}/**
	 * Clears the dirty flag for the next frame.
	 */},{key:'clearDirty',value:function clearDirty(){this[DIRTY]=false;}/**
	 * Adds a layer to the plot.
	 *
	 * @param {Layer} layer - The layer to add to the plot.
	 *
	 * @returns {Plot} The plot object, for chaining.
	 */},{key:'add',value:function add(layer){if(!layer){throw'No argument provided';}if(this.layers.indexOf(layer)!==-1){throw'Provided layer is already attached to the plot';}this.layers.push(layer);layer.onAdd(this);this.setDirty();return this;}/**
	 * Removes a layer from the plot.
	 *
	 * @param {Layer} layer - The layer to remove from the plot.
	 *
	 * @returns {Plot} The plot object, for chaining.
	 */},{key:'remove',value:function remove(layer){if(!layer){throw'No argument provided';}var index=this.layers.indexOf(layer);if(index===-1){throw'Provided layer is not attached to the plot';}this.layers.splice(index,1);layer.onRemove(this);this.setDirty();return this;}/**
	 * Returns the rendering context of the plot.
	 *
	 * @returns {WebGLRenderingContext|CanvasRenderingContext2D} The context object.
	 */},{key:'getRenderingContext',value:function getRenderingContext(){return this.ctx;}/**
	 * Returns all the layer objects attached to the plot, in descending
	 * order of z-index.
	 */},{key:'getSortedLayers',value:function getSortedLayers(){// sort by z-index
return this.layers.sort(function(a,b){return a.getZIndex()-b.getZIndex();});}},{key:'getZoom',/**
	 * Returns the current zoom of the plot.
	 *
	 * @returns {number} The current zoom of the plot.
	 */value:function getZoom(){return this.zoom;}/**
	 * Returns the target zoom of the plot. If the plot is actively zooming, it
	 * will return the destination zoom. If the plot is not actively zooming, it
	 * will return the current zoom.
	 *
	 * @returns {number} The target zoom of the plot.
	 */},{key:'getTargetZoom',value:function getTargetZoom(){if(this.isZooming()){// if zooming, use the target level
return this.zoomAnimation.targetZoom;}// if not zooming, use the current level
return this.zoom;}/**
	 * Returns the current viewport of the plot.
	 *
	 * @returns {number} The current viewport of the plot.
	 */},{key:'getViewport',value:function getViewport(){return this.viewport;}/**
	 * Returns the target viewport of the plot. If the plot is actively zooming,
	 * it will return the target viewport. If the plot is not actively zooming,
	 * it will return the current viewport.
	 *
	 * @returns {Viewport} The target viewport of the plot.
	 */},{key:'getTargetViewport',value:function getTargetViewport(){if(this.isZooming()){// if zooming, use the target viewport
return this.zoomAnimation.targetViewport;}// if not zooming, use the current viewport
return this.viewport;}/**
	 * Returns the current bottom-left corner of the viewport.
	 *
	 * @returns {Object} The current center in plot coordinates.
	 */},{key:'getViewportPosition',value:function getViewportPosition(){return this.viewport.getPosition();}/**
	 * Returns the target bottom-left corner of the viewport. If the plot is actively zooming
	 * or panning, it will return the destination center.
	 *
	 * @returns {Object} The target center in plot coordinates.
	 */},{key:'getTargetViewportPosition',value:function getTargetViewportPosition(){return this.getTargetViewport().getPosition();}/**
	 * Returns the current center of the viewport.
	 *
	 * @returns {Object} The current center in plot coordinates.
	 */},{key:'getViewportCenter',value:function getViewportCenter(){return this.viewport.getCenter();}/**
	 * Returns the target center of the plot in plot coordinates. If the plot is
	 * actively zooming or panning, it will return the destination center.
	 *
	 * @returns {Object} The target center in plot coordinates.
	 */},{key:'getTargetViewportCenter',value:function getTargetViewportCenter(){return this.getTargetViewport().getCenter();}/**
	 * Returns the center of the plot in plot coordinates.
	 *
	 * @returns {Object} The target center in plot coordinates.
	 */},{key:'getViewportCenter',value:function getViewportCenter(){return this.viewport.getCenter();}/**
	 * Returns the tile coordinates visible in the target viewport.
	 *
	 * @returns {Array} The array of visible tile coords.
	 */},{key:'getTargetVisibleCoords',value:function getTargetVisibleCoords(){var tileZoom=Math.round(this.getTargetZoom());// use target zoom
var viewport=this.getTargetViewport();// use target viewport
return viewport.getVisibleCoords(tileZoom,this.wraparound);}/**
	 * Returns the tile coordinates currently visible in the current viewport.
	 *
	 * @returns {Array} The array of visible tile coords.
	 */},{key:'getVisibleCoords',value:function getVisibleCoords(){var tileZoom=Math.round(this.zoom);// use current zoom
var viewport=this.viewport;// use current viewport
return viewport.getVisibleCoords(tileZoom,this.wraparound);}/**
	 * Returns the plot size in pixels.
	 *
	 * @returns {Object} The plot size in pixels.
	 */},{key:'getPixelExtent',value:function getPixelExtent(){return Math.pow(2,this.zoom)*this.tileSize;}/**
	 * Returns the target plot size in pixels.
	 *
	 * @returns {Object} The target plot size in pixels.
	 */},{key:'getTargetPixelExtent',value:function getTargetPixelExtent(){return Math.pow(2,this.getTargetZoom())*this.tileSize;}/**
	 * Returns the viewport size in pixels.
	 *
	 * @returns {Object} The viewport size in pixels.
	 */},{key:'getViewportPixelSize',value:function getViewportPixelSize(){return this.viewport.getPixelSize(this.zoom,this.tileSize);}/**
	 * Returns the target viewport size in pixels.
	 *
	 * @returns {Object} The target viewport size in pixels.
	 */},{key:'getTargetViewportPixelSize',value:function getTargetViewportPixelSize(){return this.getTargetViewport().getPixelSize(this.zoom,this.tileSize);}/**
	 * Returns the viewport offset in pixels.
	 *
	 * @returns {Object} The viewport offset in pixels.
	 */},{key:'getViewportPixelOffset',value:function getViewportPixelOffset(){return this.viewport.getPixelOffset(this.zoom,this.tileSize);}/**
	 * Returns the target viewport offset in pixels.
	 *
	 * @returns {Object} The target viewport offset in pixels.
	 */},{key:'getTargetViewportPixelOffset',value:function getTargetViewportPixelOffset(){return this.getTargetViewport().getPixelOffset(this.zoom,this.tileSize);}/**
	 * Returns the orthographic projection matrix for the viewport.
	 *
	 * @returns {Float32Array} The orthographic projection matrix.
	 */},{key:'getOrthoMatrix',value:function getOrthoMatrix(){var size=this.getViewportPixelSize();var left=0;var right=size.width;var bottom=0;var top=size.height;var near=-1;var far=1;var lr=1/(left-right);var bt=1/(bottom-top);var nf=1/(near-far);var out=new Float32Array(16);out[0]=-2*lr;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=-2*bt;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[10]=2*nf;out[11]=0;out[12]=(left+right)*lr;out[13]=(top+bottom)*bt;out[14]=(far+near)*nf;out[15]=1;return out;}/**
	 * Pans to the target plot coordinate. Cancels any current zoom or pan
	 * animations.
	 *
	 * @param {number} pos - The target plot position.
	 * @param {boolean} animate - Whether or not to animate the pan. Defaults to `true`.
	 *
	 * @returns {Plot} The plot object, for chaining.
	 */},{key:'panTo',value:function panTo(pos){var animate=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;// cancel existing animations
this.cancelPan();this.cancelZoom();this[HANDLERS].get(PAN).panTo(pos,animate);this.setDirty();return this;}/**
	 * Zooms in to the target zoom level. This is bounded by the plot objects
	 * minZoom and maxZoom attributes. Cancels any current zoom or pan
	 * animations.
	 *
	 * @param {number} level - The target zoom level.
	 * @param {boolean} animate - Whether or not to animate the zoom. Defaults to `true`.
	 *
	 * @returns {Plot} The plot object, for chaining.
	 */},{key:'zoomTo',value:function zoomTo(level){var animate=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;// cancel existing animations
this.cancelPan();this.cancelZoom();this[HANDLERS].get(ZOOM).zoomTo(level,animate);this.setDirty();return this;}/**
	 * Fit the plot to a provided bounds in plot coordinates.
	 *
	 * @param {Bounds} bounds - The bounds object, in plot coordinates.
	 *
	 * @returns {Plot} The plot object, for chaining.
	 */},{key:'fitToBounds',value:function fitToBounds(bounds){var targetZoom=this.getTargetZoom();var targetViewport=this.getTargetViewport();var scaleX=targetViewport.width/bounds.getWidth();var scaleY=targetViewport.height/bounds.getHeight();var scale=Math.min(scaleX,scaleY);var zoom=Math.log2(scale)+targetZoom;zoom=clamp(zoom,this.minZoom,this.maxZoom);if(!this.continuousZoom){zoom=Math.floor(zoom);}var center=bounds.getCenter();this.zoomTo(zoom,false);this.panTo(center,false);this.setDirty();return this;}/**
	 * Returns whether or not the plot is actively panning.
	 *
	 * @returns {bool} Whether or not the plot is panning.
	 */},{key:'isPanning',value:function isPanning(){return!!this.panAnimation;}/**
	 * Returns whether or not the plot is actively zooming.
	 *
	 * @returns {bool} Whether or not the plot is zooming.
	 */},{key:'isZooming',value:function isZooming(){return!!this.zoomAnimation;}/**
	 * Cancels any current pan animation.
	 *
	 * @returns {boolean} Whether or not the plot was panning.
	 */},{key:'cancelPan',value:function cancelPan(){if(this.isPanning()){this.panAnimation.cancel();this.panAnimation=null;return true;}return false;}/**
	 * Cancels any current zoom animation.
	 *
	 * @returns {boolean} Whether or not the plot was zooming.
	 */},{key:'cancelZoom',value:function cancelZoom(){if(this.isZooming()){this.zoomAnimation.cancel();this.zoomAnimation=null;return true;}return false;}/**
	 * Returns any highlighted data.
	 *
	 * @returns {Object} The highlighted data.
	 */},{key:'getHighlighted',value:function getHighlighted(){var layers=this.layers;for(var i=0;i<layers.length;i++){var highlight=layers[i].getHighlighted();if(highlight){return highlight;}}return null;}/**
	 * Returns true if the provided argument is highlighted.
	 *
	 * @param {Object} data - The data to test.
	 *
	 * @returns {boolean} Whether or not there is highlighted data.
	 */},{key:'isHighlighted',value:function isHighlighted(data){var layers=this.layers;for(var i=0;i<layers.length;i++){if(layers[i].isHighlighted(data)){return true;}}return false;}/**
	 * Returns any selected data.
	 *
	 * @returns {Array} The selected data.
	 */},{key:'getSelected',value:function getSelected(){var selection=[];var layers=this.layers;for(var i=0;i<layers.length;i++){var selected=layers[i].getSelected();for(var j=0;j<selected.length;j++){selection.push(selected[j]);}}return selection;}/**
	 * Returns true if the provided argument is selected.
	 *
	 * @param {Object} data - The data to test.
	 *
	 * @returns {boolean} Whether or not the data is selected.
	 */},{key:'isSelected',value:function isSelected(data){var layers=this.layers;for(var i=0;i<layers.length;i++){if(layers[i].isSelected(data)){return true;}}return false;}/**
	 * Return the containing element of the plot.
	 *
	 * @returns {HTMLElement} The container of the plot.
	 */},{key:'getContainer',value:function getContainer(){return this.container;}}]);return Plot;}(EventEmitter);module.exports=Plot;

},{"../event/Event":138,"../event/EventBroadcaster":139,"../event/EventDelegator":140,"../event/EventType":141,"../event/ResizeEvent":143,"../webgl/RenderBuffer":191,"./Cell":162,"./Viewport":164,"./handler/ClickHandler":168,"./handler/MouseHandler":170,"./handler/PanHandler":171,"./handler/ZoomHandler":172,"events":2,"lodash/clamp":107,"lodash/defaultTo":109,"lodash/throttle":133}],164:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var Bounds=require('../geometry/Bounds');var TileCoord=require('../layer/tile/TileCoord');// Private Methods
var getVisibleTileBounds=function getVisibleTileBounds(viewport,tileZoom,wraparound){var bounds=viewport.getTileBounds(tileZoom);// min / max tile coords
var dim=Math.pow(2,tileZoom);var min=0;var max=dim-1;// get the bounds of the zoom level
var layerBounds=new Bounds(wraparound?-Infinity:min,wraparound?Infinity:max,min,max);// check if the layer is within the viewport
if(!bounds.overlaps(layerBounds)){// there is no overlap
return undefined;}// clamp horizontal bounds if there is no wraparound
var left=wraparound?bounds.left:Math.max(min,bounds.left);var right=wraparound?bounds.right:Math.min(max,bounds.right);// clamp vertical bounds
var bottom=Math.max(min,bounds.bottom);var top=Math.min(max,bounds.top);return new Bounds(left,right,bottom,top);};var isWithinRange=function isWithinRange(min,max,m,n){// Given:
//    1) An integer range r = [min : max].
//    2) An power-of-two integer m.
//    3) An integer n within the within the range of [0 : m).
//    4) An integer constant k.
// Check if n, or any values of m +/- kn, is within the range R.
//
// Ex:
//     min: -3
//     max: 6
//     m: 8
//     n: 7
//
// Return true because 7 - 8 = -1, which is within the range -3 to 6.
// within range
if(min<=n&&n<=max){return true;}// if the range is above n, find how many m's fit
// in the distance between n and min
if(min>n){var _k=Math.ceil((min-n)/m);return n+_k*m<=max;}// if the range is below n, find how many m's fit
// in the distance between max and n
var k=Math.ceil((n-max)/m);return n-k*m>=min;};/**
 * Class representing a viewport.
 */var Viewport=function(){/**
	 * Instantiates a new Viewport object.
	 *
	 * @param {number} x - The x coordinate of the viewport.
	 * @param {number} y - The y coordinate of the viewport.
	 * @param {number} width - The width of the viewport.
	 * @param {number} height - The height of the viewport.
	 */function Viewport(x,y,width,height){_classCallCheck(this,Viewport);this.x=x;this.y=y;this.width=width;this.height=height;}/**
	 * Returns the tile bounds of the viewport. Bounds edges are inclusive.
	 * NOTE: this includes wraparound coordinates.
	 *
	 * @param {number} tileZoom - The zoom of the tiles within the viewport.
	 *
	 * @returns {Bounds} The tile bounds of the viewport.
	 */_createClass(Viewport,[{key:'getTileBounds',value:function getTileBounds(tileZoom){// calc how many fit are in the plot
var tileSpan=1/Math.pow(2,tileZoom);// determine bounds
return new Bounds(Math.floor(this.x/tileSpan),Math.ceil((this.x+this.width)/tileSpan)-1,Math.floor(this.y/tileSpan),Math.ceil((this.y+this.height)/tileSpan)-1);}/**
	 * Returns the coordinates that are visible in the viewport.
	 *
	 * @param {number} tileZoom - The zoom of the tiles within the viewport. Optional.
	 * @param {boolean} wraparound - The if the horizontal axis should wraparound. Optional.
	 *
	 * @returns {Array} The array of visible tile coords.
	 */},{key:'getVisibleCoords',value:function getVisibleCoords(tileZoom){var wraparound=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;// get the bounds for what tiles are in view
var bounds=getVisibleTileBounds(this,tileZoom,wraparound);// check if no coords are in view
if(!bounds){return[];}// return an array of the coords
var coords=[];for(var x=bounds.left;x<=bounds.right;x++){for(var y=bounds.bottom;y<=bounds.top;y++){coords.push(new TileCoord(tileZoom,x,y));}}return coords;}/**
	 * Returns whether or not the provided coord is within the viewport.
	 *
	 * @param {TileCoord} coord - The coord.
	 * @param {boolean} wraparound - The if the horizontal axis should wraparound. Optional.
	 *
	 * @returns {boolean} Whether or not the coord is in view.
	 */},{key:'isInView',value:function isInView(coord){var wraparound=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;// get the bounds for what tiles are in view
var bounds=getVisibleTileBounds(this,coord.z,wraparound);// check if no coords are in view
if(!bounds){return false;}var dim=Math.pow(2,coord.z);return isWithinRange(bounds.left,bounds.right,dim,coord.x)&&isWithinRange(bounds.bottom,bounds.top,dim,coord.y);}/**
	 * Returns a viewport that has been zoomed around a provided position.
	 *
	 * @param {number} zoom - The current zoom of the viewport.
	 * @param {number} targetZoom - The target zoom of the viewport.
	 * @param {Object} targetPos - The target position to zoom around.
	 *
	 * @returns {Viewport} The new viewport object.
	 */},{key:'zoomToPos',value:function zoomToPos(zoom,targetZoom,targetPos){var scale=Math.pow(2,targetZoom-zoom);var scaledWidth=this.width/scale;var scaledHeight=this.height/scale;var diff={x:(targetPos.x-this.x)/scale,y:(targetPos.y-this.y)/scale};return new Viewport(targetPos.x-diff.x,targetPos.y-diff.y,scaledWidth,scaledHeight);}/**
	 * Returns the lower-left corner position of the viewport in plot
	 * coordinates.
	 *
	 * @returns {Object} The plot position.
	 */},{key:'getPosition',value:function getPosition(){return{x:this.x,y:this.y};}/**
	 * Returns the center of the viewport in plot coordinates.
	 *
	 * @returns {Object} The plot center.
	 */},{key:'getCenter',value:function getCenter(){return{x:this.x+this.width/2,y:this.y+this.height/2};}/**
	 * Returns the viewports size in pixels.
	 *
	 * @param {number} zoom - The zoom of the plot.
	 * @param {number} tileSize - The size of a tile in pixels.
	 *
	 * @returns {Object} The view size in pixels.
	 */},{key:'getPixelSize',value:function getPixelSize(zoom,tileSize){var extent=Math.pow(2,zoom)*tileSize;return{width:Math.round(this.width*extent),height:Math.round(this.height*extent)};}/**
	 * Returns the viewports offset in pixels.
	 *
	 * @param {number} zoom - The zoom of the plot.
	 * @param {number} tileSize - The size of a tile in pixels.
	 *
	 * @returns {Object} The view offset in pixels.
	 */},{key:'getPixelOffset',value:function getPixelOffset(zoom,tileSize){var extent=Math.pow(2,zoom)*tileSize;return{x:this.x*extent,y:this.y*extent};}/**
	 * Centers the viewport on a given plot coordinate.
	 *
	 * @param {Object} pos - The position to center the viewport on.
	 *
	 * @returns {Viewport} The viewport object, for chaining.
	 */},{key:'centerOn',value:function centerOn(pos){this.x=pos.x-this.width/2;this.y=pos.y-this.height/2;}}]);return Viewport;}();module.exports=Viewport;

},{"../geometry/Bounds":146,"../layer/tile/TileCoord":158}],165:[function(require,module,exports){
'use strict';/**
 * Class representing an animation.
 */var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var Animation=function(){/**
	 * Instantiates a new Animation object.
	 *
	 * @param {Object} params - The parameters of the animation.
	 * @param {number} params.plot - The plot target of the animation.
	 * @param {number} params.duration - The duration of the animation.
	 */function Animation(params){_classCallCheck(this,Animation);this.timestamp=Date.now();this.duration=params.duration;this.plot=params.plot;}/**
	 * Returns the t-value of the animation based on the provided timestamp.
	 *
	 * @param {number} timestamp - The frame timestamp.
	 *
	 * @returns {number} The t-value for the corresponding timestamp.
	 */_createClass(Animation,[{key:'getT',value:function getT(timestamp){if(this.duration>0){return Math.min(1.0,(timestamp-this.timestamp)/this.duration);}return 1.0;}/**
	 * Updates the the plot based on the current state of the
	 * animation.
	 *
	 * @param {number} timestamp - The frame timestamp.
	 *
	 * @returns {boolean} Whether or not the animation has finished.
	 *//* eslint-disable no-unused-vars */},{key:'update',value:function update(timestamp){return true;}/**
	 * Cancel the animation and remove it from the plot.
	 */},{key:'cancel',value:function cancel(){}/**
	 * Complete the animation and remove it from the plot.
	 */},{key:'finish',value:function finish(){}}]);return Animation;}();module.exports=Animation;

},{}],166:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var EventType=require('../../event/EventType');var Event=require('../../event/Event');var Animation=require('./Animation');/**
 * Class representing a pan animation.
 */var PanAnimation=function(_Animation){_inherits(PanAnimation,_Animation);/**
	 * Instantiates a new PanAnimation object.
	 *
	 * @param {Object} params - The parameters of the animation.
	 * @param {number} params.plot - The plot target of the animation.
	 * @param {number} params.duration - The duration of the animation.
	 * @param {number} params.start - The start timestamp of the animation.
	 * @param {number} params.delta - The positional delta of the animation.
	 * @param {number} params.easing - The easing factor of the animation.
	 */function PanAnimation(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,PanAnimation);var _this=_possibleConstructorReturn(this,(PanAnimation.__proto__||Object.getPrototypeOf(PanAnimation)).call(this,params));_this.start=params.start;_this.delta=params.delta;_this.end={x:_this.start.x+_this.delta.x,y:_this.start.y+_this.delta.y};_this.easing=params.easing;return _this;}/**
	 * Updates the position of the plot based on the current state of the
	 * animation.
	 *
	 * @param {number} timestamp - The frame timestamp.
	 *
	 * @returns {boolean} Whether or not the animation has finished.
	 */_createClass(PanAnimation,[{key:'update',value:function update(timestamp){var t=this.getT(timestamp);// calculate the progress of the animation
var progress=1-Math.pow(1-t,1/this.easing);// caclulate the current position along the pan
var plot=this.plot;// set the viewport positions
plot.viewport.x=this.start.x+this.delta.x*progress;plot.viewport.y=this.start.y+this.delta.y*progress;// create pan event
var event=new Event(plot);// check if animation is finished
if(t<1){plot.emit(EventType.PAN,event);return false;}plot.emit(EventType.PAN_END,event);return true;}/**
	 * Cancels the current animation and removes it from the plot.
	 */},{key:'cancel',value:function cancel(){var plot=this.plot;// emit pan end
plot.emit(EventType.PAN_END,new Event(plot));}/**
	 * Complete the current animation and remove it from the plot.
	 */},{key:'finish',value:function finish(){var plot=this.plot;// set the viewport positions
plot.viewport.x=this.end.x;plot.viewport.y=this.end.y;// emit pan end
plot.emit(EventType.PAN_END,new Event(plot));}}]);return PanAnimation;}(Animation);module.exports=PanAnimation;

},{"../../event/Event":138,"../../event/EventType":141,"./Animation":165}],167:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var EventType=require('../../event/EventType');var Event=require('../../event/Event');var Animation=require('./Animation');/**
 * Class representing a zoom animation.
 */var ZoomAnimation=function(_Animation){_inherits(ZoomAnimation,_Animation);/**
	 * Instantiates a new ZoomAnimation object.
	 *
	 * @param {Object} params - The parameters of the animation.
	 * @param {number} params.plot - The plot target of the animation.
	 * @param {number} params.duration - The duration of the animation.
	 * @param {number} params.prevZoom - The starting zoom of the animation.
	 * @param {number} params.targetZoom - The target zoom of the animation.
	 * @param {number} params.prevViewport - The starting viewport of the animation.
	 * @param {number} params.targetViewport - The target viewport of the animation.
	 * @param {number} params.targetPos - The target position of the animation, in plot coordinates.
	 */function ZoomAnimation(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,ZoomAnimation);var _this=_possibleConstructorReturn(this,(ZoomAnimation.__proto__||Object.getPrototypeOf(ZoomAnimation)).call(this,params));_this.prevZoom=params.prevZoom;_this.targetZoom=params.targetZoom;_this.prevViewport=params.prevViewport;_this.targetViewport=params.targetViewport;_this.targetPos=params.targetPos;return _this;}/**
	 * Updates the zoom of the plot based on the current state of the
	 * animation.
	 *
	 * @param {number} timestamp - The frame timestamp.
	 *
	 * @returns {boolean} Whether or not the animation has finished.
	 */_createClass(ZoomAnimation,[{key:'update',value:function update(timestamp){var t=this.getT(timestamp);// calc new zoom
var range=this.targetZoom-this.prevZoom;var zoom=this.prevZoom+range*t;var plot=this.plot;// set new zoom
plot.zoom=zoom;// calc new viewport position from prev
plot.viewport=this.prevViewport.zoomToPos(this.prevZoom,plot.zoom,this.targetPos);// create zoom event
var event=new Event(plot);// check if animation is finished
if(t<1){plot.emit(EventType.ZOOM,event);return false;}plot.emit(EventType.ZOOM_END,event);return true;}/**
	 * Cancels the current animation and removes it from the plot.
	 */},{key:'cancel',value:function cancel(){var plot=this.plot;if(!plot.continuousZoom){// round to the closest zoom
plot.zoom=Math.round(plot.zoom);// calc viewport position from prev
plot.viewport=this.prevViewport.zoomToPos(this.prevZoom,plot.zoom,this.targetPos);}// emit zoom end
var event=new Event(plot);plot.emit(EventType.ZOOM_END,event);}/**
	 * Complete the current animation and remove it from the plot.
	 */},{key:'finish',value:function finish(){var plot=this.plot;plot.zoom=this.targetZoom;plot.viewport=this.targetViewport;// emit zoom end
var event=new Event(plot);plot.emit(EventType.ZOOM_END,event);}}]);return ZoomAnimation;}(Animation);module.exports=ZoomAnimation;

},{"../../event/Event":138,"../../event/EventType":141,"./Animation":165}],168:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var EventType=require('../../event/EventType');var MouseEvent=require('../../event/MouseEvent');var DOMHandler=require('./DOMHandler');// Constants
/**
 * Distance in pixels the mouse can be moved before the click event is
 * cancelled.
 * @private
 * @constant {number}
 */var MOVE_TOLERANCE=15;// Private Methods
var createEvent=function createEvent(handler,plot,event){return new MouseEvent(plot,// target
event,// originalEvent
handler.mouseToPlot(event),// pos
handler.mouseToViewPx(event));// px
};/**
 * Class representing a click handler.
 * @private
 */var ClickHandler=function(_DOMHandler){_inherits(ClickHandler,_DOMHandler);/**
	 * Instantiates a new ClickHandler object.
	 *
	 * @param {Plot} plot - The plot to attach the handler to.
	 */function ClickHandler(plot){_classCallCheck(this,ClickHandler);return _possibleConstructorReturn(this,(ClickHandler.__proto__||Object.getPrototypeOf(ClickHandler)).call(this,plot));}/**
	 * Enables the handler.
	 *
	 * @returns {ClickHandler} The handler object, for chaining.
	 */_createClass(ClickHandler,[{key:'enable',value:function enable(){var _this2=this;_get(ClickHandler.prototype.__proto__||Object.getPrototypeOf(ClickHandler.prototype),'enable',this).call(this);var plot=this.plot;var last=null;this.mousedown=function(event){last=_this2.mouseToViewPx(event);};this.mouseup=function(event){if(!last){return;}var pos=_this2.mouseToViewPx(event);var diff={x:last.x-pos.x,y:last.y-pos.y};var distSqrd=diff.x*diff.x+diff.y*diff.y;if(distSqrd<MOVE_TOLERANCE*MOVE_TOLERANCE){// movement was within tolerance, emit click
plot.setDirty();event.preventDefault();_this2.plot.emit(EventType.CLICK,createEvent(_this2,plot,event));}last=null;};this.dblclick=function(event){plot.setDirty();event.preventDefault();_this2.plot.emit(EventType.DBL_CLICK,createEvent(_this2,plot,event));};var container=plot.getContainer();container.addEventListener('mousedown',this.mousedown);container.addEventListener('mouseup',this.mouseup);container.addEventListener('dblclick',this.dblclick);}/**
	 * Disables the handler.
	 *
	 * @returns {ClickHandler} The handler object, for chaining.
	 */},{key:'disable',value:function disable(){_get(ClickHandler.prototype.__proto__||Object.getPrototypeOf(ClickHandler.prototype),'disable',this).call(this);var container=this.plot.getContainer();container.removeEventListener('mousedown',this.mousedown);container.removeEventListener('mouseup',this.mouseup);container.removeEventListener('dblclick',this.dblclick);this.mousedown=null;this.mouseup=null;this.dblclick=null;}}]);return ClickHandler;}(DOMHandler);module.exports=ClickHandler;

},{"../../event/EventType":141,"../../event/MouseEvent":142,"./DOMHandler":169}],169:[function(require,module,exports){
'use strict';/**
 * Class representing a DOM handler.
 * @private
 */var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var DOMHandler=function(){/**
	 * Instantiates a new DOM object.
	 *
	 * @param {Plot} plot - The plot to attach the handler to.
	 */function DOMHandler(plot){_classCallCheck(this,DOMHandler);this.plot=plot;this.enabled=false;}/**
	 * Enables the handler.
	 *
	 * @returns {ZoomHandler} The handler object, for chaining.
	 */_createClass(DOMHandler,[{key:'enable',value:function enable(){if(this.enabled){throw'Handler is already enabled';}this.enable=true;}/**
	 * Disables the handler.
	 *
	 * @returns {ZoomHandler} The handler object, for chaining.
	 */},{key:'disable',value:function disable(){if(this.enabled){throw'Handler is already disabled';}this.enabled=false;}/**
	 * Takes a DOM event and returns the corresponding plot position.
	 * Coordinate [0, 0] is bottom-left of the plot.
	 *
	 * @param {Event} event - The mouse event.
	 *
	 * @returns {Object} The plot position.
	 */},{key:'mouseToPlot',value:function mouseToPlot(event){var plot=this.plot;var extent=plot.getPixelExtent();var size=plot.getViewportPixelSize();return{x:plot.viewport.x+event.clientX/extent,y:plot.viewport.y+(size.height-event.clientY)/extent};}/**
	 * Takes a DOM event and returns the corresponding viewport pixel position.
	 * Coordinate [0, 0] is bottom-left of the viewport.
	 *
	 * @param {Event} event - The mouse event.
	 *
	 * @returns {Object} The viewport pixel coordinate.
	 */},{key:'mouseToViewPx',value:function mouseToViewPx(event){var size=this.plot.getViewportPixelSize();return{x:event.clientX,y:size.height-event.clientY};}/**
	 * Takes a viewport pixel coordinate and returns the corresponding plot
	 * position.
	 * Coordinate [0, 0] is bottom-left of the plot.
	 *
	 * @param {Object} px - The viewport pixel coordinate.
	 *
	 * @returns {Object} The plot position.
	 */},{key:'viewPxToPlot',value:function viewPxToPlot(px){var extent=this.plot.getPixelExtent();return{x:px.x/extent,y:px.y/extent};}/**
	 * Takes a plot position and returns the corresponding viewport pixel
	 * coordinate.
	 * Coordinate [0, 0] is bottom-left of the plot.
	 *
	 * @param {Object} pos - The plot position.
	 *
	 * @returns {Object} The viewport pixel coordinate.
	 */},{key:'plotToViewPx',value:function plotToViewPx(pos){var extent=this.plot.getPixelExtent();return{x:pos.x*extent,y:pos.y*extent};}/**
	 * Takes a DOM event and returns true if the left mouse button is down.
	 *
	 * @param {Event} event - The mouse event.
	 *
	 * @returns {boolean} Whether the left mouse button is down.
	 */},{key:'isLeftButton',value:function isLeftButton(event){return event.which?event.which===1:event.button===0;}/**
	 * Takes a DOM event and returns true if the middle mouse button is down.
	 *
	 * @param {Event} event - The mouse event.
	 *
	 * @returns {boolean} Whether the middle mouse button is down.
	 */},{key:'isMiddleButton',value:function isMiddleButton(event){return event.which?event.which===2:event.button===1;}/**
	 * Takes a DOM event and returns true if the right mouse button is down.
	 *
	 * @param {Event} event - The mouse event.
	 *
	 * @returns {boolean} Whether the right mouse button is down.
	 */},{key:'isRightButton',value:function isRightButton(event){return event.which?event.which===3:event.button===2;}}]);return DOMHandler;}();module.exports=DOMHandler;

},{}],170:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var EventType=require('../../event/EventType');var MouseEvent=require('../../event/MouseEvent');var DOMHandler=require('./DOMHandler');// Private Methods
var createEvent=function createEvent(handler,plot,event){return new MouseEvent(plot,// target
event,// originalEvent
handler.mouseToPlot(event),// pos
handler.mouseToViewPx(event));// px
};/**
 * Class representing a mouse handler.
 * @private
 */var MouseHandler=function(_DOMHandler){_inherits(MouseHandler,_DOMHandler);/**
	 * Instantiates a new MouseHandler object.
	 *
	 * @param {Plot} plot - The plot to attach the handler to.
	 */function MouseHandler(plot){_classCallCheck(this,MouseHandler);return _possibleConstructorReturn(this,(MouseHandler.__proto__||Object.getPrototypeOf(MouseHandler)).call(this,plot));}/**
	 * Enables the handler.
	 *
	 * @returns {MouseHandler} The handler object, for chaining.
	 */_createClass(MouseHandler,[{key:'enable',value:function enable(){var _this2=this;_get(MouseHandler.prototype.__proto__||Object.getPrototypeOf(MouseHandler.prototype),'enable',this).call(this);var plot=this.plot;this.mousedown=function(event){plot.setDirty();event.preventDefault();plot.emit(EventType.MOUSE_DOWN,createEvent(_this2,plot,event));};this.mouseup=function(event){plot.setDirty();event.preventDefault();plot.emit(EventType.MOUSE_UP,createEvent(_this2,plot,event));};this.mousemove=function(event){plot.setDirty();event.preventDefault();plot.emit(EventType.MOUSE_MOVE,createEvent(_this2,plot,event));};this.mouseover=function(event){plot.setDirty();event.preventDefault();plot.emit(EventType.MOUSE_OVER,createEvent(_this2,plot,event));};this.mouseout=function(event){plot.setDirty();event.preventDefault();plot.emit(EventType.MOUSE_OUT,createEvent(_this2,plot,event));};this.wheel=function(event){plot.setDirty();event.preventDefault();};var container=plot.getContainer();container.addEventListener('mousedown',this.mousedown);container.addEventListener('mouseup',this.mouseup);container.addEventListener('mousemove',this.mousemove);container.addEventListener('mouseover',this.mouseover);container.addEventListener('mouseout',this.mouseout);container.addEventListener('wheel',this.wheel);}/**
	 * Disables the handler.
	 *
	 * @returns {MouseHandler} The handler object, for chaining.
	 */},{key:'disable',value:function disable(){_get(MouseHandler.prototype.__proto__||Object.getPrototypeOf(MouseHandler.prototype),'disable',this).call(this);var container=this.plot.getContainer();container.removeEventListener('mousedown',this.mousedown);container.removeEventListener('mouseup',this.mouseup);container.removeEventListener('mousemove',this.mousemove);container.removeEventListener('mouseover',this.mouseover);container.removeEventListener('mouseout',this.mouseout);container.removeEventListener('wheel',this.wheel);this.mousedown=null;this.mouseup=null;this.mousemove=null;this.mouseover=null;this.mouseout=null;this.wheel=null;}}]);return MouseHandler;}(DOMHandler);module.exports=MouseHandler;

},{"../../event/EventType":141,"../../event/MouseEvent":142,"./DOMHandler":169}],171:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var defaultTo=require('lodash/defaultTo');var PanAnimation=require('../animation/PanAnimation');var EventType=require('../../event/EventType');var Event=require('../../event/Event');var DOMHandler=require('./DOMHandler');// Constants
/**
 * Time in milliseconds before a pan point expires.
 * @private
 * @constant {number}
 */var PAN_EXPIRY_MS=50;/**
 * Pan inertia enabled.
 * @private
 * @constant {boolean}
 */var PAN_INTERTIA=true;/**
 * Pan inertia easing.
 * @private
 * @constant {number}
 */var PAN_INTERTIA_EASING=0.2;/**
 * Pan inertia deceleration.
 * @private
 * @constant {number}
 */var PAN_INTERTIA_DECELERATION=3400;/**
 * Pan to animation duration
 * @private
 * @constant {number}
 */var PAN_TO_DURATION=800;// Private Methods
var pan=function pan(plot,delta){if(plot.isZooming()){// no panning while zooming
return;}// update current viewport
plot.viewport.x+=delta.x;plot.viewport.y+=delta.y;// request tiles
plot.panRequest();// emit pan
plot.emit(EventType.PAN,new Event(plot));};/**
 * Class representing a pan handler.
 */var PanHandler=function(_DOMHandler){_inherits(PanHandler,_DOMHandler);/**
	 * Instantiates a new PanHandler object.
	 *
	 * @param {Plot} plot - The plot to attach the handler to.
	 * @param {Object} options - The parameters of the animation.
	 * @param {number} options.inertia - Whether or not pan inertia is enabled.
	 * @param {number} options.inertiaEasing - The inertia easing factor.
	 * @param {number} options.inertiaDeceleration - The inertia deceleration factor.
	 */function PanHandler(plot){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,PanHandler);var _this=_possibleConstructorReturn(this,(PanHandler.__proto__||Object.getPrototypeOf(PanHandler)).call(this,plot));_this.inertia=defaultTo(options.inertia,PAN_INTERTIA);_this.inertiaEasing=defaultTo(options.inertiaEasing,PAN_INTERTIA_EASING);_this.inertiaDeceleration=defaultTo(options.inertiaDeceleration,PAN_INTERTIA_DECELERATION);return _this;}/**
	 * Enables the handler.
	 *
	 * @returns {PanHandler} The handler object, for chaining.
	 */_createClass(PanHandler,[{key:'enable',value:function enable(){var _this2=this;_get(PanHandler.prototype.__proto__||Object.getPrototypeOf(PanHandler.prototype),'enable',this).call(this);var plot=this.plot;var down=false;var lastPos=null;var lastTime=null;var positions=[];var times=[];this.mousedown=function(event){// ignore if right-button
if(!_this2.isLeftButton(event)){return;}// flag as down
down=true;// set position and timestamp
lastPos=_this2.mouseToViewPx(event);lastTime=Date.now();if(_this2.inertia){// clear existing pan animation
plot.panAnimation=null;// reset position and time arrays
positions=[];times=[];}};this.mousemove=function(event){if(down){// get latest position and timestamp
var pos=_this2.mouseToViewPx(event);var time=Date.now();if(positions.length===0){// emit pan start
plot.emit(EventType.PAN_START,new Event(plot));}if(_this2.inertia){// add to position and time arrays
positions.push(pos);times.push(time);// prevent array from getting too big
if(time-times[0]>PAN_EXPIRY_MS){positions.shift();times.shift();}}// calculate the positional delta
var delta={x:lastPos.x-pos.x,y:lastPos.y-pos.y};// pan the plot
pan(plot,_this2.viewPxToPlot(delta));// update last position and time
lastTime=time;lastPos=pos;}};this.mouseup=function(event){// flag as up
down=false;if(plot.isZooming()){// no panning while zooming
return;}// ignore if right-button
if(!_this2.isLeftButton(event)){return;}// ignore if no drag occurred
if(positions.length===0){return;}if(!_this2.inertia){// exit early if no inertia or no movement
plot.emit(EventType.PAN_END,new Event(plot));return;}// get timestamp
var time=Date.now();// strip any positions that are too old
while(time-times[0]>PAN_EXPIRY_MS){positions.shift();times.shift();}if(times.length<2){// exit early if no remaining valid positions
plot.emit(EventType.PAN_END,new Event(plot));return;}// shorthand
var deceleration=_this2.inertiaDeceleration;var easing=_this2.inertiaEasing;// calculate direction from earliest to latest
var direction={x:lastPos.x-positions[0].x,y:lastPos.y-positions[0].y};// calculate the time difference
var diff=(lastTime-times[0]||1)/1000;// ms to s
// calculate velocity
var velocity={x:direction.x*(easing/diff),y:direction.y*(easing/diff)};// calculate speed
var speed=Math.sqrt(velocity.x*velocity.x+velocity.y*velocity.y);// calculate panning duration
var duration=speed/(deceleration*easing);// calculate inertia delta
var delta={x:Math.round(velocity.x*(-duration/2)),y:Math.round(velocity.y*(-duration/2))};// set pan animation
plot.panAnimation=new PanAnimation({plot:plot,start:plot.getViewportPosition(),delta:_this2.viewPxToPlot(delta),easing:easing,duration:duration*1000// s to ms
});};var container=plot.getContainer();container.addEventListener('mousedown',this.mousedown);document.addEventListener('mousemove',this.mousemove);document.addEventListener('mouseup',this.mouseup);}/**
	 * Disables the handler.
	 *
	 * @returns {PanHandler} The handler object, for chaining.
	 */},{key:'disable',value:function disable(){_get(PanHandler.prototype.__proto__||Object.getPrototypeOf(PanHandler.prototype),'disable',this).call(this);var container=this.plot.getContainer();container.removeEventListener('mousedown',this.mousedown);document.removeEventListener('mousemove',this.mousemove);document.removeEventListener('mouseup',this.mouseup);this.mousedown=null;this.mousemove=null;this.mouseup=null;}/**
	 * Pans to the target plot coordinate.
	 *
	 * @param {number} pos - The target plot position.
	 * @param {boolean} animate - Whether or not to animate the pan. Defaults to `true`.
	 */},{key:'panTo',value:function panTo(pos){var animate=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var plot=this.plot;var center=plot.getViewportCenter();var delta={x:pos.x-center.x,y:pos.y-center.y};if(!animate){// do not animate
plot.emit(EventType.PAN_START,new Event(plot));pan(plot,delta);plot.emit(EventType.PAN_END,new Event(plot));}else{// animate pan
plot.emit(EventType.PAN_START,new Event(plot));plot.panAnimation=new PanAnimation({plot:plot,start:plot.getViewportPosition(),delta:delta,easing:this.inertiaEasing,duration:PAN_TO_DURATION});}}}]);return PanHandler;}(DOMHandler);module.exports=PanHandler;

},{"../../event/Event":138,"../../event/EventType":141,"../animation/PanAnimation":166,"./DOMHandler":169,"lodash/defaultTo":109}],172:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var clamp=require('lodash/clamp');var defaultTo=require('lodash/defaultTo');var Browser=require('../../util/Browser');var EventType=require('../../event/EventType');var Event=require('../../event/Event');var ZoomAnimation=require('../animation/ZoomAnimation');var Viewport=require('../Viewport');var DOMHandler=require('./DOMHandler');// Constants
/**
 * Amount of scroll pixels per zoom level.
 * @private
 * @constant {number}
 */var ZOOM_WHEEL_DELTA=300;/**
 * Length of zoom animation in milliseconds.
 * @private
 * @constant {number}
 */var ZOOM_ANIMATION_MS=250;/**
 * Maximum concurrent discrete zooms in a single batch.
 * @private
 * @constant {number}
 */var MAX_CONCURRENT_ZOOMS=4;/**
 * Zoom debounce delay in miliseconds.
 * @private
 * @constant {number}
 */var ZOOM_DEBOUNCE_MS=100;/**
 * Continuous zoom enabled.
 * @private
 * @constant {boolean}
 */var CONTINUOUS_ZOOM=false;// Private Methods
var last=Date.now();var skipInterpolation=function skipInterpolation(animation,delta){// NOTE: attempt to determine if the scroll device is a mouse or a
// trackpad. Mouse scrolling creates large infrequent deltas while
// trackpads create tons of very small deltas. We want to interpolate
// between wheel events, but not between trackpad events.
var now=Date.now();var tdelta=now-last;last=now;if(delta%4.000244140625===0){// definitely a wheel, interpolate
return false;}if(Math.abs(delta)<4){// definitely track pad, do not interpolate
return true;}if(animation&&animation.duration!==0){// current animation has interpolation, should probably interpolate
// the next animation too.
// NOTE: without this, rapid wheel scrolling will trigger the skip
// below
return false;}if(tdelta<40){// events are close enough together that we should probably
// not interpolate
return true;}return false;};var computeZoomDelta=function computeZoomDelta(wheelDelta,continuousZoom,deltaPerZoom,maxZooms){var zoomDelta=wheelDelta/deltaPerZoom;if(!continuousZoom){// snap value if not continuous zoom
if(wheelDelta>0){zoomDelta=Math.ceil(zoomDelta);}else{zoomDelta=Math.floor(zoomDelta);}}// clamp zoom delta to max concurrent zooms
return clamp(zoomDelta,-maxZooms,maxZooms);};var computeTargetZoom=function computeTargetZoom(zoomDelta,currentZoom,currentAnimation,minZoom,maxZoom){var targetZoom=void 0;if(currentAnimation){// append to existing animation target
targetZoom=currentAnimation.targetZoom+zoomDelta;}else{targetZoom=currentZoom+zoomDelta;}// clamp the target zoom to min and max zoom level of plot
return clamp(targetZoom,minZoom,maxZoom);};var zoom=function zoom(plot,targetPos,zoomDelta,duration){// calculate target zoom level
var targetZoom=computeTargetZoom(zoomDelta,plot.zoom,plot.zoomAnimation,plot.minZoom,plot.maxZoom);// check if we need to zoom
if(targetZoom!==plot.getTargetZoom()){// set target viewport
var targetViewport=plot.viewport.zoomToPos(plot.zoom,targetZoom,targetPos);// clear pan animation
plot.panAnimation=null;// if there is a duration
if(duration>0){// set zoom animation
plot.zoomAnimation=new ZoomAnimation({plot:plot,duration:duration,prevZoom:plot.zoom,targetZoom:targetZoom,prevViewport:new Viewport(plot.viewport.x,plot.viewport.y,plot.viewport.width,plot.viewport.height),targetViewport:targetViewport,targetPos:targetPos});}// emit zoom start
plot.emit(EventType.ZOOM_START,new Event(plot));// if there isn't a duration
if(duration===0){// immediately update plot
plot.zoom=targetZoom;plot.viewport=targetViewport;// emit zoom end
plot.emit(EventType.ZOOM_END,new Event(plot));}// request tiles
plot.zoomRequest();}};var zoomFromWheel=function zoomFromWheel(handler,plot,targetPos,wheelDelta,continuousZoom){// no wheel delta, exit early
if(wheelDelta===0){return;}// calculate zoom delta from wheel delta
var zoomDelta=computeZoomDelta(wheelDelta,continuousZoom,handler.deltaPerZoom,handler.maxConcurrentZooms);// get duration
var duration=handler.zoomDuration;if(continuousZoom&&skipInterpolation(plot.zoomAnimation,wheelDelta)){// skip animation interpolation
duration=0;}// process the zoom
zoom(plot,targetPos,zoomDelta,duration);};var getWheelDelta=function getWheelDelta(plot,event){if(event.deltaMode===0){// pixels
if(Browser.firefox){return-event.deltaY/plot.pixelRatio;}return-event.deltaY;}else if(event.deltaMode===1){// lines
return-event.deltaY*20;}// pages
return-event.deltaY*60;};/**
 * Class representing a zoom handler.
 */var ZoomHandler=function(_DOMHandler){_inherits(ZoomHandler,_DOMHandler);/**
	 * Instantiates a new ZoomHandler object.
	 *
	 * @param {Plot} plot - The plot to attach the handler to.
	 * @param {Object} options - The parameters of the animation.
	 * @param {number} options.continuousZoom - Whether or not continuous zoom is enabled.
	 * @param {number} options.zoomDuration - The duration of the zoom animation.
	 * @param {number} options.maxConcurrentZooms - The maximum concurrent zooms in a single batch.
	 * @param {number} options.deltaPerZoom - The scroll delta required per zoom level.
	 * @param {number} options.zoomDebounce - The debounce duration of the zoom in ms.
	 */function ZoomHandler(plot){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,ZoomHandler);var _this=_possibleConstructorReturn(this,(ZoomHandler.__proto__||Object.getPrototypeOf(ZoomHandler)).call(this,plot));_this.continuousZoom=defaultTo(options.continuousZoom,CONTINUOUS_ZOOM);_this.zoomDuration=defaultTo(options.zoomDuration,ZOOM_ANIMATION_MS);_this.maxConcurrentZooms=defaultTo(options.maxConcurrentZooms,MAX_CONCURRENT_ZOOMS);_this.deltaPerZoom=defaultTo(options.deltaPerZoom,ZOOM_WHEEL_DELTA);_this.zoomDebounce=defaultTo(options.zoomDebounce,ZOOM_DEBOUNCE_MS);return _this;}/**
	 * Enables the handler.
	 *
	 * @returns {ZoomHandler} The handler object, for chaining.
	 */_createClass(ZoomHandler,[{key:'enable',value:function enable(){var _this2=this;_get(ZoomHandler.prototype.__proto__||Object.getPrototypeOf(ZoomHandler.prototype),'enable',this).call(this);var plot=this.plot;var wheelDelta=0;var timeout=null;var evt=null;this.dblclick=function(event){// get mouse position
var targetPos=_this2.mouseToPlot(event);// zoom the plot by one level
zoom(plot,targetPos,1,_this2.zoomDuration);};this.wheel=function(event){// get normalized delta
var delta=getWheelDelta(plot,event);if(!_this2.continuousZoom&&Math.abs(delta)<4){// mitigate the hyper sensitivty of a trackpad
return;}// increment wheel delta
wheelDelta+=delta;// check zoom type
if(_this2.continuousZoom){// get target from mouse position
var targetPos=_this2.mouseToPlot(event);// process continuous zoom immediately
zoomFromWheel(_this2,plot,targetPos,wheelDelta,true);// reset wheel delta
wheelDelta=0;}else{// set event
evt=event;// debounce discrete zoom
if(!timeout){timeout=setTimeout(function(){// get target position from mouse position
// NOTE: this is called inside the closure to ensure
// that we use the current viewport of the plot to
// convert from mouse to plot pixels
var targetPos=_this2.mouseToPlot(evt);// process zoom event
zoomFromWheel(_this2,plot,targetPos,wheelDelta,false);// reset wheel delta
wheelDelta=0;// clear timeout
timeout=null;// clear event
evt=null;},_this2.zoomDebounce);}}// prevent default behavior and stop propagationa
event.preventDefault();event.stopPropagation();};var container=plot.getContainer();container.addEventListener('dblclick',this.dblclick);container.addEventListener('wheel',this.wheel);}/**
	 * Disables the handler.
	 *
	 * @returns {ZoomHandler} The handler object, for chaining.
	 */},{key:'disable',value:function disable(){_get(ZoomHandler.prototype.__proto__||Object.getPrototypeOf(ZoomHandler.prototype),'disable',this).call(this);var container=this.plot.getContainer();container.removeEventListener('dblclick',this.dblclick);container.removeEventListener('wheel',this.wheel);this.dblclick=null;this.wheel=null;}/**
	 * Zooms in to the target zoom level. This is bounded by the plot objects
	 * minZoom and maxZoom attributes.
	 *
	 * @param {number} level - The target zoom level.
	 * @param {boolean} animate - Whether or not to animate the zoom. Defaults to `true`.
	 */},{key:'zoomTo',value:function zoomTo(level){var animate=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var plot=this.plot;var targetPos=this.plot.getViewportCenter();var zoomDelta=level-plot.zoom;if(!animate){// do not animate
zoom(plot,targetPos,zoomDelta,0);}else{// animate
zoom(plot,targetPos,zoomDelta,this.zoomDuration);}}}]);return ZoomHandler;}(DOMHandler);module.exports=ZoomHandler;

},{"../../event/Event":138,"../../event/EventType":141,"../../util/Browser":186,"../Viewport":164,"../animation/ZoomAnimation":167,"./DOMHandler":169,"lodash/clamp":107,"lodash/defaultTo":109}],173:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var EventEmitter=require('events');/**
 * Class representing a renderer.
 */var Renderer=function(_EventEmitter){_inherits(Renderer,_EventEmitter);/**
	 * Instantiates a new Renderer object.
	 */function Renderer(){_classCallCheck(this,Renderer);return _possibleConstructorReturn(this,(Renderer.__proto__||Object.getPrototypeOf(Renderer)).call(this));}/**
	 * Executed when the target is attached to a plot.
	 *
	 * @param {target} target - The target to attach the renderer to.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 *//* eslint-disable no-unused-vars */_createClass(Renderer,[{key:'onAdd',value:function onAdd(target){return this;}/**
	 * Executed when the target is removed from a plot.
	 *
	 * @param {Overlay} target - The target to remove the renderer from.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 *//* eslint-disable no-unused-vars */},{key:'onRemove',value:function onRemove(target){return this;}/**
	 * Pick a position of the layer for a collision with any rendered objects.
	 *
	 * @param {Object} pos - The plot position to pick at.
	 *
	 * @returns {Object} The collision, or null.
	 *//* eslint-disable no-unused-vars */},{key:'pick',value:function pick(pos){return null;}/**
	 * Clears any persisted state in the renderer.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 */},{key:'clear',value:function clear(){return this;}/**
	 * The draw function that is executed per frame.
	 *
	 * @param {number} timestamp - The frame timestamp.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 *//* eslint-disable no-unused-vars */},{key:'draw',value:function draw(timestamp){return this;}}]);return Renderer;}(EventEmitter);module.exports=Renderer;

},{"events":2}],174:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Renderer=require('../Renderer');/**
 * Class representing an overlay renderer.
 */var OverlayRenderer=function(_Renderer){_inherits(OverlayRenderer,_Renderer);/**
	 * Instantiates a new OverlayRenderer object.
	 */function OverlayRenderer(){_classCallCheck(this,OverlayRenderer);var _this=_possibleConstructorReturn(this,(OverlayRenderer.__proto__||Object.getPrototypeOf(OverlayRenderer)).call(this));_this.overlay=null;return _this;}/**
	 * Executed when the overlay is attached to a plot.
	 *
	 * @param {Overlay} overlay - The overlay to attach the renderer to.
	 *
	 * @returns {OverlayRenderer} The renderer object, for chaining.
	 */_createClass(OverlayRenderer,[{key:'onAdd',value:function onAdd(overlay){if(!overlay){throw'No overlay provided as argument';}this.overlay=overlay;return this;}/**
	 * Executed when the overlay is removed from a plot.
	 *
	 * @param {Overlay} overlay - The overlay to remove the renderer from.
	 *
	 * @returns {OverlayRenderer} The renderer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(overlay){if(!overlay){throw'No overlay provided as argument';}this.overlay=null;return this;}}]);return OverlayRenderer;}(Renderer);module.exports=OverlayRenderer;

},{"../Renderer":173}],175:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Shader=require('../../webgl/shader/Shader');var EventType=require('../../event/EventType');var OverlayRenderer=require('./OverlayRenderer');// Constants
/**
 * Refresh event handler symbol.
 * @private
 * @constant {Symbol}
 */var REFRESH=Symbol();/**
 * Class representing a webgl overlay renderer.
 */var WebGLOverlayRenderer=function(_OverlayRenderer){_inherits(WebGLOverlayRenderer,_OverlayRenderer);/**
	 * Instantiates a new WebGLOverlayRenderer object.
	 *
	 * @param {Object} options - The overlay options.
	 */function WebGLOverlayRenderer(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,WebGLOverlayRenderer);var _this=_possibleConstructorReturn(this,(WebGLOverlayRenderer.__proto__||Object.getPrototypeOf(WebGLOverlayRenderer)).call(this,options));_this.gl=null;_this[REFRESH]=null;return _this;}/**
	 * Executed when the overlay is attached to a plot.
	 *
	 * @param {Layer} overlay - The overlay to attach the renderer to.
	 *
	 * @returns {WebGLOverlayRenderer} The renderer object, for chaining.
	 */_createClass(WebGLOverlayRenderer,[{key:'onAdd',value:function onAdd(overlay){var _this2=this;_get(WebGLOverlayRenderer.prototype.__proto__||Object.getPrototypeOf(WebGLOverlayRenderer.prototype),'onAdd',this).call(this,overlay);this.gl=this.overlay.plot.getRenderingContext();// create buffers
this.refreshBuffers();// create refresh handler
this[REFRESH]=function(){_this2.refreshBuffers();};// attach refresh handler
this.overlay.on(EventType.REFRESH,this[REFRESH]);return this;}/**
	 * Executed when the overlay is removed from a plot.
	 *
	 * @param {Layer} overlay - The overlay to remove the renderer from.
	 *
	 * @returns {WebGLOverlayRenderer} The renderer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(overlay){// remove refresh handler
this.overlay.removeListener(EventType.REFRESH,this[REFRESH]);// destroy refresh handler
this[REFRESH]=null;this.gl=null;_get(WebGLOverlayRenderer.prototype.__proto__||Object.getPrototypeOf(WebGLOverlayRenderer.prototype),'onRemove',this).call(this,overlay);return this;}/**
	 * Generate any underlying buffers.
	 *
	 * @returns {WebGLOverlayRenderer} The overlay object, for chaining.
	 */},{key:'refreshBuffers',value:function refreshBuffers(){throw'`refreshBuffers` must be overridden';}/**
	 * Instantiate and return a new Shader object using the renderers internal
	 * WebGLRenderingContext.
	 *
	 * @param {Object} source - The shader param object.
	 * @param {string} source.common - Common glsl to be shared by both vertex and fragment shaders.
	 * @param {string} source.vert - The vertex shader glsl.
	 * @param {string} source.frag - The fragment shader glsl.
	 *
	 * @returns {Shader} The shader object.
	 */},{key:'createShader',value:function createShader(source){return new Shader(this.gl,source);}/**
	 * Returns the orthographic projection matrix for the viewport.
	 *
	 * @returns {Float32Array} The orthographic projection matrix.
	 */},{key:'getOrthoMatrix',value:function getOrthoMatrix(){return this.overlay.plot.getOrthoMatrix();}}]);return WebGLOverlayRenderer;}(OverlayRenderer);module.exports=WebGLOverlayRenderer;

},{"../../event/EventType":141,"../../webgl/shader/Shader":192,"./OverlayRenderer":174}],176:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var defaultTo=require('lodash/defaultTo');var VertexBuffer=require('../../../webgl/vertex/VertexBuffer');var WebGLOverlayRenderer=require('../WebGLOverlayRenderer');// Constants
/**
 * Shader GLSL source.
 * @private
 * @constant {Object}
 */var SHADER_GLSL={vert:'\n\t\tprecision highp float;\n\t\tattribute vec2 aPosition;\n\t\tattribute vec2 aNormal;\n\t\tuniform vec2 uViewOffset;\n\t\tuniform float uScale;\n\t\tuniform float uLineWidth;\n\t\tuniform float uPixelRatio;\n\t\tuniform float uPointRadius;\n\t\tuniform mat4 uProjectionMatrix;\n\t\tvoid main() {\n\t\t\tvec2 wPosition = (aPosition * uScale) - uViewOffset;\n\t\t\tgl_Position = uProjectionMatrix * vec4(wPosition, 0.0, 1.0);\n\t\t\tgl_PointSize = uPointRadius * 2.0 * uPixelRatio;\n\t\t}\n\t\t',frag:'\n\t\t#ifdef GL_OES_standard_derivatives\n\t\t\t#extension GL_OES_standard_derivatives : enable\n\t\t#endif\n\t\tprecision highp float;\n\t\tuniform vec4 uPointColor;\n\t\tuniform float uOpacity;\n\t\tvoid main() {\n\t\t\tvec2 cxy = 2.0 * gl_PointCoord - 1.0;\n\t\t\tfloat radius = dot(cxy, cxy);\n\t\t\tfloat alpha = 1.0;\n\t\t\t#ifdef GL_OES_standard_derivatives\n\t\t\t\tfloat delta = fwidth(radius);\n\t\t\t\talpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, radius);\n\t\t\t#else\n\t\t\t\tif (radius > 1.0) {\n\t\t\t\t\tdiscard;\n\t\t\t\t}\n\t\t\t#endif\n\t\t\tgl_FragColor = vec4(uPointColor.rgb, uPointColor.a * alpha * uOpacity);\n\t\t}\n\t\t'};// Private Methods
var bufferPoints=function bufferPoints(points){var buffer=new Float32Array(points.length*2);for(var i=0;i<points.length;i++){var point=points[i];buffer[i*2]=point.x;buffer[i*2+1]=point.y;}return buffer;};var createVertexBuffer=function createVertexBuffer(gl,points){var data=bufferPoints(points);return new VertexBuffer(gl,data,{0:{size:2,type:'FLOAT'}},{mode:'POINTS',count:points.length});};/**
 * Class representing a webgl point overlay renderer.
 */var PointOverlayRenderer=function(_WebGLOverlayRenderer){_inherits(PointOverlayRenderer,_WebGLOverlayRenderer);/**
	 * Instantiates a new PointOverlayRenderer object.
	 *
	 * @param {Object} options - The overlay options.
	 * @param {Array} options.pointColor - The color of the points.
	 * @param {number} options.pointRadius - The pixel radius of the points.
	 */function PointOverlayRenderer(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,PointOverlayRenderer);var _this=_possibleConstructorReturn(this,(PointOverlayRenderer.__proto__||Object.getPrototypeOf(PointOverlayRenderer)).call(this,options));_this.pointColor=defaultTo(options.pointColor,[1.0,0.0,1.0,1.0]);_this.pointRadius=defaultTo(options.pointRadius,4);_this.shader=null;_this.ext=null;_this.points=null;return _this;}/**
	 * Executed when the overlay is attached to a plot.
	 *
	 * @param {Layer} overlay - The overlay to attach the renderer to.
	 *
	 * @returns {PointOverlayRenderer} The renderer object, for chaining.
	 */_createClass(PointOverlayRenderer,[{key:'onAdd',value:function onAdd(overlay){_get(PointOverlayRenderer.prototype.__proto__||Object.getPrototypeOf(PointOverlayRenderer.prototype),'onAdd',this).call(this,overlay);this.ext=this.gl.getExtension('OES_standard_derivatives');this.shader=this.createShader(SHADER_GLSL);return this;}/**
	 * Executed when the overlay is removed from a plot.
	 *
	 * @param {Layer} overlay - The overlay to remove the renderer from.
	 *
	 * @returns {PointOverlayRenderer} The renderer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(overlay){this.shader=null;this.ext=null;this.points=null;_get(PointOverlayRenderer.prototype.__proto__||Object.getPrototypeOf(PointOverlayRenderer.prototype),'onRemove',this).call(this,overlay);return this;}/**
	 * Generate any underlying buffers.
	 *
	 * @returns {PointOverlayRenderer} The overlay object, for chaining.
	 */},{key:'refreshBuffers',value:function refreshBuffers(){// clip points to only those that are inside the cell
var clipped=this.overlay.getClippedGeometry();// generate the buffer
if(clipped&&clipped.length>0){this.points=createVertexBuffer(this.gl,clipped);}else{this.points=null;}}/**
	 * The draw function that is executed per frame.
	 *
	 * @returns {PointOverlayRenderer} The overlay object, for chaining.
	 */},{key:'draw',value:function draw(){if(!this.points){return this;}var gl=this.gl;var shader=this.shader;var points=this.points;var plot=this.overlay.plot;var cell=plot.cell;var proj=this.getOrthoMatrix();var scale=Math.pow(2,plot.zoom-cell.zoom);var opacity=this.overlay.opacity;// get view offset in cell space
var offset=cell.project(plot.viewport,plot.zoom);// set blending func
gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);// bind shader
shader.use();// set global uniforms
shader.setUniform('uProjectionMatrix',proj);shader.setUniform('uViewOffset',[offset.x,offset.y]);shader.setUniform('uScale',scale);shader.setUniform('uPointColor',this.pointColor);shader.setUniform('uPointRadius',this.pointRadius);shader.setUniform('uPixelRatio',plot.pixelRatio);shader.setUniform('uOpacity',opacity);// draw the points
points.bind();points.draw();return this;}}]);return PointOverlayRenderer;}(WebGLOverlayRenderer);module.exports=PointOverlayRenderer;

},{"../../../webgl/vertex/VertexBuffer":199,"../WebGLOverlayRenderer":175,"lodash/defaultTo":109}],177:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var earcut=require('earcut');var defaultTo=require('lodash/defaultTo');var VertexBuffer=require('../../../webgl/vertex/VertexBuffer');var IndexBuffer=require('../../../webgl/vertex/IndexBuffer');var WebGLOverlayRenderer=require('../WebGLOverlayRenderer');// Constants
/**
 * Shader GLSL source.
 * @private
 * @constant {Object}
 */var SHADER_GLSL={vert:'\n\t\tprecision highp float;\n\t\tattribute vec2 aPosition;\n\t\tuniform vec2 uViewOffset;\n\t\tuniform float uScale;\n\t\tuniform mat4 uProjectionMatrix;\n\t\tvoid main() {\n\t\t\tvec2 wPosition = (aPosition * uScale) - uViewOffset;\n\t\t\tgl_Position = uProjectionMatrix * vec4(wPosition, 0.0, 1.0);\n\t\t}\n\t\t',frag:'\n\t\tprecision highp float;\n\t\tuniform vec4 uPolygonColor;\n\t\tuniform float uOpacity;\n\t\tvoid main() {\n\t\t\tgl_FragColor = vec4(uPolygonColor.rgb, uPolygonColor.a * uOpacity);\n\t\t}\n\t\t'};// Private Methods
var getVertexArray=function getVertexArray(points){var vertices=new Float32Array(points.length*2);for(var i=0;i<points.length;i++){vertices[i*2]=points[i].x;vertices[i*2+1]=points[i].y;}return vertices;};var createBuffers=function createBuffers(overlay,points){var vertices=getVertexArray(points);var indices=earcut(vertices);var vertexBuffer=new VertexBuffer(overlay.gl,vertices,{0:{size:2,type:'FLOAT'}});var is16Bit=vertices.length<Math.pow(2,16);var indexBuffer=new IndexBuffer(overlay.gl,is16Bit?new Uint16Array(indices):new Uint32Array(indices),{mode:'TRIANGLES',type:is16Bit?'UNSIGNED_SHORT':'UNSIGNED_INT',count:indices.length});return{vertex:vertexBuffer,index:indexBuffer};};/**
 * Class representing a webgl polyline overlay renderer.
 */var PolygonOverlayRenderer=function(_WebGLOverlayRenderer){_inherits(PolygonOverlayRenderer,_WebGLOverlayRenderer);/**
	 * Instantiates a new PolygonOverlayRenderer object.
	 *
	 * @param {Object} options - The overlay options.
	 * @param {Array} options.polygonColor - The color of the line.
	 */function PolygonOverlayRenderer(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,PolygonOverlayRenderer);var _this=_possibleConstructorReturn(this,(PolygonOverlayRenderer.__proto__||Object.getPrototypeOf(PolygonOverlayRenderer)).call(this,options));_this.polygonColor=defaultTo(options.polygonColor,[1.0,0.4,0.1,0.8]);_this.shader=null;_this.polygons=null;return _this;}/**
	 * Executed when the overlay is attached to a plot.
	 *
	 * @param {Plot} plot - The plot to attach the overlay to.
	 *
	 * @returns {PolygonOverlayRenderer} The overlay object, for chaining.
	 */_createClass(PolygonOverlayRenderer,[{key:'onAdd',value:function onAdd(plot){_get(PolygonOverlayRenderer.prototype.__proto__||Object.getPrototypeOf(PolygonOverlayRenderer.prototype),'onAdd',this).call(this,plot);this.shader=this.createShader(SHADER_GLSL);return this;}/**
	 * Executed when the overlay is removed from a plot.
	 *
	 * @param {Plot} plot - The plot to remove the overlay from.
	 *
	 * @returns {PolygonOverlayRenderer} The overlay object, for chaining.
	 */},{key:'onRemove',value:function onRemove(plot){_get(PolygonOverlayRenderer.prototype.__proto__||Object.getPrototypeOf(PolygonOverlayRenderer.prototype),'onRemove',this).call(this,plot);this.shader=null;return this;}/**
	 * Generate any underlying buffers.
	 *
	 * @returns {PolygonOverlayRenderer} The overlay object, for chaining.
	 */},{key:'refreshBuffers',value:function refreshBuffers(){var _this2=this;var clipped=this.overlay.getClippedGeometry();if(clipped){this.polygons=clipped.map(function(points){// generate the buffer
return createBuffers(_this2,points);});}else{this.polygons=null;}}/**
	 * The draw function that is executed per frame.
	 *
	 * @returns {PolygonOverlayRenderer} The overlay object, for chaining.
	 */},{key:'draw',value:function draw(){if(!this.polygons){return this;}var gl=this.gl;var shader=this.shader;var polygons=this.polygons;var plot=this.overlay.plot;var cell=plot.cell;var proj=this.getOrthoMatrix();var scale=Math.pow(2,plot.zoom-cell.zoom);var opacity=this.overlay.opacity;// get view offset in cell space
var offset=cell.project(plot.viewport,plot.zoom);// set blending func
gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);// bind shader
shader.use();// set global uniforms
shader.setUniform('uProjectionMatrix',proj);shader.setUniform('uViewOffset',[offset.x,offset.y]);shader.setUniform('uScale',scale);shader.setUniform('uPolygonColor',this.polygonColor);shader.setUniform('uOpacity',opacity);// for each polyline buffer
polygons.forEach(function(buffer){// draw the points
buffer.vertex.bind();buffer.index.draw();});return this;}}]);return PolygonOverlayRenderer;}(WebGLOverlayRenderer);module.exports=PolygonOverlayRenderer;

},{"../../../webgl/vertex/IndexBuffer":197,"../../../webgl/vertex/VertexBuffer":199,"../WebGLOverlayRenderer":175,"earcut":1,"lodash/defaultTo":109}],178:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var defaultTo=require('lodash/defaultTo');var VertexBuffer=require('../../../webgl/vertex/VertexBuffer');var WebGLOverlayRenderer=require('../WebGLOverlayRenderer');// Constants
/**
 * Shader GLSL source.
 * @private
 * @constant {Object}
 */var SHADER_GLSL={vert:'\n\t\tprecision highp float;\n\t\tattribute vec2 aPosition;\n\t\tattribute vec2 aNormal;\n\t\tuniform vec2 uViewOffset;\n\t\tuniform float uScale;\n\t\tuniform float uLineWidth;\n\t\tuniform mat4 uProjectionMatrix;\n\t\tvoid main() {\n\t\t\tvec2 wPosition = (aPosition * uScale) - uViewOffset + aNormal * uLineWidth;\n\t\t\tgl_Position = uProjectionMatrix * vec4(wPosition, 0.0, 1.0);\n\t\t}\n\t\t',frag:'\n\t\tprecision highp float;\n\t\tuniform vec4 uLineColor;\n\t\tuniform float uOpacity;\n\t\tvoid main() {\n\t\t\tgl_FragColor = vec4(uLineColor.rgb, uLineColor.a * uOpacity);\n\t\t}\n\t\t'};// Private Methods
// NOTE: smooth / round lines implemented using code modified from:
// http://labs.hyperandroid.com/efficient-webgl-stroking . Instead of baking in
// the positions of the lines, this implementation instead generates the
// positions along the line and stores the tangents, allowing the thickness to
// be arbitrarily scaled outwards independant of scale. In order to prevent
// degeneration of normals due to self-intersections, the triangles are
// generated upon zoom.
var EPSILON=0.000001;var scalarMult=function scalarMult(a,s){return{x:a.x*s,y:a.y*s};};var perpendicular=function perpendicular(a){return{x:-a.y,y:a.x};};var invert=function invert(a){return{x:-a.x,y:-a.y};};var length=function length(a){return Math.sqrt(a.x*a.x+a.y*a.y);};var normalize=function normalize(a){var mod=Math.sqrt(a.x*a.x+a.y*a.y);return{x:a.x/mod,y:a.y/mod};};var add=function add(p0,p1){return{x:p0.x+p1.x,y:p0.y+p1.y};};var sub=function sub(p0,p1){return{x:p0.x-p1.x,y:p0.y-p1.y};};var middle=function middle(p0,p1){return scalarMult(add(p0,p1),0.5);};var equal=function equal(p0,p1){return p0.x===p1.x&&p0.y===p1.y;};var signedArea=function signedArea(p0,p1,p2){return(p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);};var getStrokeGeometry=function getStrokeGeometry(points,strokeWidth){if(points.length<2){throw'A valid polyline must consist of at least 2 points';}var lineWidth=strokeWidth/2;var positions=[];var normals=[];var middlePoints=[];// middle points per each line segment
var closed=false;if(points.length===2){createTriangles(points[0],middle(points[0],points[1]),points[1],positions,normals,lineWidth);}else{if(equal(points[0],points[points.length-1])){var p0=middle(points.shift(),points[0]);points.unshift(p0);points.push(p0);closed=true;}for(var i=0;i<points.length-1;i++){if(i===0){middlePoints.push(points[0]);}else if(i===points.length-2){middlePoints.push(points[points.length-1]);}else{middlePoints.push(middle(points[i],points[i+1]));}}for(var _i=1;_i<middlePoints.length;_i++){createTriangles(middlePoints[_i-1],points[_i],middlePoints[_i],positions,normals,lineWidth);}}if(!closed){// start cap
var _p=points[0];var p1=points[1];var t=perpendicular(sub(p1,_p));createRoundCap(_p,add(_p,t),sub(_p,t),p1,positions,normals);// end cap
_p=points[points.length-1];p1=points[points.length-2];t=perpendicular(sub(p1,_p));createRoundCap(_p,add(_p,t),sub(_p,t),p1,positions,normals);}return{positions:positions,normals:normals};};var createRoundCap=function createRoundCap(center,p0,p1,nextPointInLine,positions,normals){var angle0=Math.atan2(p1.y-center.y,p1.x-center.x);var angle1=Math.atan2(p0.y-center.y,p0.x-center.x);var orgAngle0=angle0;if(angle1>angle0){if(angle1-angle0>=Math.PI-EPSILON){angle1=angle1-2*Math.PI;}}else{if(angle0-angle1>=Math.PI-EPSILON){angle0=angle0-2*Math.PI;}}var angleDiff=angle1-angle0;if(Math.abs(angleDiff)>=Math.PI-EPSILON&&Math.abs(angleDiff)<=Math.PI+EPSILON){var r1=sub(center,nextPointInLine);if(r1.x===0){if(r1.y>0){angleDiff=-angleDiff;}}else if(r1.x>=-EPSILON){angleDiff=-angleDiff;}}var segmentsPerSemi=16;var nsegments=Math.ceil(Math.abs(angleDiff/Math.PI)*segmentsPerSemi);var angleInc=angleDiff/nsegments;var n0={x:0,y:0};for(var i=0;i<nsegments;i++){var n1={x:Math.cos(orgAngle0+angleInc*i),y:Math.sin(orgAngle0+angleInc*i)};var n2={x:Math.cos(orgAngle0+angleInc*(1+i)),y:Math.sin(orgAngle0+angleInc*(1+i))};positions.push(center);positions.push(center);positions.push(center);normals.push(n0);normals.push(n1);normals.push(n2);}};function lineIntersection(p0,p1,p2,p3){var a0=p1.y-p0.y;var b0=p0.x-p1.x;var a1=p3.y-p2.y;var b1=p2.x-p3.x;var det=a0*b1-a1*b0;if(det>-EPSILON&&det<EPSILON){return null;}var c0=a0*p0.x+b0*p0.y;var c1=a1*p2.x+b1*p2.y;var x=(b1*c0-b0*c1)/det;var y=(a0*c1-a1*c0)/det;return{x:x,y:y};}function createTriangles(p0,p1,p2,positions,normals,lineWidth){var t0=sub(p1,p0);var t2=sub(p2,p1);t0=perpendicular(t0);t2=perpendicular(t2);// triangle composed by the 3 points if clockwise or counter-clockwise.
// if counter-clockwise, we must invert the line threshold points, otherwise
// the intersection point could be erroneous and lead to odd results.
if(signedArea(p0,p1,p2)>0){t0=invert(t0);t2=invert(t2);}t0=normalize(t0);t2=normalize(t2);t0=scalarMult(t0,lineWidth);t2=scalarMult(t2,lineWidth);var pintersect=lineIntersection(add(t0,p0),add(t0,p1),add(t2,p2),add(t2,p1));var anchor=null;var anchorLength=Number.MAX_VALUE;var ian=null;if(pintersect){anchor=sub(pintersect,p1);anchorLength=length(anchor);ian=invert(scalarMult(anchor,1.0/lineWidth));}var p0p1=sub(p0,p1);var p0p1Length=length(p0p1);var p1p2=sub(p1,p2);var p1p2Length=length(p1p2);var n0=normalize(t0);var in0=invert(n0);var n2=normalize(t2);var in2=invert(n2);// the cross point exceeds any of the segments dimension.
// do not use cross point as reference.
if(anchorLength>p0p1Length||anchorLength>p1p2Length){positions.push(p0);positions.push(p0);positions.push(p1);normals.push(n0);normals.push(in0);normals.push(n0);positions.push(p0);positions.push(p1);positions.push(p1);normals.push(in0);normals.push(n0);normals.push(in0);createRoundCap(p1,add(p1,t0),add(p1,t2),p2,positions,normals);positions.push(p2);positions.push(p1);positions.push(p1);normals.push(n2);normals.push(in2);normals.push(n2);positions.push(p2);positions.push(p1);positions.push(p2);normals.push(n2);normals.push(in2);normals.push(in2);}else{positions.push(p0);positions.push(p0);positions.push(p1);normals.push(n0);normals.push(in0);normals.push(ian);positions.push(p0);positions.push(p1);positions.push(p1);normals.push(n0);normals.push(ian);normals.push(n0);positions.push(p1);positions.push(p1);positions.push(p1);normals.push(n0);normals.push({x:0,y:0});normals.push(ian);createRoundCap(p1,add(p1,t0),add(p1,t2),sub(p1,anchor),positions,normals);positions.push(p1);positions.push(p1);positions.push(p1);normals.push({x:0,y:0});normals.push(n2);normals.push(ian);positions.push(p2);positions.push(p1);positions.push(p1);normals.push(n2);normals.push(ian);normals.push(n2);positions.push(p2);positions.push(p1);positions.push(p2);normals.push(n2);normals.push(ian);normals.push(in2);}}var bufferPolyline=function bufferPolyline(points,normals){var buffer=new Float32Array(points.length*4);for(var i=0;i<points.length;i++){var point=points[i];var normal=normals[i];buffer[i*4]=point.x;buffer[i*4+1]=point.y;buffer[i*4+2]=normal.x;buffer[i*4+3]=normal.y;}return buffer;};var createVertexBuffer=function createVertexBuffer(overlay,points){var lineWidth=overlay.lineWidth;var geometry=getStrokeGeometry(points,lineWidth);var data=bufferPolyline(geometry.positions,geometry.normals);return new VertexBuffer(overlay.gl,data,{0:{size:2,type:'FLOAT',byteOffset:0},1:{size:2,type:'FLOAT',byteOffset:2*4}},{mode:'TRIANGLES',count:geometry.positions.length});};/**
 * Class representing a webgl polyline overlay renderer.
 */var PolylineOverlayRenderer=function(_WebGLOverlayRenderer){_inherits(PolylineOverlayRenderer,_WebGLOverlayRenderer);/**
	 * Instantiates a new PolylineOverlayRenderer object.
	 *
	 * @param {Object} options - The overlay options.
	 * @param {Array} options.lineColor - The color of the line.
	 * @param {number} options.lineWidth - The pixel width of the line.
	 */function PolylineOverlayRenderer(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,PolylineOverlayRenderer);var _this=_possibleConstructorReturn(this,(PolylineOverlayRenderer.__proto__||Object.getPrototypeOf(PolylineOverlayRenderer)).call(this,options));_this.lineColor=defaultTo(options.lineColor,[1.0,0.4,0.1,0.8]);_this.lineWidth=defaultTo(options.lineWidth,2);_this.shader=null;_this.lines=null;return _this;}/**
	 * Executed when the overlay is attached to a plot.
	 *
	 * @param {Plot} plot - The plot to attach the overlay to.
	 *
	 * @returns {PolylineOverlayRenderer} The overlay object, for chaining.
	 */_createClass(PolylineOverlayRenderer,[{key:'onAdd',value:function onAdd(plot){_get(PolylineOverlayRenderer.prototype.__proto__||Object.getPrototypeOf(PolylineOverlayRenderer.prototype),'onAdd',this).call(this,plot);this.shader=this.createShader(SHADER_GLSL);return this;}/**
	 * Executed when the overlay is removed from a plot.
	 *
	 * @param {Plot} plot - The plot to remove the overlay from.
	 *
	 * @returns {PolylineOverlayRenderer} The overlay object, for chaining.
	 */},{key:'onRemove',value:function onRemove(plot){_get(PolylineOverlayRenderer.prototype.__proto__||Object.getPrototypeOf(PolylineOverlayRenderer.prototype),'onRemove',this).call(this,plot);this.shader=null;return this;}/**
	 * Generate any underlying buffers.
	 *
	 * @returns {PolylineOverlayRenderer} The overlay object, for chaining.
	 */},{key:'refreshBuffers',value:function refreshBuffers(){var _this2=this;var clipped=this.overlay.getClippedGeometry();if(clipped){this.lines=clipped.map(function(points){// generate the buffer
return createVertexBuffer(_this2,points);});}else{this.lines=null;}}/**
	 * The draw function that is executed per frame.
	 *
	 * @returns {PolylineOverlayRenderer} The overlay object, for chaining.
	 */},{key:'draw',value:function draw(){if(!this.lines){return this;}var gl=this.gl;var shader=this.shader;var lines=this.lines;var plot=this.overlay.plot;var cell=plot.cell;var proj=this.getOrthoMatrix();var scale=Math.pow(2,plot.zoom-cell.zoom);var opacity=this.overlay.opacity;// get view offset in cell space
var offset=cell.project(plot.viewport,plot.zoom);// set blending func
gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);// bind shader
shader.use();// set global uniforms
shader.setUniform('uProjectionMatrix',proj);shader.setUniform('uViewOffset',[offset.x,offset.y]);shader.setUniform('uScale',scale);shader.setUniform('uLineWidth',this.lineWidth/2);shader.setUniform('uLineColor',this.lineColor);shader.setUniform('uOpacity',opacity);// for each polyline buffer
lines.forEach(function(buffer){// draw the points
buffer.bind();buffer.draw();});return this;}}]);return PolylineOverlayRenderer;}(WebGLOverlayRenderer);module.exports=PolylineOverlayRenderer;

},{"../../../webgl/vertex/VertexBuffer":199,"../WebGLOverlayRenderer":175,"lodash/defaultTo":109}],179:[function(require,module,exports){
'use strict';// Private Methods
var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var getUVOffset=function getUVOffset(ancestor,descendant){var scale=1/Math.pow(2,descendant.z-ancestor.z);return[descendant.x*scale-ancestor.x,descendant.y*scale-ancestor.y,scale,scale];};/**
 * Class representing a tile renderable.
 */var TileRenderable=function(){/**
	 * Instantiates a new TileRenderable object.
	 *
	 * @param {Tile} tile - The tile data to be rendered.
	 * @param {number} scale - The scale to render the tile at.
	 * @param {Object} tileOffset - The tile pixel offset relative to the viewport.
	 * @param {Array} uvOffset - The texture coordinate offset describing the portion of the tile to render.
	 */function TileRenderable(tile,scale,tileOffset,uvOffset){_classCallCheck(this,TileRenderable);this.tile=tile;this.hash=tile.coord.hash;this.scale=scale;this.tileOffset=tileOffset;this.uvOffset=uvOffset;}/**
	 * Instantiate a TileRenderable object from a specific tile.
	 *
	 * @param {Tile} tile - The tile data to be rendered.
	 * @param {TileCoord} coord - The unnormalized tile coordinate of the tile.
	 * @param {number} scale - The scale to render the tile at.
	 * @param {number} tileSize - The size of the tile in pixels.
	 * @param {number} viewportOffset - The offset of the viewport in pixels.
	 *
	 * @returns {TileRenderable} The renderable object.
	 */_createClass(TileRenderable,[{key:'toCanvas',/**
	 * Converts the `uvOffset` and `tileOffset` parameters to the canvas
	 * coordinate system, with [0, 0] being the top-left corner. The conversion
	 * is done in-place.
	 *
	 * @param {Object} viewport - The pixel dimensions of the viewport.
	 * @param {number} tileSize - The size of each tile in pixels.
	 *
	 * @returns {TileRenderable} The renderable object.
	 */value:function toCanvas(viewport,tileSize){// flip y component of uv offset
var uvOffset=this.uvOffset;uvOffset[1]=1-uvOffset[2]-uvOffset[1];// flip y component of tile offset
var tileOffset=this.tileOffset;tileOffset[1]=viewport.height-tileOffset[1]-tileSize*this.scale;return this;}}],[{key:'fromTile',value:function fromTile(tile,coord,scale,tileSize,viewportOffset){var scaledTileSize=scale*tileSize;var tileOffset=[coord.x*scaledTileSize-viewportOffset.x,coord.y*scaledTileSize-viewportOffset.y];return new TileRenderable(tile,scale,tileOffset,[0,0,1,1]);}/**
	 * Instantiate a TileRenderable object from an ancestor of the tile.
	 *
	 * @param {Tile} tile - The tile data to be rendered.
	 * @param {TileCoord} coord - The unnormalized tile coordinate of the tile.
	 * @param {number} scale - The scale to render the tile at.
	 * @param {number} tileSize - The size of the tile in pixels.
	 * @param {number} viewportOffset - The offset of the viewport in pixels.
	 * @param {TileCoord} wanted - The coordinate the tile will substitue for.
	 * @param {TileCoord} descendant - The direct descendant of the substituted tile.
	 *
	 * @returns {TileRenderable} The renderable object.
	 */},{key:'fromAncestor',value:function fromAncestor(tile,coord,scale,tileSize,viewportOffset,wanted,descendant){var scaledTileSize=scale*tileSize;var tileOffset=[0,0];if(descendant===wanted){// if the "wanted" tile is the same as the "descendant" of this
// ancestor, then there is no positional offset
tileOffset[0]=coord.x*scaledTileSize-viewportOffset.x;tileOffset[1]=coord.y*scaledTileSize-viewportOffset.y;}else{// if the "wanted" tile is not the same as the "descendant", we need
// to position and scale this tile relative to the descendant
var offsetScale=1/Math.pow(2,descendant.z-wanted.z);var offsetX=descendant.x*offsetScale-wanted.x;var offsetY=descendant.y*offsetScale-wanted.y;tileOffset[0]=(coord.x+offsetX)*scaledTileSize-viewportOffset.x;tileOffset[1]=(coord.y+offsetY)*scaledTileSize-viewportOffset.y;scale*=offsetScale;}return new TileRenderable(tile,scale,tileOffset,getUVOffset(tile.coord,descendant));}/**
	 * Instantiate a TileRenderable object from a descendant of the tile.
	 *
	 * @param {Tile} tile - The tile data to be rendered.
	 * @param {TileCoord} coord - The unnormalized tile coordinate of the tile.
	 * @param {number} scale - The scale to render the tile at.
	 * @param {number} tileSize - The size of the tile in pixels.
	 * @param {number} viewportOffset - The offset of the viewport in pixels.
	 * @param {TileCoord} wanted - The coordinate the tile will substitue for.
	 *
	 * @returns {TileRenderable} The renderable object.
	 */},{key:'fromDescendant',value:function fromDescendant(tile,coord,scale,tileSize,viewportOffset,wanted){var scaledTileSize=scale*tileSize;var offsetScale=1/Math.pow(2,tile.coord.z-wanted.z);var offsetX=tile.coord.x*offsetScale-wanted.x;var offsetY=tile.coord.y*offsetScale-wanted.y;var tileOffset=[(coord.x+offsetX)*scaledTileSize-viewportOffset.x,(coord.y+offsetY)*scaledTileSize-viewportOffset.y];return new TileRenderable(tile,scale*offsetScale,tileOffset,[0,0,1,1]);}/**
	 * Instantiate a TileRenderable object from an ancestor of the tile.
	 *
	 * @param {TilePartial} partial - The tile partial to be rendered.
	 * @param {TileCoord} coord - The unnormalized tile coordinate of the tile.
	 * @param {number} scale - The scale to render the tile at.
	 * @param {number} tileSize - The size of the tile in pixels.
	 * @param {number} viewportOffset - The offset of the viewport in pixels.
	 *
	 * @returns {TileRenderable} The renderable object.
	 */},{key:'fromAncestorPartial',value:function fromAncestorPartial(partial,coord,scale,tileSize,viewportOffset){var tile=partial.tile;// tile we have
var target=partial.target;// tile we wanted
var relative=partial.relative;// where to position the tile relative to
var scaledTileSize=scale*tileSize;var tileOffset=[0,0];if(relative===partial.target){// if the "target" tile is the same as the "relative" of this
// ancestor, then there is no positional offset
tileOffset[0]=coord.x*scaledTileSize-viewportOffset.x;tileOffset[1]=coord.y*scaledTileSize-viewportOffset.y;}else{// if the "target" tile is not the same as the "relative", we need
// to position and scale this tile relative to the relative
var offsetScale=1/Math.pow(2,relative.z-target.z);var offsetX=relative.x*offsetScale-target.x;var offsetY=relative.y*offsetScale-target.y;tileOffset[0]=(coord.x+offsetX)*scaledTileSize-viewportOffset.x;tileOffset[1]=(coord.y+offsetY)*scaledTileSize-viewportOffset.y;scale*=offsetScale;}return new TileRenderable(tile,scale,tileOffset,getUVOffset(tile.coord,relative));}/**
	 * Instantiate a TileRenderable object from a descendant of the tile.
	 *
	 * @param {TilePartial} partial - The tile partial to be rendered.
	 * @param {TileCoord} coord - The unnormalized tile coordinate of the tile.
	 * @param {number} scale - The scale to render the tile at.
	 * @param {number} tileSize - The size of the tile in pixels.
	 * @param {number} viewportOffset - The offset of the viewport in pixels.
	 *
	 * @returns {TileRenderable} The renderable object.
	 */},{key:'fromDescendantPartial',value:function fromDescendantPartial(partial,coord,scale,tileSize,viewportOffset){var tile=partial.tile;// tile we have
var target=partial.target;// tile we wanted
var scaledTileSize=scale*tileSize;var offsetScale=1/Math.pow(2,tile.coord.z-target.z);var offsetX=tile.coord.x*offsetScale-target.x;var offsetY=tile.coord.y*offsetScale-target.y;var tileOffset=[(coord.x+offsetX)*scaledTileSize-viewportOffset.x,(coord.y+offsetY)*scaledTileSize-viewportOffset.y];return new TileRenderable(tile,scale*offsetScale,tileOffset,[0,0,1,1]);}}]);return TileRenderable;}();module.exports=TileRenderable;

},{}],180:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var EventType=require('../../event/EventType');var RTreePyramid=require('../../geometry/RTreePyramid');var Renderer=require('../Renderer');var TileRenderable=require('./TileRenderable');// Constants
/**
 * Tile index handler symbol.
 * @private
 * @constant {Symbol}
 */var TILE_INDEX=Symbol();/**
 * Tile unindex handler symbol.
 * @private
 * @constant {Symbol}
 */var TILE_UNINDEX=Symbol();/**
 * Class representing a tile renderer.
 */var TileRenderer=function(_Renderer){_inherits(TileRenderer,_Renderer);/**
	 * Instantiates a new TileRenderer object.
	 */function TileRenderer(){_classCallCheck(this,TileRenderer);var _this=_possibleConstructorReturn(this,(TileRenderer.__proto__||Object.getPrototypeOf(TileRenderer)).call(this));_this[TILE_INDEX]=new Map();_this[TILE_UNINDEX]=new Map();_this.layer=null;return _this;}/**
	 * Executed when the layer is attached to a plot.
	 *
	 * @param {Layer} layer - The layer to attach the renderer to.
	 *
	 * @returns {TileRenderer} The renderer object, for chaining.
	 */_createClass(TileRenderer,[{key:'onAdd',value:function onAdd(layer){if(!layer){throw'No layer provided as argument';}this.layer=layer;return this;}/**
	 * Executed when the layer is removed from a plot.
	 *
	 * @param {Layer} layer - The layer to remove the renderer from.
	 *
	 * @returns {TileRenderer} The renderer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(layer){if(!layer){throw'No layer provided as argument';}this.layer=null;return this;}/**
	 * Creates an rtree pyramid object. Creates and attaches the necessary
	 * event handlers to add and remove data from the rtree accordingly.
	 *
	 * @param {Object} options - The options for the r-tree pyramid.
	 * @param {number} options.nodeCapacity - The node capacity of the rtree.
	 * @param {Function} options.createCollidables - The function to create collidables from a tile.
	 *
	 * @returns {RTreePyramid} The r-tree pyramid object.
	 */},{key:'createRTreePyramid',value:function createRTreePyramid(){var _this2=this;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var createCollidables=options.createCollidables;if(!createCollidables){throw'`options.createCollidables` argument is missing';}// create rtree pyramid
var pyramid=new RTreePyramid({nodeCapacity:options.nodeCapacity});// create handlers
var index=function index(event){var tile=event.tile;var coord=tile.coord;var tileSize=_this2.layer.plot.tileSize;var xOffset=coord.x*tileSize;var yOffset=coord.y*tileSize;var collidables=createCollidables(tile,xOffset,yOffset);pyramid.insert(coord,collidables);};var unindex=function unindex(event){pyramid.remove(event.tile.coord);};// attach handlers
this.layer.on(EventType.TILE_ADD,index);this.layer.on(EventType.TILE_REMOVE,unindex);// store the handlers under the atlas
this[TILE_INDEX].set(pyramid,index);this[TILE_UNINDEX].set(pyramid,unindex);return pyramid;}/**
	 * Destroys a vertex atlas object and removes all event handlers used to add
	 * and remove data from the atlas.
	 *
	 * @param {RTreePyramid} pyramid - The r-tree pyramid object to destroy.
	 */},{key:'destroyRTreePyramid',value:function destroyRTreePyramid(pyramid){// detach handlers
this.layer.removeListener(EventType.TILE_ADD,this[TILE_INDEX].get(pyramid));this.layer.removeListener(EventType.TILE_REMOVE,this[TILE_UNINDEX].get(pyramid));// remove handlers
this[TILE_INDEX].delete(pyramid);this[TILE_UNINDEX].delete(pyramid);}/**
	 * Returns the tile renderables for the underlying layer.
	 *
	 * @returns {Array} The array of tile renderables.
	 */},{key:'getRenderables',value:function getRenderables(){var plot=this.layer.plot;var pyramid=this.layer.pyramid;var tileSize=plot.tileSize;var zoom=plot.zoom;var viewport=plot.getViewportPixelOffset();var coords=plot.getVisibleCoords();var renderables=[];for(var i=0;i<coords.length;i++){var coord=coords[i];var ncoord=coord.normalize();// check if we have the tile
var tile=pyramid.get(ncoord);if(tile){var scale=Math.pow(2,zoom-coord.z);var renderable=TileRenderable.fromTile(tile,coord,scale,tileSize,viewport);renderables.push(renderable);}}return renderables;}/**
	 * Returns the tile renderables for the underlying layer at the closest
	 * available level-of-detail.
	 *
	 * @returns {Array} The array of tile renderables.
	 */},{key:'getRenderablesLOD',value:function getRenderablesLOD(){var plot=this.layer.plot;var pyramid=this.layer.pyramid;var tileSize=plot.tileSize;var zoom=plot.zoom;var viewport=plot.getViewportPixelOffset();var coords=plot.getVisibleCoords();var renderables=[];for(var i=0;i<coords.length;i++){var coord=coords[i];var ncoord=coord.normalize();var scale=Math.pow(2,zoom-coord.z);// check if we have any tile LOD available
var partials=pyramid.getAvailableLOD(ncoord);if(partials){for(var j=0;j<partials.length;j++){var partial=partials[j];var tile=partial.tile;var renderable=void 0;if(tile.coord.z===coord.z){// exact tile
renderable=TileRenderable.fromTile(tile,coord,scale,tileSize,viewport);}else if(tile.coord.z<coord.z){// ancestor of the tile
renderable=TileRenderable.fromAncestorPartial(partial,coord,scale,tileSize,viewport);}else{// descendant of the tile
renderable=TileRenderable.fromDescendantPartial(partial,coord,scale,tileSize,viewport);}renderables.push(renderable);}}}return renderables;}}]);return TileRenderer;}(Renderer);module.exports=TileRenderer;

},{"../../event/EventType":141,"../../geometry/RTreePyramid":149,"../Renderer":173,"./TileRenderable":179}],181:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var defaultTo=require('lodash/defaultTo');var EventType=require('../../event/EventType');var Shader=require('../../webgl/shader/Shader');var TextureArray=require('../../webgl/texture/TextureArray');var VertexAtlas=require('../../webgl/vertex/VertexAtlas');var TileRenderer=require('./TileRenderer');// Constants
/**
 * Tile add handler symbol.
 * @private
 * @constant {Symbol}
 */var TILE_ADD=Symbol();/**
 * Tile remove handler symbol.
 * @private
 * @constant {Symbol}
 */var TILE_REMOVE=Symbol();// Private Methods
var addTileToTextureArray=function addTileToTextureArray(array,tile){array.set(tile.coord.hash,tile.data);};var removeTileFromTextureArray=function removeTileFromTextureArray(array,tile){array.delete(tile.coord.hash);};var addTileToVertexAtlas=function addTileToVertexAtlas(atlas,tile){atlas.set(tile.coord.hash,tile.data,tile.data.length/atlas.stride);};var removeTileFromVertexAtlas=function removeTileFromVertexAtlas(atlas,tile){atlas.delete(tile.coord.hash);};/**
 * Class representing a webgl tile renderer.
 */var WebGLTileRenderer=function(_TileRenderer){_inherits(WebGLTileRenderer,_TileRenderer);/**
	 * Instantiates a new WebGLTileRenderer object.
	 */function WebGLTileRenderer(){_classCallCheck(this,WebGLTileRenderer);var _this=_possibleConstructorReturn(this,(WebGLTileRenderer.__proto__||Object.getPrototypeOf(WebGLTileRenderer)).call(this));_this.gl=null;_this[TILE_ADD]=new Map();_this[TILE_REMOVE]=new Map();return _this;}/**
	 * Executed when the layer is attached to a plot.
	 *
	 * @param {Layer} layer - The layer to attach the renderer to.
	 *
	 * @returns {WebGLTileRenderer} The renderer object, for chaining.
	 */_createClass(WebGLTileRenderer,[{key:'onAdd',value:function onAdd(layer){_get(WebGLTileRenderer.prototype.__proto__||Object.getPrototypeOf(WebGLTileRenderer.prototype),'onAdd',this).call(this,layer);this.gl=this.layer.plot.getRenderingContext();return this;}/**
	 * Executed when the layer is removed from a plot.
	 *
	 * @param {Layer} layer - The layer to remove the renderer from.
	 *
	 * @returns {WebGLRenderer} The renderer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(layer){this.gl=null;_get(WebGLTileRenderer.prototype.__proto__||Object.getPrototypeOf(WebGLTileRenderer.prototype),'onRemove',this).call(this,layer);return this;}/**
	 * Returns the orthographic projection matrix for the viewport.
	 *
	 * @returns {Float32Array} The orthographic projection matrix.
	 */},{key:'getOrthoMatrix',value:function getOrthoMatrix(){return this.layer.plot.getOrthoMatrix();}/**
	 * Instantiate and return a new Shader object using the renderers internal
	 * WebGLRenderingContext.
	 *
	 * @param {Object} source - The shader param object.
	 * @param {string} source.common - Common glsl to be shared by both vertex and fragment shaders.
	 * @param {string} source.vert - The vertex shader glsl.
	 * @param {string} source.frag - The fragment shader glsl.
	 *
	 * @returns {Shader} The shader object.
	 */},{key:'createShader',value:function createShader(source){return new Shader(this.gl,source);}/**
	 * Creates a texture array of appropriate size for the layer pyramid using
	 * the provided texture size. Creates and attaches the necessary event
	 * handlers to add and remove data from the array accordingly.
	 *
	 * @param {Object} options - The options for the texture array.
	 * @param {number} options.chunkSize - The resolution of the tile texture.
	 * @param {string} options.format - The texture pixel format.
	 * @param {string} options.type - The texture pixel component type.
	 * @param {string} options.filter - The min / mag filter used during scaling.
	 * @param {string} options.wrap - The wrapping type over both S and T dimension.
	 * @param {bool} options.invertY - Whether or not invert-y is enabled.
	 * @param {bool} options.premultiplyAlpha - Whether or not alpha premultiplying is enabled.
	 * @param {Function} options.onAdd - The function executed when a tile is added.
	 * @param {Function} options.onRemove - The function executed when a tile is removed.
	 *
	 * @returns {TextureArray} The texture array object.
	 */},{key:'createTextureArray',value:function createTextureArray(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};// create texture array
var array=new TextureArray(this.gl,{// set texture params
format:options.format,type:options.type,filter:options.filter,invertY:options.invertY,premultiplyAlpha:options.premultiplyAlpha},{// set num chunks to be able to fit the capacity of the pyramid
numChunks:this.layer.pyramid.getCapacity(),chunkSize:options.chunkSize});// create handlers
var onAdd=defaultTo(options.onAdd,addTileToTextureArray);var onRemove=defaultTo(options.onRemove,removeTileFromTextureArray);var add=function add(event){onAdd(array,event.tile);};var remove=function remove(event){onRemove(array,event.tile);};// attach handlers
this.layer.on(EventType.TILE_ADD,add);this.layer.on(EventType.TILE_REMOVE,remove);// store the handlers under the array
this[TILE_ADD].set(array,add);this[TILE_REMOVE].set(array,remove);return array;}/**
	 * Destroys a texture array object and removes all event handlers used to
	 * add and remove data from the array.
	 *
	 * @param {TextureArray} array - The texture array to destroy.
	 */},{key:'destroyTextureArray',value:function destroyTextureArray(array){// detach handlers
this.layer.removeListener(EventType.TILE_ADD,this[TILE_ADD].get(array));this.layer.removeListener(EventType.TILE_REMOVE,this[TILE_REMOVE].get(array));// remove handlers
this[TILE_ADD].delete(array);this[TILE_REMOVE].delete(array);}/**
	 * Creates a vertex atlas of appropriate size for the layer pyramid using
	 * the provided attribute pointers. Creates and attaches the necessary
	 * event handlers to add and remove data from the atlas accordingly.
	 *
	 * @param {Object} options - The options for the vertex atlas.
	 * @param {Object} options.attributePointers - The vertex attribute pointers.
	 * @param {number} options.chunkSize - The size of a single chunk, in vertices.
	 * @param {Function} options.onAdd - The function executed when a tile is added.
	 * @param {Function} options.onRemove - The function executed when a tile is removed.
	 *
	 * @returns {VertexAtlas} The vertex atlas object.
	 */},{key:'createVertexAtlas',value:function createVertexAtlas(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};// create vertex atlas
var atlas=new VertexAtlas(this.gl,options.attributePointers,{// set num chunks to be able to fit the capacity of the pyramid
numChunks:this.layer.pyramid.getCapacity(),chunkSize:options.chunkSize});// create handlers
var onAdd=defaultTo(options.onAdd,addTileToVertexAtlas);var onRemove=defaultTo(options.onRemove,removeTileFromVertexAtlas);var add=function add(event){onAdd(atlas,event.tile);};var remove=function remove(event){onRemove(atlas,event.tile);};// attach handlers
this.layer.on(EventType.TILE_ADD,add);this.layer.on(EventType.TILE_REMOVE,remove);// store the handlers under the atlas
this[TILE_ADD].set(atlas,add);this[TILE_REMOVE].set(atlas,remove);return atlas;}/**
	 * Destroys a vertex atlas object and removes all event handlers used to add
	 * and remove data from the atlas.
	 *
	 * @param {VertexAtlas} atlas - The vertex atlas to destroy.
	 */},{key:'destroyVertexAtlas',value:function destroyVertexAtlas(atlas){// detach handlers
this.layer.removeListener(EventType.TILE_ADD,this[TILE_ADD].get(atlas));this.layer.removeListener(EventType.TILE_REMOVE,this[TILE_REMOVE].get(atlas));// remove handlers
this[TILE_ADD].delete(atlas);this[TILE_REMOVE].delete(atlas);}}]);return WebGLTileRenderer;}(TileRenderer);module.exports=WebGLTileRenderer;

},{"../../event/EventType":141,"../../webgl/shader/Shader":192,"../../webgl/texture/TextureArray":196,"../../webgl/vertex/VertexAtlas":198,"./TileRenderer":180,"lodash/defaultTo":109}],182:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var VertexBuffer=require('../../../webgl/vertex/VertexBuffer');var WebGLTileRenderer=require('../WebGLTileRenderer');// Constants
/**
 * Shader GLSL source.
 * @private
 * @constant {Object}
 */var SHADER_GLSL={vert:'\n\t\tprecision highp float;\n\t\tattribute vec2 aPosition;\n\t\tattribute vec2 aTextureCoord;\n\t\tuniform vec4 uTextureCoordOffset;\n\t\tuniform vec2 uTileOffset;\n\t\tuniform float uScale;\n\t\tuniform mat4 uProjectionMatrix;\n\t\tvarying vec2 vTextureCoord;\n\t\tvoid main() {\n\t\t\tvTextureCoord = vec2(\n\t\t\t\tuTextureCoordOffset.x + (aTextureCoord.x * uTextureCoordOffset.z),\n\t\t\t\tuTextureCoordOffset.y + (aTextureCoord.y * uTextureCoordOffset.w));\n\t\t\tvec2 wPosition = (aPosition * uScale) + uTileOffset;\n\t\t\tgl_Position = uProjectionMatrix * vec4(wPosition, 0.0, 1.0);\n\t\t}\n\t\t',frag:'\n\t\tprecision highp float;\n\t\tuniform sampler2D uTextureSampler;\n\t\tuniform float uOpacity;\n\t\tvarying vec2 vTextureCoord;\n\t\tvoid main() {\n\t\t\tvec4 color = texture2D(uTextureSampler, vec2(vTextureCoord.x, 1.0 - vTextureCoord.y));\n\t\t\tgl_FragColor = vec4(color.rgb, color.a * uOpacity);\n\t\t}\n\t\t'};var createQuad=function createQuad(gl,min,max){var vertices=new Float32Array(24);// positions
vertices[0]=min;vertices[1]=min;vertices[2]=max;vertices[3]=min;vertices[4]=max;vertices[5]=max;vertices[6]=min;vertices[7]=min;vertices[8]=max;vertices[9]=max;vertices[10]=min;vertices[11]=max;// uvs
vertices[12]=0;vertices[13]=0;vertices[14]=1;vertices[15]=0;vertices[16]=1;vertices[17]=1;vertices[18]=0;vertices[19]=0;vertices[20]=1;vertices[21]=1;vertices[22]=0;vertices[23]=1;// create quad buffer
return new VertexBuffer(gl,vertices,{0:{size:2,type:'FLOAT',byteOffset:0},1:{size:2,type:'FLOAT',byteOffset:2*6*4}},{count:6});};/**
 * Class representing a webgl image tile renderer.
 */var ImageTileRenderer=function(_WebGLTileRenderer){_inherits(ImageTileRenderer,_WebGLTileRenderer);/**
	 * Instantiates a new ImageTileRenderer object.
	 */function ImageTileRenderer(){_classCallCheck(this,ImageTileRenderer);var _this=_possibleConstructorReturn(this,(ImageTileRenderer.__proto__||Object.getPrototypeOf(ImageTileRenderer)).call(this));_this.quad=null;_this.shader=null;_this.array=null;return _this;}/**
	 * Executed when the layer is attached to a plot.
	 *
	 * @param {Layer} layer - The layer to attach the renderer to.
	 *
	 * @returns {ImageTileRenderer} The renderer object, for chaining.
	 */_createClass(ImageTileRenderer,[{key:'onAdd',value:function onAdd(layer){_get(ImageTileRenderer.prototype.__proto__||Object.getPrototypeOf(ImageTileRenderer.prototype),'onAdd',this).call(this,layer);this.quad=createQuad(this.gl,0,layer.plot.tileSize);this.shader=this.createShader(SHADER_GLSL);this.array=this.createTextureArray({chunkSize:layer.plot.tileSize});return this;}/**
	 * Executed when the layer is removed from a plot.
	 *
	 * @param {Layer} layer - The layer to remove the renderer from.
	 *
	 * @returns {ImageTileRenderer} The renderer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(layer){this.destroyTextureArray(this.array);this.array=null;this.quad=null;this.shader=null;_get(ImageTileRenderer.prototype.__proto__||Object.getPrototypeOf(ImageTileRenderer.prototype),'onRemove',this).call(this,layer);return this;}/**
	 * The draw function that is executed per frame.
	 *
	 * @returns {ImageTileRenderer} The renderer object, for chaining.
	 */},{key:'draw',value:function draw(){var gl=this.gl;var shader=this.shader;var array=this.array;var quad=this.quad;var renderables=this.getRenderablesLOD();var proj=this.getOrthoMatrix();// bind shader
shader.use();// set global uniforms
shader.setUniform('uProjectionMatrix',proj);shader.setUniform('uTextureSampler',0);shader.setUniform('uOpacity',this.layer.opacity);// set blending func
gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);// bind quad
quad.bind();// for each renderable
for(var i=0;i<renderables.length;i++){var renderable=renderables[i];array.bind(renderable.hash,0);// set tile uniforms
shader.setUniform('uTextureCoordOffset',renderable.uvOffset);shader.setUniform('uScale',renderable.scale);shader.setUniform('uTileOffset',renderable.tileOffset);// draw
quad.draw();// no need to unbind texture
}// unbind quad
quad.unbind();return this;}}]);return ImageTileRenderer;}(WebGLTileRenderer);module.exports=ImageTileRenderer;

},{"../../../webgl/vertex/VertexBuffer":199,"../WebGLTileRenderer":181}],183:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var defaultTo=require('lodash/defaultTo');var VertexBuffer=require('../../../webgl/vertex/VertexBuffer');var WebGLTileRenderer=require('../WebGLTileRenderer');// Constants
/**
 * Numver of vertices supported per chunk.
 * @private
 * @constant {number}
 */var CHUNK_SIZE=128*128;/**
 * Inner radius of star.
 * @private
 * @constant {number}
 */var STAR_INNER_RADIUS=0.4;/**
 * Outer radius of star.
 * @private
 * @constant {number}
 */var STAR_OUTER_RADIUS=1.0;/**
 * number of points on the star.
 * @private
 * @constant {number}
 */var STAR_NUM_POINTS=5;/**
 * Shader GLSL source.
 * @private
 * @constant {Object}
 */var SHADER_GLSL={vert:'\n\t\tprecision highp float;\n\t\tattribute vec2 aPosition;\n\t\tattribute vec2 aOffset;\n\t\tattribute float aRadius;\n\t\tuniform vec2 uTileOffset;\n\t\tuniform float uScale;\n\t\tuniform mat4 uProjectionMatrix;\n\t\tvoid main() {\n\t\t\tvec2 wPosition = (aPosition * aRadius) + (aOffset * uScale) + uTileOffset;\n\t\t\tgl_Position = uProjectionMatrix * vec4(wPosition, 0.0, 1.0);\n\t\t}\n\t\t',frag:'\n\t\tprecision highp float;\n\t\tuniform vec4 uColor;\n\t\tvoid main() {\n\t\t\tgl_FragColor = uColor;\n\t\t}\n\t\t'};// Private Methods
var createStar=function createStar(gl){var theta=2*Math.PI/STAR_NUM_POINTS;var htheta=theta/2.0;var qtheta=theta/4.0;var positions=new Float32Array(STAR_NUM_POINTS*2*2+4);positions[0]=0;positions[1]=0;for(var i=0;i<STAR_NUM_POINTS;i++){var angle=i*theta;var sx=Math.cos(angle-qtheta)*STAR_INNER_RADIUS;var sy=Math.sin(angle-qtheta)*STAR_INNER_RADIUS;positions[i*4+2]=sx;positions[i*4+1+2]=sy;sx=Math.cos(angle+htheta-qtheta)*STAR_OUTER_RADIUS;sy=Math.sin(angle+htheta-qtheta)*STAR_OUTER_RADIUS;positions[i*4+2+2]=sx;positions[i*4+3+2]=sy;}positions[positions.length-2]=positions[2];positions[positions.length-1]=positions[3];return new VertexBuffer(gl,positions,{0:{size:2,type:'FLOAT'}},{mode:'TRIANGLE_FAN',count:positions.length/2});};/**
 * Class representing a webgl instanced shape tile renderer.
 */var InstancedTileRenderer=function(_WebGLTileRenderer){_inherits(InstancedTileRenderer,_WebGLTileRenderer);/**
	 * Instantiates a new InstancedTileRenderer object.
	 *
	 * @param {Object} options - The options object.
	 * @param {Array} options.color - The color of the points.
	 */function InstancedTileRenderer(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,InstancedTileRenderer);var _this=_possibleConstructorReturn(this,(InstancedTileRenderer.__proto__||Object.getPrototypeOf(InstancedTileRenderer)).call(this));_this.color=defaultTo(options.color,[1.0,0.4,0.1,0.8]);_this.shape=null;_this.shader=null;_this.atlas=null;return _this;}/**
	 * Executed when the layer is attached to a plot.
	 *
	 * @param {Layer} layer - The layer to attach the renderer to.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 */_createClass(InstancedTileRenderer,[{key:'onAdd',value:function onAdd(layer){_get(InstancedTileRenderer.prototype.__proto__||Object.getPrototypeOf(InstancedTileRenderer.prototype),'onAdd',this).call(this,layer);this.shape=createStar(this.gl);this.shader=this.createShader(SHADER_GLSL);this.atlas=this.createVertexAtlas({chunkSize:CHUNK_SIZE,attributePointers:{// offset
1:{size:2,type:'FLOAT'},// radius
2:{size:1,type:'FLOAT'}}});return this;}/**
	 * Executed when the layer is removed from a plot.
	 *
	 * @param {Layer} layer - The layer to remove the renderer from.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(layer){this.destroyVertexAtlas(this.atlas);this.atlas=null;this.shape=null;this.shader=null;_get(InstancedTileRenderer.prototype.__proto__||Object.getPrototypeOf(InstancedTileRenderer.prototype),'onRemove',this).call(this,layer);return this;}/**
	 * The draw function that is executed per frame.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 */},{key:'draw',value:function draw(){var gl=this.gl;var shader=this.shader;var atlas=this.atlas;var shape=this.shape;var renderables=this.getRenderables();var proj=this.getOrthoMatrix();// set blending func
gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);// bind shader
shader.use();// set global uniforms
shader.setUniform('uProjectionMatrix',proj);shader.setUniform('uColor',this.color);// bind shape
shape.bind();// binds the buffer to instance
atlas.bindInstanced();// for each renderable
for(var i=0;i<renderables.length;i++){var renderable=renderables[i];// set tile uniforms
shader.setUniform('uScale',renderable.scale);shader.setUniform('uTileOffset',renderable.tileOffset);// draw the instances
atlas.drawInstanced(renderable.hash,shape.mode,shape.count);}// unbind
atlas.unbindInstanced();// unbind quad
shape.unbind();return this;}}]);return InstancedTileRenderer;}(WebGLTileRenderer);module.exports=InstancedTileRenderer;

},{"../../../webgl/vertex/VertexBuffer":199,"../WebGLTileRenderer":181,"lodash/defaultTo":109}],184:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var defaultTo=require('lodash/defaultTo');var CircleCollidable=require('../../../geometry/CircleCollidable');var VertexBuffer=require('../../../webgl/vertex/VertexBuffer');var WebGLTileRenderer=require('../WebGLTileRenderer');// Constants
/**
 * Numver of vertices supported per chunk.
 * @private
 * @constant {number}
 */var CHUNK_SIZE=128*128;/**
 * Highlighted point radius increase.
 * @private
 * @constant {number}
 */var HIGHLIGHTED_RADIUS_OFFSET=2;/**
 * Selected point radius increase.
 * @private
 * @constant {number}
 */var SELECTED_RADIUS_OFFSET=4;/**
 * R-Tree node capacity.
 * @private
 * @constant {number}
 */var NODE_CAPACITY=32;/**
 * Shader GLSL source.
 * @private
 * @constant {Object}
 */var SHADER_GLSL={vert:'\n\t\tprecision highp float;\n\t\tattribute vec2 aPosition;\n\t\tattribute float aRadius;\n\t\tuniform float uRadiusOffset;\n\t\tuniform vec2 uTileOffset;\n\t\tuniform float uScale;\n\t\tuniform float uPixelRatio;\n\t\tuniform mat4 uProjectionMatrix;\n\t\tvoid main() {\n\t\t\tvec2 wPosition = (aPosition * uScale) + uTileOffset;\n\t\t\tgl_PointSize = (aRadius + uRadiusOffset) * uScale * 2.0 * uPixelRatio;\n\t\t\tgl_Position = uProjectionMatrix * vec4(wPosition, 0.0, 1.0);\n\t\t}\n\t\t',frag:'\n\t\t#ifdef GL_OES_standard_derivatives\n\t\t\t#extension GL_OES_standard_derivatives : enable\n\t\t#endif\n\t\tprecision highp float;\n\t\tuniform vec4 uColor;\n\t\tvoid main() {\n\t\t\tvec2 cxy = 2.0 * gl_PointCoord - 1.0;\n\t\t\tfloat radius = dot(cxy, cxy);\n\t\t\tfloat alpha = 1.0;\n\t\t\t#ifdef GL_OES_standard_derivatives\n\t\t\t\tfloat delta = fwidth(radius);\n\t\t\t\talpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, radius);\n\t\t\t#else\n\t\t\t\tif (radius > 1.0) {\n\t\t\t\t\tdiscard;\n\t\t\t\t}\n\t\t\t#endif\n\t\t\tgl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\n\t\t}\n\t\t'};// Private Methods
var createPoint=function createPoint(gl){var vertices=new Float32Array(2);vertices[0]=0.0;vertices[1]=0.0;// create quad buffer
return new VertexBuffer(gl,vertices,{0:{size:2,type:'FLOAT'}},{mode:'POINTS',count:1});};var createCollidables=function createCollidables(tile,xOffset,yOffset){var data=tile.data;var collidables=new Array(data.length/3);for(var i=0;i<data.length;i+=3){// add collidable
collidables[i/3]=new CircleCollidable(data[i],// x
data[i+1],// y
data[i+2],// radius
xOffset,yOffset,tile);}return collidables;};var renderTiles=function renderTiles(atlas,shader,renderables,color){// set global uniforms
shader.setUniform('uColor',color);shader.setUniform('uRadiusOffset',0);// binds the buffer to instance
atlas.bind();// for each renderable
for(var i=0;i<renderables.length;i++){var renderable=renderables[i];// set tile uniforms
shader.setUniform('uScale',renderable.scale);shader.setUniform('uTileOffset',renderable.tileOffset);// draw points
atlas.draw(renderable.hash,'POINTS');}// unbind
atlas.unbind();};var renderPoint=function renderPoint(point,shader,plot,target,color,radius){// get tile offset
var coord=target.tile.coord;var scale=Math.pow(2,plot.zoom-coord.z);var viewport=plot.getViewportPixelOffset();var tileOffset=[(coord.x*plot.tileSize+target.x)*scale-viewport.x,(coord.y*plot.tileSize+target.y)*scale-viewport.y];// set uniforms
shader.setUniform('uTileOffset',tileOffset);shader.setUniform('uScale',scale);shader.setUniform('uColor',color);shader.setUniform('uRadiusOffset',radius+target.radius);// binds the buffer to instance
point.bind();// draw the points
point.draw();// unbind
point.unbind();};/**
 * Class representing a webgl interactive point tile renderer.
 */var InteractiveTileRenderer=function(_WebGLTileRenderer){_inherits(InteractiveTileRenderer,_WebGLTileRenderer);/**
	 * Instantiates a new InteractiveTileRenderer object.
	 *
	 * @param {Object} options - The options object.
	 * @param {Array} options.color - The color of the points.
	 */function InteractiveTileRenderer(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,InteractiveTileRenderer);var _this=_possibleConstructorReturn(this,(InteractiveTileRenderer.__proto__||Object.getPrototypeOf(InteractiveTileRenderer)).call(this));_this.color=defaultTo(options.color,[1.0,0.4,0.1,0.8]);_this.shader=null;_this.point=null;_this.tree=null;_this.atlas=null;_this.ext=null;return _this;}/**
	 * Executed when the layer is attached to a plot.
	 *
	 * @param {Layer} layer - The layer to attach the renderer to.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 */_createClass(InteractiveTileRenderer,[{key:'onAdd',value:function onAdd(layer){_get(InteractiveTileRenderer.prototype.__proto__||Object.getPrototypeOf(InteractiveTileRenderer.prototype),'onAdd',this).call(this,layer);// get the extension for standard derivatives
this.ext=this.gl.getExtension('OES_standard_derivatives');this.point=createPoint(this.gl);this.shader=this.createShader(SHADER_GLSL);this.tree=this.createRTreePyramid({nodeCapacity:NODE_CAPACITY,createCollidables:createCollidables});this.atlas=this.createVertexAtlas({chunkSize:CHUNK_SIZE,attributePointers:{// position
0:{size:2,type:'FLOAT'},// radius
1:{size:1,type:'FLOAT'}}});return this;}/**
	 * Executed when the layer is removed from a plot.
	 *
	 * @param {Layer} layer - The layer to remove the renderer from.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(layer){this.destroyVertexAtlas(this.atlas);this.destroyRTreePyramid(this.tree);this.atlas=null;this.shader=null;this.point=null;this.tree=null;this.ext=null;_get(InteractiveTileRenderer.prototype.__proto__||Object.getPrototypeOf(InteractiveTileRenderer.prototype),'onRemove',this).call(this,layer);return this;}/**
	 * Pick a position of the renderer for a collision with any rendered objects.
	 *
	 * @param {Object} pos - The plot position to pick at.
	 *
	 * @returns {Object} The collision, if any.
	 */},{key:'pick',value:function pick(pos){if(this.layer.plot.isZooming()){return null;}return this.tree.searchPoint(pos.x,pos.y,this.layer.plot.zoom,this.layer.plot.getPixelExtent());}/**
	 * The draw function that is executed per frame.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 */},{key:'draw',value:function draw(){var _this2=this;var gl=this.gl;var layer=this.layer;var plot=layer.plot;var projection=this.getOrthoMatrix();var shader=this.shader;// bind render target
plot.renderBuffer.bind();// clear render target
plot.renderBuffer.clear();// set blending func
gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA,gl.ONE);// use shader
shader.use();// set uniforms
shader.setUniform('uProjectionMatrix',projection);shader.setUniform('uPixelRatio',plot.pixelRatio);// render the tiles
renderTiles(this.atlas,shader,this.getRenderables(),this.color);// render selected
layer.getSelected().forEach(function(selected){renderPoint(_this2.point,shader,plot,selected,_this2.color,SELECTED_RADIUS_OFFSET);});// render highlighted
var highlighted=layer.getHighlighted();if(highlighted&&!layer.isSelected(highlighted)){renderPoint(this.point,shader,plot,highlighted,this.color,HIGHLIGHTED_RADIUS_OFFSET);}// unbind render target
plot.renderBuffer.unbind();// render framebuffer to the backbuffer
plot.renderBuffer.blitToScreen(this.layer.opacity);return this;}}]);return InteractiveTileRenderer;}(WebGLTileRenderer);module.exports=InteractiveTileRenderer;

},{"../../../geometry/CircleCollidable":147,"../../../webgl/vertex/VertexBuffer":199,"../WebGLTileRenderer":181,"lodash/defaultTo":109}],185:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var defaultTo=require('lodash/defaultTo');var WebGLTileRenderer=require('../WebGLTileRenderer');// Constants
/**
 * Numver of vertices supported per chunk.
 * @private
 * @constant {number}
 */var CHUNK_SIZE=128*128;/**
 * Shader GLSL source.
 * @private
 * @constant {Object}
 */var SHADER_GLSL={vert:'\n\t\tprecision highp float;\n\t\tattribute vec2 aPosition;\n\t\tattribute float aRadius;\n\t\tuniform vec2 uTileOffset;\n\t\tuniform float uScale;\n\t\tuniform float uPixelRatio;\n\t\tuniform mat4 uProjectionMatrix;\n\t\tvoid main() {\n\t\t\tvec2 wPosition = (aPosition * uScale) + uTileOffset;\n\t\t\tgl_PointSize = aRadius * 2.0 * uPixelRatio;\n\t\t\tgl_Position = uProjectionMatrix * vec4(wPosition, 0.0, 1.0);\n\t\t}\n\t\t',frag:'\n\t\t#ifdef GL_OES_standard_derivatives\n\t\t\t#extension GL_OES_standard_derivatives : enable\n\t\t#endif\n\t\tprecision highp float;\n\t\tuniform vec4 uColor;\n\t\tvoid main() {\n\t\t\tvec2 cxy = 2.0 * gl_PointCoord - 1.0;\n\t\t\tfloat radius = dot(cxy, cxy);\n\t\t\tfloat alpha = 1.0;\n\t\t\t#ifdef GL_OES_standard_derivatives\n\t\t\t\tfloat delta = fwidth(radius);\n\t\t\t\talpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, radius);\n\t\t\t#else\n\t\t\t\tif (radius > 1.0) {\n\t\t\t\t\tdiscard;\n\t\t\t\t}\n\t\t\t#endif\n\t\t\tgl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\n\t\t}\n\t\t'};/**
 * Class representing a webgl point tile renderer.
 */var PointTileRenderer=function(_WebGLTileRenderer){_inherits(PointTileRenderer,_WebGLTileRenderer);/**
	 * Instantiates a new PointTileRenderer object.
	 *
	 * @param {Object} options - The options object.
	 * @param {Array} options.color - The color of the points.
	 */function PointTileRenderer(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,PointTileRenderer);var _this=_possibleConstructorReturn(this,(PointTileRenderer.__proto__||Object.getPrototypeOf(PointTileRenderer)).call(this));_this.color=defaultTo(options.color,[1.0,0.4,0.1,0.8]);_this.shader=null;_this.atlas=null;_this.ext=null;return _this;}/**
	 * Executed when the layer is attached to a plot.
	 *
	 * @param {Layer} layer - The layer to attach the renderer to.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 */_createClass(PointTileRenderer,[{key:'onAdd',value:function onAdd(layer){_get(PointTileRenderer.prototype.__proto__||Object.getPrototypeOf(PointTileRenderer.prototype),'onAdd',this).call(this,layer);// get the extension for standard derivatives
this.ext=this.gl.getExtension('OES_standard_derivatives');this.shader=this.createShader(SHADER_GLSL);this.atlas=this.createVertexAtlas({chunkSize:CHUNK_SIZE,attributePointers:{// position
0:{size:2,type:'FLOAT'},// radius
1:{size:1,type:'FLOAT'}}});return this;}/**
	 * Executed when the layer is removed from a plot.
	 *
	 * @param {Layer} layer - The layer to remove the renderer from.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 */},{key:'onRemove',value:function onRemove(layer){this.destroyVertexAtlas(this.atlas);this.atlas=null;this.shader=null;this.ext=null;_get(PointTileRenderer.prototype.__proto__||Object.getPrototypeOf(PointTileRenderer.prototype),'onRemove',this).call(this,layer);return this;}/**
	 * The draw function that is executed per frame.
	 *
	 * @returns {Renderer} The renderer object, for chaining.
	 */},{key:'draw',value:function draw(){var gl=this.gl;var shader=this.shader;var atlas=this.atlas;var plot=this.layer.plot;var renderables=this.getRenderables();var proj=this.getOrthoMatrix();// bind render target
plot.renderBuffer.bind();// clear render target
plot.renderBuffer.clear();// set blending func
gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA,gl.ONE);// bind shader
shader.use();// set global uniforms
shader.setUniform('uProjectionMatrix',proj);shader.setUniform('uColor',this.color);shader.setUniform('uPixelRatio',plot.pixelRatio);// binds the vertex atlas
atlas.bind();// for each renderable
for(var i=0;i<renderables.length;i++){var renderable=renderables[i];// set tile uniforms
shader.setUniform('uScale',renderable.scale);shader.setUniform('uTileOffset',renderable.tileOffset);// draw the points
atlas.draw(renderable.hash,'POINTS');}// unbind
atlas.unbind();// unbind render target
plot.renderBuffer.unbind();// render framebuffer to the backbuffer
plot.renderBuffer.blitToScreen(this.layer.opacity);return this;}}]);return PointTileRenderer;}(WebGLTileRenderer);module.exports=PointTileRenderer;

},{"../WebGLTileRenderer":181,"lodash/defaultTo":109}],186:[function(require,module,exports){
'use strict';// https://github.com/arasatasaygin/is.js/blob/master/is.js
var userAgent=(navigator&&navigator.userAgent||'').toLowerCase();var vendor=(navigator&&navigator.vendor||'').toLowerCase();/**
 * Test if the browser is firefox.
 *
 * @private
 *
 * @returns {Array} Whether or not the browser is firefox.
 */var isFirefox=function isFirefox(){return userAgent.match(/(?:firefox|fxios)\/(\d+)/);};/**
 * Test if the browser is chrome.
 *
 * @private
 *
 * @returns {Array} Whether or not the browser is chrome.
 */var isChrome=function isChrome(){return /google inc/.test(vendor)?userAgent.match(/(?:chrome|crios)\/(\d+)/):null;};/**
 * Test if the browser is internet explorer.
 *
 * @private
 *
 * @returns {Array} Whether or not the browser is internet explorer.
 */var isIE=function isIE(){return userAgent.match(/(?:msie |trident.+?; rv:)(\d+)/);};/**
 * Test if the browser is edge.
 *
 * @private
 *
 * @returns {Array} Whether or not the browser is edge.
 */var isEdge=function isEdge(){return userAgent.match(/edge\/(\d+)/);};/**
 * Test if the browser is opera.
 *
 * @private
 *
 * @returns {Array} Whether or not the browser is opera.
 */var isOpera=function isOpera(){return userAgent.match(/(?:^opera.+?version|opr)\/(\d+)/);};/**
 * Test if the browser is safari.
 *
 * @private
 *
 * @returns {Array} Whether or not the browser is safari.
 */var isSafari=function isSafari(){return userAgent.match(/version\/(\d+).+?safari/);};/**
 * Browser detection.
 * @private
 */module.exports={/**
	 * Whether or not the browser is firefox.
	 * @constant {boolean}
	 */firefox:!!isFirefox(),/**
	 * Whether or not the browser is chrome.
	 * @constant {boolean}
	 */chrome:!!isChrome(),/**
	 * Whether or not the browser is ie.
	 * @constant {boolean}
	 */ie:!!isIE(),/**
	 * Whether or not the browser is edge.
	 * @constant {boolean}
	 */edge:!!isEdge(),/**
	 * Whether or not the browser is opera.
	 * @constant {boolean}
	 */opera:!!isOpera(),/**
	 * Whether or not the browser is safari.
	 * @constant {boolean}
	 */safari:!!isSafari()};

},{}],187:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var defaultTo=require('lodash/defaultTo');var LinkedList=require('./LinkedList');// Constants
/**
 * Max size symbol.
 * @private
 * @constant {Symbol}
 */var CAPACITY=Symbol();/**
 * Dispose function symbol.
 * @private
 * @constant {Symbol}
 */var ON_REMOVE=Symbol();/**
 * Cache symbol.
 * @private
 * @constant {Symbol}
 */var CACHE=Symbol();/**
 * LRU linked list symbol.
 * @private
 * @constant {Symbol}
 */var LRU_LIST=Symbol();/**
 * LRU length symbol.
 * @private
 * @constant {Symbol}
 */var LENGTH=Symbol();// Private Methods
var del=function del(self,node){if(node){var hit=node.value;if(self[ON_REMOVE]){self[ON_REMOVE](hit.value,hit.key);}self[LENGTH]--;self[CACHE].delete(hit.key);self[LRU_LIST].removeNode(node);}};/**
 * Class representing an LRU cache.
 * @private
 */var LRUCache=function(){/**
	 * Instantiates a new LRUCache object.
	 *
	 * @param {Object} options - The options object.
	 * @param {number} options.capacity - The capacity of the cache.
	 * @param {Function} options.onRemove - A function to execute when a value is evicted.
	 */function LRUCache(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,LRUCache);this[CAPACITY]=defaultTo(Math.max(1,options.capacity),256);this[ON_REMOVE]=defaultTo(options.onRemove,null);this.clear();}/**
	 * Returns the capacity of the cache.
	 *
	 * @returns {number} - The capcity of the cache.
	 */_createClass(LRUCache,[{key:'getCapacity',value:function getCapacity(){return this[CAPACITY];}/**
	 * Returns the length of the cache.
	 *
	 * @returns {number} - The length of the cache.
	 */},{key:'getLength',value:function getLength(){return this[LENGTH];}/**
	 * Iterates over and executes the provided function for all values.
	 * NOTE: Does not update recentness of the entries.
	 *
	 * @param {Function} fn - The function to execute on each value and key.
	 */},{key:'forEach',value:function forEach(fn){for(var node=this[LRU_LIST].head;node!==null;){var next=node.next;fn(node.value.value,node.value.key);node=next;}}/**
	 * Clears all entries in the cache.
	 */},{key:'clear',value:function clear(){var _this=this;if(this[ON_REMOVE]&&this[LRU_LIST]){this[LRU_LIST].forEach(function(hit){_this[ON_REMOVE](hit.value,hit.key);});}this[CACHE]=new Map();this[LRU_LIST]=new LinkedList();this[LENGTH]=0;}/**
	 * Set a value under the provided key, removing the previous entry if one
	 * exists.
	 *
	 * @param {string} key - The key string.
	 * @param {*} value - The value.
	 */},{key:'set',value:function set(key,value){if(this[CACHE].has(key)){// if we already have an entry
var node=this[CACHE].get(key);var item=node.value;// execute onRemove for old value before evicting
if(this[ON_REMOVE]){this[ON_REMOVE](item.value,key);}// set the new value
item.value=value;this.get(key);// no need to trim, since the length remained constant
return;}// add new entry
var hit=new Entry(key,value);this[LENGTH]++;this[LRU_LIST].unshift(hit);this[CACHE].set(key,this[LRU_LIST].head);// trim any old entry
if(this[LENGTH]>this[CAPACITY]){// delete oldest entry
del(this,this[LRU_LIST].tail);}}/**
	 * Returns whether or not the entry is in the LRU cache under the provided
	 * key.
	 * NOTE: Does not update recentness of the entry.
	 *
	 * @param {string} key - The key string.
	 *
	 * @returns {boolean} Whether or not the key exists.
	 */},{key:'has',value:function has(key){if(!this[CACHE].has(key)){return false;}return true;}/**
	 * Returns the entry in the LRU cache under the provided key.
	 * NOTE: Updates the recentness of the entry.
	 *
	 * @param {string} key - The key string.
	 *
	 * @returns {*} The value in the cache.
	 */},{key:'get',value:function get(key){var node=this[CACHE].get(key);if(node){// update recentness
this[LRU_LIST].unshiftNode(node);return node.value.value;}return undefined;}/**
	 * Returns the entry in the LRU cache under the provided key.
	 * NOTE: Does not update recentness of the entry.
	 *
	 * @param {string} key - The key string.
	 *
	 * @returns {*} The value in the cache.
	 */},{key:'peek',value:function peek(key){var node=this[CACHE].get(key);if(node){return node.value.value;}return undefined;}/**
	 * Removes the entry in the LRU cache under the provided key.
	 *
	 * @param {string} key - The key string.
	 */},{key:'delete',value:function _delete(key){del(this,this[CACHE].get(key));}}]);return LRUCache;}();/**
 * Class representing an LRU cache entry.
 * @private
 */var Entry=/**
	 * Instantiates a new Entry object.
	 *
	 * @param {string} key - The entry key.
	 * @param {*} value - The entry value.
	 */function Entry(key,value){_classCallCheck(this,Entry);this.key=key;this.value=value;};module.exports=LRUCache;

},{"./LinkedList":188,"lodash/defaultTo":109}],188:[function(require,module,exports){
'use strict';/**
 * Class representing a linked list.
 * @private
 */var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var LinkedList=function(){/**
	 * Instantiates a new LinkedList object.
	 */function LinkedList(){_classCallCheck(this,LinkedList);this.tail=null;this.head=null;this.length=0;}/**
	 * Push an item to the end of the linked list.
	 *
	 * @param {*} item - The item to add.
	 *
	 * @returns {number} The new length of the list.
	 */_createClass(LinkedList,[{key:'push',value:function push(item){this.tail=new Node(item,this.tail,null,this);if(!this.head){this.head=this.tail;}this.length++;return this.length;}/**
	 * Push an item to the front of the linked list.
	 *
	 * @param {*} item - The item to add.
	 *
	 * @returns {number} The new length of the list.
	 */},{key:'unshift',value:function unshift(item){this.head=new Node(item,null,this.head,this);if(!this.tail){this.tail=this.head;}this.length++;return this.length;}/**
	 * Remove an item front the end of the linked list.
	 *
	 * @returns {*} The removed value.
	 */},{key:'pop',value:function pop(){if(!this.tail){return undefined;}var res=this.tail.value;this.tail=this.tail.prev;if(this.tail){this.tail.next=null;}else{this.head=null;}this.length--;return res;}/**
	 * Remove an item from the front of the linked list.
	 *
	 * @returns {*} The removed value.
	 */},{key:'shift',value:function shift(){if(!this.head){return undefined;}var res=this.head.value;this.head=this.head.next;if(this.head){this.head.prev=null;}else{this.tail=null;}this.length--;return res;}/**
	 * Get an item at a particular index in the list.
	 *
	 * @param {number} n - The index of the element.
	 *
	 * @returns {*} The value.
	 */},{key:'get',value:function get(n){var i=void 0;var node=void 0;for(i=0,node=this.head;node!==null&&i<n;i++){// abort out of the list early if we hit a cycle
node=node.next;}if(i===n&&node!==null){return node.value;}}/**
	 * Iterates over and executes the provided function for all values.
	 *
	 * @param {Function} fn - The function to execute on each value.
	 */},{key:'forEach',value:function forEach(fn){for(var node=this.head,i=0;node!==null;i++){fn(node.value,i);node=node.next;}}/**
	 * Iterates over and executes the provided function for all values returning
	 * an array of all mapped values.
	 *
	 * @param {Function} fn - The function to execute on each tile.
	 *
	 * @returns {Array} The array of mapped values.
	 */},{key:'map',value:function map(fn){var arr=new Array(this.length);for(var i=0,node=this.head;node!==null;i++){arr[i]=fn(node.value,i);node=node.next;}return arr;}/**
	 * Push a node to the end of the linked list.
	 *
	 * @param {Node} node - The node to add.
	 *
	 * @returns {number} The new length of the list.
	 */},{key:'pushNode',value:function pushNode(node){if(node===this.tail){return;}if(node.list){node.list.removeNode(node);}var tail=this.tail;node.list=this;node.prev=tail;if(tail){tail.next=node;}this.tail=node;if(!this.head){this.head=node;}this.length++;return this.length;}/**
	 * Push a node to the front of the linked list.
	 *
	 * @param {Node} node - The node to add.
	 *
	 * @returns {number} The new length of the list.
	 */},{key:'unshiftNode',value:function unshiftNode(node){if(node===this.head){return;}if(node.list){node.list.removeNode(node);}var head=this.head;node.list=this;node.next=head;if(head){head.prev=node;}this.head=node;if(!this.tail){this.tail=node;}this.length++;return this.length;}/**
	 * Remove a node from the linked list.
	 *
	 * @param {Node} node - The node to remove.
	 *
	 * @returns {number} The new length of the list.
	 */},{key:'removeNode',value:function removeNode(node){if(node.list!==this){throw'Removing node which does not belong to this list';}var next=node.next;var prev=node.prev;if(next){next.prev=prev;}if(prev){prev.next=next;}if(node===this.head){this.head=next;}if(node===this.tail){this.tail=prev;}node.list.length--;node.next=null;node.prev=null;node.list=null;return this.length;}}]);return LinkedList;}();/**
 * Class representing a linked list node.
 * @private
 */var Node=/**
	 * Instantiates a new Node object.
	 *
	 * @param {*} value - The value of the node.
	 * @param {Node} prev - The previous node.
	 * @param {Node} next - The next node.
	 * @param {LinkedList} list - The linked list.
	 */function Node(value,prev,next,list){_classCallCheck(this,Node);this.list=list;this.value=value;if(prev){prev.next=this;this.prev=prev;}else{this.prev=null;}if(next){next.prev=this;this.next=next;}else{this.next=null;}};module.exports=LinkedList;

},{}],189:[function(require,module,exports){
'use strict';/**
 * Issues a XHR and loads an ArrayBuffer.
 *
 * @param {string} url - The url.
 * @param {Function} done - The callback.
 */module.exports=function(url,done){var req=new XMLHttpRequest();req.open('GET',url,true);req.responseType='arraybuffer';req.onload=function(){var arraybuffer=req.response;if(arraybuffer){done(null,arraybuffer);}else{var err='Unable to load ArrayBuffer from URL: `'+event.path[0].currentSrc+'`';done(err,null);}};req.onerror=function(event){var err='Unable to load ArrayBuffer from URL: `'+event.path[0].currentSrc+'`';done(err,null);};req.withCredentials=true;req.send(null);};

},{}],190:[function(require,module,exports){
'use strict';/**
 * Issues a XHR and loads an Image.
 *
 * @param {string} url - The url.
 * @param {Function} done - The callback.
 */module.exports=function(url,done){var image=new Image();image.onload=function(){done(null,image);};image.onerror=function(event){var err='Unable to load image from URL: `'+event.path[0].currentSrc+'`';done(err,null);};image.crossOrigin='anonymous';image.src=url;};

},{}],191:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var Texture=require('./texture/Texture');var Shader=require('./shader/Shader');var VertexBuffer=require('./vertex/VertexBuffer');// Constants
/**
 * Shader GLSL source.
 * @private
 * @constant {Object}
 */var SHADER_GLSL={vert:'\n\t\tprecision highp float;\n\t\tattribute vec3 aVertexPosition;\n\t\tattribute vec2 aTextureCoord;\n\t\tvarying vec2 vTextureCoord;\n\t\tvoid main(void) {\n\t\t\tvTextureCoord = aTextureCoord;\n\t\t\tgl_Position = vec4(aVertexPosition, 1.0);\n\t\t}\n\t\t',frag:'\n\t\tprecision highp float;\n\t\tuniform float uOpacity;\n\t\tuniform sampler2D uTextureSampler;\n\t\tvarying vec2 vTextureCoord;\n\t\tvoid main(void) {\n\t\t\tvec4 color = texture2D(uTextureSampler, vTextureCoord);\n\t\t\tgl_FragColor = vec4(color.rgb, color.a * uOpacity);\n\t\t}\n\t\t'};// Private Methods
var createQuad=function createQuad(gl,min,max){var vertices=new Float32Array(24);// positions
vertices[0]=min;vertices[1]=min;vertices[2]=max;vertices[3]=min;vertices[4]=max;vertices[5]=max;vertices[6]=min;vertices[7]=min;vertices[8]=max;vertices[9]=max;vertices[10]=min;vertices[11]=max;// uvs
vertices[12]=0;vertices[13]=0;vertices[14]=1;vertices[15]=0;vertices[16]=1;vertices[17]=1;vertices[18]=0;vertices[19]=0;vertices[20]=1;vertices[21]=1;vertices[22]=0;vertices[23]=1;// create quad buffer
return new VertexBuffer(gl,vertices,{0:{size:2,type:'FLOAT',byteOffset:0},1:{size:2,type:'FLOAT',byteOffset:2*6*4}},{count:6});};var setColorTarget=function setColorTarget(gl,framebuffer,attachment,index){gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer);gl.framebufferTexture2D(gl.FRAMEBUFFER,gl['COLOR_ATTACHMENT'+index],gl.TEXTURE_2D,attachment.texture,0);gl.bindFramebuffer(gl.FRAMEBUFFER,null);};var renderToScreen=function renderToScreen(gl,texture,shader,quad,opacity){// bind shader
shader.use();// set blending func
gl.enable(gl.BLEND);gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);// set uniforms
shader.setUniform('uOpacity',opacity);// set texture sampler unit
shader.setUniform('uTextureSampler',0);// bind texture
texture.bind(0);// draw quad
quad.bind();quad.draw();quad.unbind();};/**
 * Class representing a webgl renderbuffer.
 */var RenderBuffer=function(){/**
	 * Instantiates a RenderBuffer object.
	 *
	 * @param {WebGLRenderingContext} gl - The WebGL context.
	 * @param {number} width - The width of the renderbuffer.
	 * @param {number} height - The height of the renderbuffer.
	 */function RenderBuffer(gl,width,height){_classCallCheck(this,RenderBuffer);this.gl=gl;this.framebuffer=gl.createFramebuffer();this.shader=new Shader(gl,SHADER_GLSL);this.quad=createQuad(gl,-1,1);this.texture=new Texture(gl,null,{width:width,height:height,filter:'NEAREST',invertY:false,premultiplyAlpha:false});setColorTarget(this.gl,this.framebuffer,this.texture,0);}/**
	 * Binds the renderbuffer for writing.
	 *
	 * @returns {RenderBuffer} The renderbuffer object, for chaining.
	 */_createClass(RenderBuffer,[{key:'bind',value:function bind(){var gl=this.gl;gl.bindFramebuffer(gl.FRAMEBUFFER,this.framebuffer);return this;}/**
	 * Unbinds the renderbuffer for writing.
	 *
	 * @returns {RenderBuffer} The renderbuffer object, for chaining.
	 */},{key:'unbind',value:function unbind(){var gl=this.gl;gl.bindFramebuffer(gl.FRAMEBUFFER,null);return this;}/**
	 * Clears the renderbuffer buffer color bits.
	 *
	 * @returns {RenderBuffer} The renderbuffer object, for chaining.
	 */},{key:'clear',value:function clear(){this.gl.clearColor(0,0,0,0);this.gl.clear(this.gl.COLOR_BUFFER_BIT);return this;}/**
	 * Blits the renderbuffer texture to the screen.
	 *
	 * @param {number} opacity - The opacity to blit at.
	 *
	 * @returns {RenderBuffer} The renderbuffer object, for chaining.
	 */},{key:'blitToScreen',value:function blitToScreen(opacity){renderToScreen(this.gl,this.texture,this.shader,this.quad,opacity);return this;}/**
	 * Resizes the renderbuffer to the provided height and width.
	 *
	 * @param {number} width - The new width of the renderbuffer.
	 * @param {number} height - The new height of the renderbuffer.
	 *
	 * @returns {RenderBuffer} The renderbuffer object, for chaining.
	 */},{key:'resize',value:function resize(width,height){this.texture.resize(width,height);return this;}}]);return RenderBuffer;}();module.exports=RenderBuffer;

},{"./shader/Shader":192,"./texture/Texture":195,"./vertex/VertexBuffer":199}],192:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var map=require('lodash/map');var parseShader=require('./parseShader');// Constants
var UNIFORM_FUNCTIONS={'bool':'uniform1i','bool[]':'uniform1iv','float':'uniform1f','float[]':'uniform1fv','int':'uniform1i','int[]':'uniform1iv','uint':'uniform1i','uint[]':'uniform1iv','vec2':'uniform2fv','vec2[]':'uniform2fv','ivec2':'uniform2iv','ivec2[]':'uniform2iv','vec3':'uniform3fv','vec3[]':'uniform3fv','ivec3':'uniform3iv','ivec3[]':'uniform3iv','vec4':'uniform4fv','vec4[]':'uniform4fv','ivec4':'uniform4iv','ivec4[]':'uniform4iv','mat2':'uniformMatrix2fv','mat2[]':'uniformMatrix2fv','mat3':'uniformMatrix3fv','mat3[]':'uniformMatrix3fv','mat4':'uniformMatrix4fv','mat4[]':'uniformMatrix4fv','sampler2D':'uniform1i','samplerCube':'uniform1i'};// Private Methods
var setAttributesAndUniforms=function setAttributesAndUniforms(shader,vertSource,fragSource){// parse shader delcarations
var declarations=parseShader([vertSource,fragSource],['uniform','attribute']);// for each declaration in the shader
declarations.forEach(function(declaration){// check if its an attribute or uniform
if(declaration.qualifier==='attribute'){// if attribute, store type and index
shader.attributes.set(declaration.name,{type:declaration.type,index:shader.attributes.size});}else{// if (declaration.qualifier === 'uniform') {
// if uniform, store type and buffer function name
var type=declaration.type+(declaration.count>1?'[]':'');shader.uniforms.set(declaration.name,{type:declaration.type,func:UNIFORM_FUNCTIONS[type]});}});};var formatLine=function formatLine(str,num){str=str.toString();var diff=num-str.length;str+=':';for(var i=0;i<diff;i++){str+=' ';}return str;};var compileShader=function compileShader(gl,shaderSource,type){var shader=gl.createShader(gl[type]);gl.shaderSource(shader,shaderSource);gl.compileShader(shader);if(!gl.getShaderParameter(shader,gl.COMPILE_STATUS)){var split=shaderSource.split('\n');var maxDigits=split.length.toString().length+1;var srcByLines=split.map(function(line,index){return formatLine(index+1,maxDigits)+' '+line;}).join('\n');var shaderLog=gl.getShaderInfoLog(shader);throw'An error occurred compiling the shader:\n\n'+shaderLog.slice(0,shaderLog.length-1)+'\n'+srcByLines;}return shader;};var bindAttributeLocations=function bindAttributeLocations(shader){var gl=shader.gl;shader.attributes.forEach(function(attribute,name){// bind the attribute location
gl.bindAttribLocation(shader.program,attribute.index,name);});};var getUniformLocations=function getUniformLocations(shader){var gl=shader.gl;var uniforms=shader.uniforms;uniforms.forEach(function(uniform,name){// get the uniform location
var location=gl.getUniformLocation(shader.program,name);// check if null, parse may detect uniform that is compiled out due to
// not being used, or due to a preprocessor evaluation.
if(location===null){uniforms.delete(name);}else{uniform.location=location;}});};var createDefines=function createDefines(defines){return map(defines,function(value,name){return'#define '+name+' '+value;}).join('\n');};var createProgram=function createProgram(shader,sources){// Creates the shader program object from source strings. This includes:
//	1) Compiling and linking the shader program.
//	2) Parsing shader source for attribute and uniform information.
//	3) Binding attribute locations, by order of delcaration.
//	4) Querying and storing uniform location.
var gl=shader.gl;var defines=createDefines(sources.define);var common=defines+(sources.common||'');var vert=common+sources.vert;var frag=common+sources.frag;// compile shaders
var vertexShader=compileShader(gl,vert,'VERTEX_SHADER');var fragmentShader=compileShader(gl,frag,'FRAGMENT_SHADER');// parse source for attribute and uniforms
setAttributesAndUniforms(shader,vert,frag);// create the shader program
shader.program=gl.createProgram();// attach vertex and fragment shaders
gl.attachShader(shader.program,vertexShader);gl.attachShader(shader.program,fragmentShader);// bind vertex attribute locations BEFORE linking
bindAttributeLocations(shader);// link shader
gl.linkProgram(shader.program);// If creating the shader program failed, alert
if(!gl.getProgramParameter(shader.program,gl.LINK_STATUS)){throw'An error occured linking the shader:\n'+gl.getProgramInfoLog(shader.program);}// get shader uniform locations
getUniformLocations(shader);};/**
 * Class representing a shader program.
 */var Shader=function(){/**
	 * Instantiates a Shader object.
	 *
	 * @param {WebGLRenderingContext} gl - The WebGL context.
	 * @param {Object} params - The shader params object.
	 * @param {string} params.common - Common glsl to be shared by both vertex and fragment shaders.
	 * @param {string} params.vert - The vertex shader glsl.
	 * @param {string} params.frag - The fragment shader glsl.
	 * @param {Object} params.define - Any #define directives to include in the glsl.
	 */function Shader(gl){var params=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Shader);// check source arguments
if(!params.vert){throw'Vertex shader argument `vert` has not been provided';}if(!params.frag){throw'Fragment shader argument `frag` has not been provided';}this.gl=gl;this.program=null;this.attributes=new Map();this.uniforms=new Map();// create the shader program
createProgram(this,params);}/**
	 * Binds the shader program for use.
	 *
	 * @returns {Shader} The shader object, for chaining.
	 */_createClass(Shader,[{key:'use',value:function use(){// use the shader
this.gl.useProgram(this.program);return this;}/**
	 * Buffer a uniform value by name.
	 *
	 * @param {string} name - The uniform name in the shader source.
	 * @param {*} value - The uniform value to buffer.
	 *
	 * @returns {Shader} The shader object, for chaining.
	 */},{key:'setUniform',value:function setUniform(name,value){var uniform=this.uniforms.get(name);// ensure that the uniform params exists for the name
if(!uniform){throw'No uniform found under name `'+name+'`';}// check value
if(value===undefined||value===null){// ensure that the uniform argument is defined
throw'Value passed for uniform `'+name+'` is undefined or null';}// set the uniform
// NOTE: checking type by string comparison is faster than wrapping
// the functions.
if(uniform.type==='mat2'||uniform.type==='mat3'||uniform.type==='mat4'){this.gl[uniform.func](uniform.location,false,value);}else{this.gl[uniform.func](uniform.location,value);}return this;}}]);return Shader;}();module.exports=Shader;

},{"./parseShader":193,"lodash/map":127}],193:[function(require,module,exports){
'use strict';var preprocess=require('./preprocess');// Constants
var COMMENTS_REGEXP=/(\/\*([\s\S]*?)\*\/)|(\/\/(.*)$)/gm;var ENDLINE_REGEXP=/(\r\n|\n|\r)/gm;var WHITESPACE_REGEXP=/\s{2,}/g;var BRACKET_WHITESPACE_REGEXP=/(\s*)(\[)(\s*)(\d+)(\s*)(\])(\s*)/g;var NAME_COUNT_REGEXP=/([a-zA-Z_][a-zA-Z0-9_]*)(?:\[(\d+)\])?/;var PRECISION_REGEX=/\bprecision\s+\w+\s+\w+;/g;var INLINE_PRECISION_REGEX=/\b(highp|mediump|lowp)\s+/g;// Private Methods
var stripComments=function stripComments(str){// regex source: https://github.com/moagrius/stripcomments
return str.replace(COMMENTS_REGEXP,'');};var stripPrecision=function stripPrecision(str){return str.replace(PRECISION_REGEX,'')// remove global precision declarations
.replace(INLINE_PRECISION_REGEX,'');// remove inline precision declarations
};var normalizeWhitespace=function normalizeWhitespace(str){return str.replace(ENDLINE_REGEXP,' ')// normalize line endings
.replace(WHITESPACE_REGEXP,' ')// normalize whitespace to single ' '
.replace(BRACKET_WHITESPACE_REGEXP,'$2$4$6');// remove whitespace in brackets
};var parseNameAndCount=function parseNameAndCount(qualifier,type,entry){// determine name and size of variable
var matches=entry.match(NAME_COUNT_REGEXP);var name=matches[1];var count=matches[2]===undefined?1:parseInt(matches[2],10);return{qualifier:qualifier,type:type,name:name,count:count};};var parseStatement=function parseStatement(statement){// split statement on commas
//
// ['uniform mat4 A[10]', 'B', 'C[2]']
//
var split=statement.split(',').map(function(elem){return elem.trim();});// split declaration header from statement
//
// ['uniform', 'mat4', 'A[10]']
//
var header=split.shift().split(' ');// qualifier is always first element
//
// 'uniform'
//
var qualifier=header.shift();// type will be the second element
//
// 'mat4'
//
var type=header.shift();// last part of header will be the first, and possible only variable name
//
// ['A[10]', 'B', 'C[2]']
//
var names=header.concat(split);// if there are other names after a ',' add them as well
return names.map(function(name){return parseNameAndCount(qualifier,type,name);});};var parseSource=function parseSource(source,keywords){// splits the source string by semi-colons and constructs an array of
// declaration objects based on the provided qualifier keywords.
// get individual statements (any sequence ending in ;)
var statements=source.split(';');// build regex for parsing statements with targetted keywords
var keywordStr=keywords.join('|');var keywordRegex=new RegExp('\\b('+keywordStr+')\\b.*');// parse and store global precision statements and any declarations
var matched=[];// for each statement
statements.forEach(function(statement){// check for keywords
//
// ['uniform float uTime']
//
var kmatch=statement.match(keywordRegex);if(kmatch){// parse statement and add to array
matched=matched.concat(parseStatement(kmatch[0]));}});return matched;};var filterDuplicatesByName=function filterDuplicatesByName(declarations){// in cases where the same declarations are present in multiple
// sources, this function will remove duplicates from the results
var seen={};return declarations.filter(function(declaration){if(seen[declaration.name]){return false;}seen[declaration.name]=true;return true;});};/**
 * Parses the provided GLSL source, and returns all declaration statements that
 * contain the provided qualifier types. This can be used to extract the
 * attributes and uniform names / types from a shader.
 * NOTE: This is run only AFTER compilation succeed, so it assumes VALID syntax.
 *
 * Ex, when provided a 'uniform' qualifier, the declaration:
 *
 *    'uniform highp vec3 uSpecularColor;'
 *
 * Would be parsed to:
 *    {
 *        qualifier: 'uniform',
 *        type: 'vec3'
 *        name: 'uSpecularColor',
 *        count: 1
 *    }
 *
 * @private
 * @param {Array} sources - The shader glsl sources.
 * @param {Array} qualifiers - The qualifiers to extract.
 *
 * @returns {Array} The array of qualifier declaration statements.
 */module.exports=function(){var sources=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var qualifiers=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];// if no sources or qualifiers are provided, return empty array
if(sources.length===0||qualifiers.length===0){return[];}sources=Array.isArray(sources)?sources:[sources];qualifiers=Array.isArray(qualifiers)?qualifiers:[qualifiers];// parse out targetted declarations
var declarations=[];sources.forEach(function(source){// remove comments
source=stripComments(source);// run preprocessor
source=preprocess(source);// remove precision statements
source=stripPrecision(source);// finally, normalize the whitespace
source=normalizeWhitespace(source);// parse out declarations
declarations=declarations.concat(parseSource(source,qualifiers));});// remove duplicates and return
return filterDuplicatesByName(declarations);};

},{"./preprocess":194}],194:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var DEFINED='__DEFINED__';var DEFINE_REGEX=/#define\b/i;var UNDEF_REGEX=/#undef\b/i;var IF_REGEX=/#if\b/i;var IFDEF_REGEX=/#ifdef\b/i;var IFNDEF_REGEX=/#ifndef\b/i;var ELSE_REGEX=/#else\b/i;var ELIF_REGEX=/#elif\b/i;var ENDIF_REGEX=/#endif\b/i;var PARSE_DEFINE_REGEX=/#define\s+(\w+)(\s(\w*)?)?/i;var PARSE_UNDEF_REGEX=/#undef\s+(\w+)/i;var PARSE_IF_REGEX=/#if\s+\(?\s*(!?\s*\w+)\s*(==|!=|>=|<=|<|>)?\s*(\w*)\s*\)?/i;var PARSE_IFDEF_REGEX=/#ifdef\s+(\w+)/i;var PARSE_IFNDEF_REGEX=/#ifndef\s+(\w+)/i;var PARSE_ELIF_REGEX=/#elif\s+\(?\s*(!?\s*\w+)\s*(==|!=|>=|<=|<|>)?\s*(\w*)\s*\)?/i;var REMAINING_REGEX=/#([\W\w\s\d])(?:.*\\r?\n)*.*$/gm;var evalIf=function evalIf(a,logic,b){if(logic===undefined){if(a[0]==='!'){return!(a==='true'||a>=1);}return a==='true'||a>=1;}switch(logic){case'==':return a===b;case'!=':return a!==b;case'>':return a>b;case'>=':return a>=b;case'<':return a<b;case'<=':return a<=b;}throw'Unrecognized logical operator `'+logic+'`';};var Conditional=function(){function Conditional(type,conditional){_classCallCheck(this,Conditional);this.type=type;this.conditional=conditional.trim();this.body=[];this.children=[];}_createClass(Conditional,[{key:'eval',value:function _eval(){var parsed=void 0;switch(this.type){case'if':parsed=PARSE_IF_REGEX.exec(this.conditional);return evalIf(parsed[1],parsed[2],parsed[3]);case'ifdef':parsed=PARSE_IFDEF_REGEX.exec(this.conditional);return parsed[1]===DEFINED;case'ifndef':parsed=PARSE_IFNDEF_REGEX.exec(this.conditional);return parsed[1]!==DEFINED;case'elif':parsed=PARSE_ELIF_REGEX.exec(this.conditional);return evalIf(parsed[1],parsed[2],parsed[3]);}throw'Unrecognized conditional type `'+this.type+'`';}}]);return Conditional;}();var Block=function(){function Block(type,conditional,lineNum){_classCallCheck(this,Block);this.if=new Conditional(type,conditional);this.elif=[];this.else=null;this.parent=null;this.current=this.if;this.startLine=lineNum;this.endLine=null;}_createClass(Block,[{key:'addElse',value:function addElse(conditional){this.current=new Conditional('else',conditional);this.else=this.current;}},{key:'addElif',value:function addElif(conditional){this.current=new Conditional('elif',conditional);this.elif.push(this.current);}},{key:'addBody',value:function addBody(line,lineNum){this.current.body.push({string:line.trim(),line:lineNum});}},{key:'nest',value:function nest(block){block.parent=this;this.current.children.push(block);}},{key:'extract',value:function extract(){// #if
var body=[];if(this.if.eval()){body=body.concat(this.if.body);this.if.children.forEach(function(child){body=body.concat(child.extract());});return body;}// #elif
for(var i=0;i<this.elif.length;i++){var elif=this.elif[i];if(elif.eval()){body=body.concat(elif.body);for(var j=0;j<elif.children.length;j++){var child=elif.children[j];body=body.concat(child.extract());}return body;}}// #else
if(this.else){body=body.concat(this.else.body);this.else.children.forEach(function(child){body=body.concat(child.extract());});return body;}return[];}},{key:'eval',value:function _eval(){// ensure extract text is ordered correctly
return this.extract().sort(function(a,b){return a.line-b.line;}).map(function(arg){return arg.string;}).join('\n');}}]);return Block;}();var parseLines=function parseLines(lines){var blocks=[];var current=null;lines.forEach(function(line,index){if(line.match(IF_REGEX)){// #if
var block=new Block('if',line,index);if(!current){blocks.push(block);}else{current.nest(block);}current=block;}else if(line.match(IFDEF_REGEX)){// #ifdef
var _block=new Block('ifdef',line,index);if(!current){blocks.push(_block);}else{current.nest(_block);}current=_block;}else if(line.match(IFNDEF_REGEX)){// #ifndef
var _block2=new Block('ifndef',line,index);if(!current){blocks.push(_block2);}else{current.nest(_block2);}current=_block2;}else if(line.match(ELIF_REGEX)){// #elif
if(!current){throw'Invalid preprocessor syntax, unexpected `#elif`';}current.addElif(line);}else if(line.match(ELSE_REGEX)){// #else
if(!current){throw'Invalid preprocessor syntax, unexpected `#else`';}current.addElse(line);}else if(line.match(ENDIF_REGEX)){// #endif
if(!current){throw'Invalid preprocessor syntax, unexpected `#endif`';}current.endLine=index;current=current.parent;}else{// other
if(current){current.addBody(line,index);}}});if(current){throw'Invalid preprocessor syntax, missing expected `#endif`';}return blocks;};var replaceDefines=function replaceDefines(lines){var defines=new Map();var replaced=[];lines.forEach(function(line){if(line.match(DEFINE_REGEX)){// #define
var parsed=PARSE_DEFINE_REGEX.exec(line);defines.set(parsed[1],parsed[2]||DEFINED);}else if(line.match(UNDEF_REGEX)){// #undef
var _parsed=PARSE_UNDEF_REGEX.exec(line);defines.delete(_parsed[1]);}else if(line.match(IFDEF_REGEX)){// #ifdef
var _parsed2=PARSE_IFDEF_REGEX.exec(line);if(defines.has(_parsed2[1])){line=line.replace(_parsed2[1],DEFINED);}replaced.push(line);}else if(line.match(IFNDEF_REGEX)){// #ifndef
var _parsed3=PARSE_IFNDEF_REGEX.exec(line);if(defines.has(_parsed3[1])){line=line.replace(_parsed3[1],DEFINED);}replaced.push(line);}else{// swap defines
defines.forEach(function(val,define){line=line.replace(define,val);});replaced.push(line);}});return replaced;};/**
 * Evaluates GLSL preprocessor statements.
 * NOTE: assumes comments have been stripped, and preprocessors are valid.
 *
 *     Supported:
 *
 *         #define (substitutions only)
 *         #undef
 *         #if (== and != comparisons only)
 *         #ifdef
 *         #ifndef
 *         #elif
 *         #else
 *         #endif
 *
 *     Not Supported:
 *
 *         #define (macros)
 *         #if (&& and || operators, defined() predicate)
 *         #error
 *         #pragma
 *         #extension
 *         #version
 *         #line
 *
 * @private
 * @param {string} glsl - The glsl source code.
 *
 * @returns {string} The processed glsl source code.
 */module.exports=function(glsl){// split lines
var lines=glsl.split('\n');// replace any defines with their values
lines=replaceDefines(lines);// parse them
var blocks=parseLines(lines);// remove blocks in reverse order to preserve line numbers
for(var i=blocks.length-1;i>=0;i--){var block=blocks[i];var replacement=block.eval();if(replacement.length>0){lines.splice(block.startLine,block.endLine-block.startLine+1,replacement);}else{lines.splice(block.startLine,block.endLine-block.startLine+1);}}// strip remaining unsupported preprocessor statements
return lines.join('\n').replace(REMAINING_REGEX,'');};

},{}],195:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var defaultTo=require('lodash/defaultTo');/**
 * Class representing a texture.
 */var Texture=function(){/**
	 * Instantiates a Texture object.
	 *
	 * @param {WebGLRenderingContext} gl - The WebGL context.
	 * @param {ArrayBuffer|CanvasElement} src - The data to buffer.
	 * @param {Object} options - The texture options.
	 * @param {number} options.width - The width of the texture.
	 * @param {number} options.height - The height of the texture.
	 * @param {string} options.format - The texture pixel format.
	 * @param {string} options.type - The texture pixel component type.
	 * @param {string} options.filter - The min / mag filter used during scaling.
	 * @param {string} options.wrap - The wrapping type over both S and T dimension.
	 * @param {bool} options.invertY - Whether or not invert-y is enabled.
	 * @param {bool} options.premultiplyAlpha - Whether or not alpha premultiplying is enabled.
	 */function Texture(gl){var src=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};_classCallCheck(this,Texture);this.gl=gl;this.texture=gl.createTexture();// set texture properties
this.format=defaultTo(options.format,'RGBA');this.type=defaultTo(options.type,'UNSIGNED_BYTE');this.filter=defaultTo(options.filter,'LINEAR');this.wrap=defaultTo(options.wrap,'CLAMP_TO_EDGE');this.invertY=defaultTo(options.invertY,false);this.premultiplyAlpha=defaultTo(options.premultiplyAlpha,false);// buffer the data
this.bufferData(src,options.width,options.height);// set parameters
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl[this.wrap]);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl[this.wrap]);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl[this.filter]);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl[this.filter]);}/**
	 * Binds the texture object to the provided texture unit location.
	 *
	 * @param {number} location - The texture unit location index. Optional.
	 *
	 * @returns {Texture} The texture object, for chaining.
	 */_createClass(Texture,[{key:'bind',value:function bind(){var location=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var gl=this.gl;gl.activeTexture(gl['TEXTURE'+location]);gl.bindTexture(gl.TEXTURE_2D,this.texture);return this;}/**
	 * Unbinds the texture object.
	 *
	 * @returns {Texture} The texture object, for chaining.
	 */},{key:'unbind',value:function unbind(){var gl=this.gl;gl.bindTexture(gl.TEXTURE_2D,null);return this;}/**
	 * Buffer data into the texture.
	 *
	 * @param {Array|ArrayBufferView|null} data - The data array to buffer.
	 * @param {number} width - The width of the data.
	 * @param {number} height - The height of the data.
	 *
	 * @returns {Texture} The texture object, for chaining.
	 */},{key:'bufferData',value:function bufferData(data,width,height){var gl=this.gl;// bind texture
gl.bindTexture(gl.TEXTURE_2D,this.texture);gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,this.invertY);gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,this.premultiplyAlpha);// buffer the data
if(data&&data.width&&data.height){// store width and height
this.width=data.width;this.height=data.height;// buffer the texture
gl.texImage2D(gl.TEXTURE_2D,0,// mip-map level
gl[this.format],// webgl requires format === internalFormat
gl[this.format],gl[this.type],data);}else{// store width and height
this.width=width||this.width;this.height=height||this.height;// buffer the texture data
gl.texImage2D(gl.TEXTURE_2D,0,// mip-map level
gl[this.format],// webgl requires format === internalFormat
this.width,this.height,0,// border, must be 0
gl[this.format],gl[this.type],data);}return this;}/**
	 * Buffer partial data into the texture.
	 *
	 * @param {Array|ArrayBufferView|null} data - The data array to buffer.
	 * @param {number} xOffset - The x offset at which to buffer.
	 * @param {number} yOffset - The y offset at which to buffer.
	 * @param {number} width - The width of the data.
	 * @param {number} height - The height of the data.
	 *
	 * @returns {Texture} The texture object, for chaining.
	 */},{key:'bufferSubData',value:function bufferSubData(data){var xOffset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var yOffset=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var width=arguments.length>3&&arguments[3]!==undefined?arguments[3]:undefined;var height=arguments.length>4&&arguments[4]!==undefined?arguments[4]:undefined;var gl=this.gl;// bind texture
gl.bindTexture(gl.TEXTURE_2D,this.texture);gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,this.invertY);gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,this.premultiplyAlpha);// buffer the data
if(data.width&&data.height){// buffer the texture
gl.texSubImage2D(gl.TEXTURE_2D,0,// mip-map level
xOffset,yOffset,gl[this.format],gl[this.type],data);}else{// buffer the texture data
gl.texSubImage2D(gl.TEXTURE_2D,0,// mip-map level
xOffset,yOffset,width,height,gl[this.format],gl[this.type],data);}return this;}/**
	 * Resize the underlying texture. This clears the texture data.
	 *
	 * @param {number} width - The new width of the texture.
	 * @param {number} height - The new height of the texture.
	 *
	 * @returns {Texture} The texture object, for chaining.
	 */},{key:'resize',value:function resize(width,height){this.bufferData(null,width,height);return this;}}]);return Texture;}();module.exports=Texture;

},{"lodash/defaultTo":109}],196:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var defaultTo=require('lodash/defaultTo');// Private Methods
var createTexture=function createTexture(gl,format,size,type,filter,wrap,invertY,premultiplyAlpha){var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,invertY);gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,premultiplyAlpha);// buffer the data
gl.texImage2D(gl.TEXTURE_2D,0,// mip-map level
gl[format],// webgl requires format === internalFormat
size,size,0,// border, must be 0
gl[format],gl[type],null);// set parameters
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl[wrap]);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl[wrap]);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl[filter]);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl[filter]);return texture;};/**
 * Class representing a texture array.
 */var TextureArray=function(){/**
	 * Instantiates a new TextureArray object.
	 *
	 * NOTE: we use a texture array rather than a texture atlas because of
	 * the sub-pixel bleeding that occurs in the atlas when textures are
	 * not padded. Due to the overhead of padding clientside, the
	 * frequency of load load events, and the average number of tiles on
	 * the screen at any one time, binding individual tile textures
	 * provides a less volatile frame rate compared to padding textures and
	 * using an atlas.
	 *
	 * @param {WebGLRenderingContext} gl - The WebGL context.
	 * @param {Object} params - The texture parameters.
	 * @param {string} params.format - The texture pixel format.
	 * @param {string} params.type - The texture pixel component type.
	 * @param {string} params.filter - The min / mag filter used during scaling.
	 * @param {string} params.wrap - The wrapping type over both S and T dimension.
	 * @param {bool} params.invertY - Whether or not invert-y is enabled.
	 * @param {bool} params.premultiplyAlpha - Whether or not alpha premultiplying is enabled.
	 * @param {Object} options - The texture array options.
	 * @param {number} options.chunkSize - The dimension of each texture, in pixels.
	 * @param {number} options.numChunks - The size of the array, in tiles.
	 */function TextureArray(gl){var params=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};_classCallCheck(this,TextureArray);this.gl=gl;// set array properties
this.chunkSize=defaultTo(options.chunkSize,256);this.numChunks=defaultTo(options.numChunks,256);// set texture parameters
this.format=defaultTo(params.format,'RGBA');this.type=defaultTo(params.type,'UNSIGNED_BYTE');this.filter=defaultTo(params.filter,'LINEAR');this.wrap=defaultTo(params.wrap,'CLAMP_TO_EDGE');this.invertY=defaultTo(params.invertY,false);this.premultiplyAlpha=defaultTo(params.premultiplyAlpha,false);// create textures
this.available=new Array(this.numChunks);for(var i=0;i<this.numChunks;i++){this.available[i]={texture:createTexture(this.gl,this.format,this.chunkSize,this.type,this.filter,this.wrap,this.invertY,this.premultiplyAlpha)};}// create used chunk map
this.used=new Map();}/**
	 * Test whether or not a key is held in the array.
	 *
	 * @param {string} key - The key to test.
	 *
	 * @returns {boolean} Whether or not the coord exists in the pyramid.
	 */_createClass(TextureArray,[{key:'has',value:function has(key){return this.used.has(key);}/**
	 * Returns the chunk matching the provided key. If the chunk does not
	 * exist, returns undefined.
	 *
	 * @param {string} key - The key of the chunk to return.
	 *
	 * @returns {Object} The chunk object.
	 */},{key:'get',value:function get(key){return this.used.get(key);}/**
	 * Set the texture data for the provided key.
	 *
	 * @param {string} key - The key of the texture data.
	 * @param {ArrayBuffer|HTMLCanvasElement|HTMLImageElement} data - The texture data.
	 */},{key:'set',value:function set(key,data){if(this.has(key)){throw'Tile of coord '+key+' already exists in the array';}if(this.available.length===0){throw'No available texture chunks in array';}// get an available chunk
var chunk=this.available.pop();// buffer the data
var gl=this.gl;gl.bindTexture(gl.TEXTURE_2D,chunk.texture);gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,this.invertY);gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,this.premultiplyAlpha);if(data.width&&data.height){// canvas type
gl.texImage2D(gl.TEXTURE_2D,0,// mip-map level
gl[this.format],// webgl requires format === internalFormat
gl[this.format],gl[this.type],data);}else{// arraybuffer type
gl.texImage2D(gl.TEXTURE_2D,0,// mip-map level
gl[this.format],// webgl requires format === internalFormat
this.chunkSize,this.chunkSize,0,// border, must be 0
gl[this.format],gl[this.type],data);}// add to used
this.used.set(key,chunk);}/**
	 * Flags the chunk matching the provided key as unused in the array.
	 *
	 * @param {string} key - The key of the chunk to free.
	 *
	 * @returns {TextureArray} The TextureArray object, for chaining.
	 */},{key:'delete',value:function _delete(key){if(!this.has(key)){throw'Tile of coord '+key+' does not exist in the array';}// get chunk
var chunk=this.used.get(key);// remove from used
this.used.delete(key);// add to available
this.available.push(chunk);return this;}/**
	 * Binds the texture array to the provided texture unit.
	 *
	 * @param {string} key - The key of the chunk to bind.
	 * @param {string} location - The texture unit to activate. Optional.
	 *
	 * @returns {TextureArray} The TextureArray object, for chaining.
	 */},{key:'bind',value:function bind(key){var location=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;if(!this.has(key)){throw'Tile of coord '+key+' does not exist in the array';}var gl=this.gl;var chunk=this.used.get(key);gl.activeTexture(gl['TEXTURE'+location]);gl.bindTexture(gl.TEXTURE_2D,chunk.texture);return this;}/**
	 * Unbinds the texture array.
	 *
	 * @returns {TextureArray} The TextureArray object, for chaining.
	 */},{key:'unbind',value:function unbind(){// no-op
return this;}}]);return TextureArray;}();module.exports=TextureArray;

},{"lodash/defaultTo":109}],197:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var defaultTo=require('lodash/defaultTo');/**
 * Class representing an index buffer.
 */var IndexBuffer=function(){/**
	 * Instantiates an IndexBuffer object.
	 *
	 * @param {WebGLRenderingContext} gl - The WebGL context.
	 * @param {WebGLBuffer|ArrayBuffer|number} arg - The index data to buffer.
	 * @param {Object} options - The rendering options.
	 * @param {string} options.type - The buffer component type.
	 * @param {string} options.mode - The draw mode / primitive type.
	 * @param {string} options.byteOffset - The byte offset into the drawn buffer.
	 * @param {string} options.count - The number of vertices to draw.
	 */function IndexBuffer(gl,arg){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};_classCallCheck(this,IndexBuffer);this.gl=gl;this.type=defaultTo(options.type,'UNSIGNED_SHORT');this.mode=defaultTo(options.mode,'TRIANGLES');this.count=defaultTo(options.count,0);this.byteOffset=defaultTo(options.byteOffset,0);// create buffer
if(arg instanceof WebGLBuffer){this.buffer=arg;}else{this.buffer=gl.createBuffer();if(arg){// buffer the data
this.bufferData(arg);}}}/**
	 * Upload index data to the GPU.
	 *
	 * @param {ArrayBuffer|number} arg - The array of data to buffer.
	 *
	 * @returns {IndexBuffer} The index buffer object, for chaining.
	 */_createClass(IndexBuffer,[{key:'bufferData',value:function bufferData(arg){var gl=this.gl;gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.buffer);gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,arg,gl.STATIC_DRAW);}/**
	 * Upload partial index data to the GPU.
	 *
	 * @param {ArrayBuffer} array - The array of data to buffer.
	 * @param {number} byteOffset - The byte offset at which to buffer.
	 *
	 * @returns {IndexBuffer} The index buffer object, for chaining.
	 */},{key:'bufferSubData',value:function bufferSubData(array){var byteOffset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var gl=this.gl;gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.buffer);gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER,byteOffset,array);return this;}/**
	 * Execute the draw command for the bound buffer.
	 *
	 * @returns {IndexBuffer} The index buffer object, for chaining.
	 */},{key:'draw',value:function draw(){var gl=this.gl;gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.buffer);gl.drawElements(gl[this.mode],this.count,gl[this.type],this.byteOffset);// no need to unbind
return this;}}]);return IndexBuffer;}();module.exports=IndexBuffer;

},{"lodash/defaultTo":109}],198:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var defaultTo=require('lodash/defaultTo');var forIn=require('lodash/forIn');// Constants
var BYTES_PER_TYPE={BYTE:1,UNSIGNED_BYTE:1,SHORT:2,UNSIGNED_SHORT:2,FIXED:4,FLOAT:4};// Private Methods
var calcChunkByteSize=function calcChunkByteSize(pointers,chunkSize){var byteSize=0;pointers.forEach(function(pointer){byteSize+=BYTES_PER_TYPE[pointer.type]*pointer.size*chunkSize;});return byteSize;};var calcByteOffsets=function calcByteOffsets(chunk,pointers,chunkByteOffset){var byteOffset=0;pointers.forEach(function(pointer,location){chunk.byteOffsets[location]=chunkByteOffset+byteOffset;byteOffset+=BYTES_PER_TYPE[pointer.type]*pointer.size;});};var calcStride=function calcStride(pointers){var stride=0;pointers.forEach(function(pointer){stride+=pointer.size;});return stride;};var parseAttributePointers=function parseAttributePointers(pointers){var attributePointers=new Map();var byteOffset=0;// convert to map
forIn(pointers,function(pointer,index){attributePointers.set(index,{type:pointer.type,size:pointer.size,byteOffset:byteOffset,byteStride:0});byteOffset+=BYTES_PER_TYPE[pointer.type]*pointer.size;});// add byte stride
attributePointers.forEach(function(pointer){pointer.byteStride=byteOffset;});return attributePointers;};/**
 * Class representing a vertex atlas.
 */var VertexAtlas=function(){/**
	 * Instantiates a new VertexAtlas object.
	 * NOTE: Assumes interleaved vertex format.
	 *
	 * @param {WebGLRenderingContext} gl - The WebGL context.
	 * @param {Object} pointers - The vertex attribute pointers.
	 * @param {Object} options - The vertex atlas options.
	 * @param {number} options.chunkSize - The size of a single chunk, in vertices.
	 * @param {number} options.numChunks - The size of the atlas, in tiles.
	 */function VertexAtlas(gl,pointers){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};_classCallCheck(this,VertexAtlas);// get context
this.gl=gl;// get the extension for hardware instancing
this.ext=gl.getExtension('ANGLE_instanced_arrays');if(!this.ext){throw'ANGLE_instanced_arrays WebGL extension is not supported';}// set atlas properties
this.chunkSize=defaultTo(options.chunkSize,128*128);this.numChunks=defaultTo(options.numChunks,256);// set the pointers of the atlas
if(!pointers){throw'No attribute pointers provided';}this.pointers=parseAttributePointers(pointers);// calc stride of the atlas
this.stride=calcStride(this.pointers);// create available chunks
this.available=new Array(this.numChunks);// calc the chunk byte size
var chunkByteSize=calcChunkByteSize(this.pointers,this.chunkSize);// for each chunk
for(var i=0;i<this.numChunks;i++){var chunkOffset=i*this.chunkSize;var chunkByteOffset=i*chunkByteSize;var available={count:0,chunkOffset:chunkOffset,chunkByteOffset:chunkByteOffset,byteOffsets:{}};// calculate interleaved offsets / stride, this only needs
// to be done once
calcByteOffsets(available,this.pointers,chunkByteOffset);// add chunk
this.available[i]=available;}// create used chunk map
this.used=new Map();// create buffer
this.buffer=gl.createBuffer();// calc total size of the buffer
var byteSize=chunkByteSize*this.numChunks;// buffer the data
gl.bindBuffer(gl.ARRAY_BUFFER,this.buffer);gl.bufferData(gl.ARRAY_BUFFER,byteSize,gl.DYNAMIC_DRAW);}/**
	 * Test whether or not a key is held in the atlas.
	 *
	 * @param {string} key - The key to test.
	 *
	 * @returns {boolean} Whether or not the coord exists in the pyramid.
	 */_createClass(VertexAtlas,[{key:'has',value:function has(key){return this.used.has(key);}/**
	 * Returns the chunk matching the provided key. If the chunk does not
	 * exist, returns undefined.
	 *
	 * @param {string} key - The key of the chunk to return.
	 *
	 * @returns {Object} The chunk object.
	 */},{key:'get',value:function get(key){return this.used.get(key);}/**
	 * Set the vertex data for the provided key.
	 *
	 * @param {string} key - The key of the vertex data.
	 * @param {ArrayBuffer} data - The vertex data.
	 * @param {number} count - The count of vertices added.
	 */},{key:'set',value:function set(key,data,count){if(this.has(key)){throw'Tile of coord '+key+' already exists in the atlas';}if(this.available.length===0){throw'No available vertex chunks in atlas';}if(count>this.chunkSize){throw'Data count of '+count+' is greater that allocated size of '+this.chunkSize;}// get an available chunk
var chunk=this.available.pop();// update chunk count
chunk.count=count;// only actually buffer the data if there is  data
if(count>0){// buffer the data
var gl=this.gl;gl.bindBuffer(gl.ARRAY_BUFFER,this.buffer);gl.bufferSubData(gl.ARRAY_BUFFER,chunk.chunkByteOffset,data);}// add to used
this.used.set(key,chunk);}/**
	 * Flags the chunk matching the provided key as unused in the atlas.
	 *
	 * @param {string} key - The key of the chunk to free.
	 *
	 * @returns {VertexAtlas} The VertexAtlas object, for chaining.
	 */},{key:'delete',value:function _delete(key){if(!this.has(key)){throw'Tile of coord '+key+' does not exist in the atlas';}// get chunk
var chunk=this.used.get(key);// remove from used
this.used.delete(key);// add to available
this.available.push(chunk);return this;}/**
	 * Binds the vertex atlas and activates the attribute arrays.
	 *
	 * @returns {VertexAtlas} The VertexAtlas object, for chaining.
	 */},{key:'bind',value:function bind(){var gl=this.gl;// bind the buffer
gl.bindBuffer(gl.ARRAY_BUFFER,this.buffer);// for each attribute pointer
this.pointers.forEach(function(pointer,index){// enable attribute index
gl.enableVertexAttribArray(index);// set attribute pointer
gl.vertexAttribPointer(index,pointer.size,gl[pointer.type],false,pointer.byteStride,pointer.byteOffset);});return this;}/**
	 * Binds the vertex atlas and activates the attribute arrays for
	 * instancing.
	 *
	 * @returns {VertexAtlas} The VertexAtlas object, for chaining.
	 */},{key:'bindInstanced',value:function bindInstanced(){var gl=this.gl;var ext=this.ext;// bind the buffer
gl.bindBuffer(gl.ARRAY_BUFFER,this.buffer);// for each attribute pointer
this.pointers.forEach(function(pointer,index){// enable attribute index
gl.enableVertexAttribArray(index);// enable instancing this attribute
ext.vertexAttribDivisorANGLE(index,1);});return this;}/**
	 * Unbinds the vertex atlas and disables the vertex arrays.
	 *
	 * @returns {VertexAtlas} The VertexAtlas object, for chaining.
	 */},{key:'unbind',value:function unbind(){var gl=this.gl;// for each attribute pointer
this.pointers.forEach(function(pointer,index){// disable attribute index
gl.disableVertexAttribArray(index);});return this;}/**
	 * Unbinds the vertex atlas and disables the vertex arrays for
	 * instancing.
	 *
	 * @returns {VertexAtlas} The VertexAtlas object, for chaining.
	 */},{key:'unbindInstanced',value:function unbindInstanced(){var gl=this.gl;var ext=this.ext;// for each attribute pointer
this.pointers.forEach(function(pointer,index){// disable attribute index
gl.disableVertexAttribArray(index);// disable instancing this attribute
ext.vertexAttribDivisorANGLE(index,0);});return this;}/**
	 * Execute the draw command at the correct offset and count within the
	 * atlas.
	 *
	 * @param {string} key - The key of the chunk to draw.
	 * @param {string} mode - The primitive drawing mode to use.
	 * @param {number} offset - The offset into the chunk. Optional.
	 * @param {number} count - The count of primitives to render. Optional.
	 *
	 * @returns {VertexBuffer} The vertex buffer object, for chaining.
	 */},{key:'draw',value:function draw(key,mode){var offset=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var count=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;if(!this.has(key)){throw'Tile of coord '+key+' does not exist in the atlas';}var gl=this.gl;var chunk=this.used.get(key);// only actually draw if count > 0
if(chunk.count>0){// draw the chunk
gl.drawArrays(gl[mode],chunk.chunkOffset+offset,count?count:chunk.count);}}/**
	 * Execute the instanced draw command at the correct offset and count within
	 * the atlas.
	 *
	 * @param {string} key - The key of the chunk to draw.
	 * @param {string} mode - The primitive drawing mode to use.
	 * @param {number} count - The count of primitives to render. Optional.
	 *
	 * @returns {VertexBuffer} The vertex buffer object, for chaining.
	 */},{key:'drawInstanced',value:function drawInstanced(key,mode,count){if(!this.has(key)){throw'Tile of coord '+key+' does not exist in the atlas';}var gl=this.gl;var ext=this.ext;var chunk=this.used.get(key);// for each attribute pointer
this.pointers.forEach(function(pointer,index){// set attribute pointer
gl.vertexAttribPointer(index,pointer.size,gl[pointer.type],false,pointer.byteStride,chunk.byteOffsets[index]);});// only actually draw if count > 0
if(chunk.count>0){// draw the bound vertex array
ext.drawArraysInstancedANGLE(gl[mode],0,count,chunk.count);}}}]);return VertexAtlas;}();module.exports=VertexAtlas;

},{"lodash/defaultTo":109,"lodash/forIn":111}],199:[function(require,module,exports){
'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var defaultTo=require('lodash/defaultTo');var forIn=require('lodash/forIn');// Constants
var BYTES_PER_TYPE={BYTE:1,UNSIGNED_BYTE:1,SHORT:2,UNSIGNED_SHORT:2,FIXED:4,FLOAT:4};// Private Methods
var getStride=function getStride(pointers){// if there is only one attribute pointer assigned to this buffer,
// there is no need for stride, set to default of 0
if(pointers.size===1){return 0;}var maxByteOffset=0;var byteSizeSum=0;var byteStride=0;pointers.forEach(function(pointer){var byteOffset=pointer.byteOffset;var size=pointer.size;var type=pointer.type;// track the sum of each attribute size
byteSizeSum+=size*BYTES_PER_TYPE[type];// track the largest offset to determine the byte stride of the buffer
if(byteOffset>maxByteOffset){maxByteOffset=byteOffset;byteStride=byteOffset+size*BYTES_PER_TYPE[type];}});// check if the max byte offset is greater than or equal to the the sum
// of the sizes. If so this buffer is not interleaved and does not need
// a stride.
if(maxByteOffset>=byteSizeSum){// TODO: test what stride === 0 does for an interleaved buffer of
// length === 1.
return 0;}return byteStride;};var getAttributePointers=function getAttributePointers(attributePointers){// parse pointers to ensure they are valid
var pointers=new Map();forIn(attributePointers,function(pointer,key){// parse index from string to int
var index=parseInt(key,10);// ensure byte offset exists
pointer.byteOffset=defaultTo(pointer.byteOffset,0);// add to map
pointers.set(index,pointer);});return pointers;};/**
 * Class representing a vertex buffer.
 */var VertexBuffer=function(){/**
	 * Instantiates an VertexBuffer object.
	 *
	 * @param {WebGLRenderingContext} gl - The WebGL context.
	 * @param {WebGLBuffer|ArrayBuffer|number} arg - The buffer or length of the buffer.
	 * @param {Object} pointers - The array pointer map.
	 * @param {Object} options - The vertex buffer options.
	 * @param {string} options.mode - The draw mode / primitive type.
	 * @param {string} options.indexOffset - The index offset into the drawn buffer.
	 * @param {string} options.count - The number of indices to draw.
	 */function VertexBuffer(gl,arg){var pointers=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var options=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};_classCallCheck(this,VertexBuffer);this.gl=gl;this.mode=defaultTo(options.mode,'TRIANGLES');this.count=defaultTo(options.count,0);this.indexOffset=defaultTo(options.indexOffset,0);// first, set the attribute pointers
this.pointers=getAttributePointers(pointers);// set the byte stride
this.byteStride=getStride(this.pointers);// create buffer
if(arg instanceof WebGLBuffer){this.buffer=arg;}else{this.buffer=gl.createBuffer();if(arg){// buffer the data
this.bufferData(arg);}}}/**
	 * Upload vertex data to the GPU.
	 *
	 * @param {ArrayBuffer|number} arg - The array of data to buffer, or size of the buffer in bytes.
	 *
	 * @returns {VertexBuffer} The vertex buffer object, for chaining.
	 */_createClass(VertexBuffer,[{key:'bufferData',value:function bufferData(arg){var gl=this.gl;gl.bindBuffer(gl.ARRAY_BUFFER,this.buffer);gl.bufferData(gl.ARRAY_BUFFER,arg,gl.STATIC_DRAW);return this;}/**
	 * Upload partial vertex data to the GPU.
	 *
	 * @param {ArrayBuffer} array - The array of data to buffer.
	 * @param {number} byteOffset - The byte offset at which to buffer.
	 *
	 * @returns {VertexBuffer} The vertex buffer object, for chaining.
	 */},{key:'bufferSubData',value:function bufferSubData(array){var byteOffset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var gl=this.gl;gl.bindBuffer(gl.ARRAY_BUFFER,this.buffer);gl.bufferSubData(gl.ARRAY_BUFFER,byteOffset,array);return this;}/**
	 * Binds the vertex buffer object.
	 *
	 * @returns {VertexBuffer} The vertex buffer object, for chaining.
	 */},{key:'bind',value:function bind(){var _this=this;var gl=this.gl;// bind buffer
gl.bindBuffer(gl.ARRAY_BUFFER,this.buffer);// for each attribute pointer
this.pointers.forEach(function(pointer,index){// set attribute pointer
gl.vertexAttribPointer(index,pointer.size,gl[pointer.type],false,_this.byteStride,pointer.byteOffset);// enable attribute index
gl.enableVertexAttribArray(index);});return this;}/**
	 * Unbinds the vertex buffer object.
	 *
	 * @returns {VertexBuffer} The vertex buffer object, for chaining.
	 */},{key:'unbind',value:function unbind(){var gl=this.gl;this.pointers.forEach(function(pointer,index){// disable attribute index
gl.disableVertexAttribArray(index);});return this;}/**
	 * Execute the draw command for the bound buffer.
	 *
	 * @returns {VertexBuffer} The vertex buffer object, for chaining.
	 */},{key:'draw',value:function draw(){var gl=this.gl;gl.drawArrays(gl[this.mode],this.indexOffset,this.count);return this;}}]);return VertexBuffer;}();module.exports=VertexBuffer;

},{"lodash/defaultTo":109,"lodash/forIn":111}]},{},[145])(145)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZWFyY3V0L3NyYy9lYXJjdXQuanMiLCJub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fUHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldENhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19VaW50OEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fV2Vha01hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TWFwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlQdXNoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlTb21lLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNsYW1wLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUVhY2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRm9yLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvck93bi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0QWxsS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSGFzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsRGVlcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hdGNoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJdGVyYXRlZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHlEZWVwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0RnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0UGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVCYXNlRWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VGb3IuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEFycmF5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQnlUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbE9iamVjdHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXRjaERhdGEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNQYXRoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaENsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzTWFza2VkLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZVNldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcFRvQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21lbW9pemVDYXBwZWQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbm9kZVV0aWwuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVBZGQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tEZWxldGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0dldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb1BhdGguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL190b0tleS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9jbGFtcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZGVib3VuY2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2RlZmF1bHRUby5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ZvckluLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9nZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2hhc0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0J1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2tleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbWFwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9ub3cuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3Byb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJGYWxzZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdGhyb3R0bGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3RvTnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC90b1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9xdWlja3NlbGVjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yYnVzaC9pbmRleC5qcyIsInNyYy9ldmVudC9FdmVudC5qcyIsInNyYy9ldmVudC9FdmVudEJyb2FkY2FzdGVyLmpzIiwic3JjL2V2ZW50L0V2ZW50RGVsZWdhdG9yLmpzIiwic3JjL2V2ZW50L0V2ZW50VHlwZS5qcyIsInNyYy9ldmVudC9Nb3VzZUV2ZW50LmpzIiwic3JjL2V2ZW50L1Jlc2l6ZUV2ZW50LmpzIiwic3JjL2V2ZW50L1RpbGVFdmVudC5qcyIsInNyYy9leHBvcnRzLmpzIiwic3JjL2dlb21ldHJ5L0JvdW5kcy5qcyIsInNyYy9nZW9tZXRyeS9DaXJjbGVDb2xsaWRhYmxlLmpzIiwic3JjL2dlb21ldHJ5L1JUcmVlLmpzIiwic3JjL2dlb21ldHJ5L1JUcmVlUHlyYW1pZC5qcyIsInNyYy9nZW9tZXRyeS9SZWN0YW5nbGVDb2xsaWRhYmxlLmpzIiwic3JjL2dlb21ldHJ5L1JpbmdDb2xsaWRhYmxlLmpzIiwic3JjL2xheWVyL0xheWVyLmpzIiwic3JjL2xheWVyL292ZXJsYXkvT3ZlcmxheS5qcyIsInNyYy9sYXllci9vdmVybGF5L1BvaW50T3ZlcmxheS5qcyIsInNyYy9sYXllci9vdmVybGF5L1BvbHlnb25PdmVybGF5LmpzIiwic3JjL2xheWVyL292ZXJsYXkvUG9seWxpbmVPdmVybGF5LmpzIiwic3JjL2xheWVyL3RpbGUvVGlsZS5qcyIsInNyYy9sYXllci90aWxlL1RpbGVDb29yZC5qcyIsInNyYy9sYXllci90aWxlL1RpbGVMYXllci5qcyIsInNyYy9sYXllci90aWxlL1RpbGVQYXJ0aWFsLmpzIiwic3JjL2xheWVyL3RpbGUvVGlsZVB5cmFtaWQuanMiLCJzcmMvcGxvdC9DZWxsLmpzIiwic3JjL3Bsb3QvUGxvdC5qcyIsInNyYy9wbG90L1ZpZXdwb3J0LmpzIiwic3JjL3Bsb3QvYW5pbWF0aW9uL0FuaW1hdGlvbi5qcyIsInNyYy9wbG90L2FuaW1hdGlvbi9QYW5BbmltYXRpb24uanMiLCJzcmMvcGxvdC9hbmltYXRpb24vWm9vbUFuaW1hdGlvbi5qcyIsInNyYy9wbG90L2hhbmRsZXIvQ2xpY2tIYW5kbGVyLmpzIiwic3JjL3Bsb3QvaGFuZGxlci9ET01IYW5kbGVyLmpzIiwic3JjL3Bsb3QvaGFuZGxlci9Nb3VzZUhhbmRsZXIuanMiLCJzcmMvcGxvdC9oYW5kbGVyL1BhbkhhbmRsZXIuanMiLCJzcmMvcGxvdC9oYW5kbGVyL1pvb21IYW5kbGVyLmpzIiwic3JjL3JlbmRlcmVyL1JlbmRlcmVyLmpzIiwic3JjL3JlbmRlcmVyL292ZXJsYXkvT3ZlcmxheVJlbmRlcmVyLmpzIiwic3JjL3JlbmRlcmVyL292ZXJsYXkvV2ViR0xPdmVybGF5UmVuZGVyZXIuanMiLCJzcmMvcmVuZGVyZXIvb3ZlcmxheS9zYW1wbGUvUG9pbnRPdmVybGF5UmVuZGVyZXIuanMiLCJzcmMvcmVuZGVyZXIvb3ZlcmxheS9zYW1wbGUvUG9seWdvbk92ZXJsYXlSZW5kZXJlci5qcyIsInNyYy9yZW5kZXJlci9vdmVybGF5L3NhbXBsZS9Qb2x5bGluZU92ZXJsYXlSZW5kZXJlci5qcyIsInNyYy9yZW5kZXJlci90aWxlL1RpbGVSZW5kZXJhYmxlLmpzIiwic3JjL3JlbmRlcmVyL3RpbGUvVGlsZVJlbmRlcmVyLmpzIiwic3JjL3JlbmRlcmVyL3RpbGUvV2ViR0xUaWxlUmVuZGVyZXIuanMiLCJzcmMvcmVuZGVyZXIvdGlsZS9zYW1wbGUvSW1hZ2VUaWxlUmVuZGVyZXIuanMiLCJzcmMvcmVuZGVyZXIvdGlsZS9zYW1wbGUvSW5zdGFuY2VkVGlsZVJlbmRlcmVyLmpzIiwic3JjL3JlbmRlcmVyL3RpbGUvc2FtcGxlL0ludGVyYWN0aXZlVGlsZVJlbmRlcmVyLmpzIiwic3JjL3JlbmRlcmVyL3RpbGUvc2FtcGxlL1BvaW50VGlsZVJlbmRlcmVyLmpzIiwic3JjL3V0aWwvQnJvd3Nlci5qcyIsInNyYy91dGlsL0xSVUNhY2hlLmpzIiwic3JjL3V0aWwvTGlua2VkTGlzdC5qcyIsInNyYy91dGlsL2xvYWRCdWZmZXIuanMiLCJzcmMvdXRpbC9sb2FkSW1hZ2UuanMiLCJzcmMvd2ViZ2wvUmVuZGVyQnVmZmVyLmpzIiwic3JjL3dlYmdsL3NoYWRlci9TaGFkZXIuanMiLCJzcmMvd2ViZ2wvc2hhZGVyL3BhcnNlU2hhZGVyLmpzIiwic3JjL3dlYmdsL3NoYWRlci9wcmVwcm9jZXNzLmpzIiwic3JjL3dlYmdsL3RleHR1cmUvVGV4dHVyZS5qcyIsInNyYy93ZWJnbC90ZXh0dXJlL1RleHR1cmVBcnJheS5qcyIsInNyYy93ZWJnbC92ZXJ0ZXgvSW5kZXhCdWZmZXIuanMiLCJzcmMvd2ViZ2wvdmVydGV4L1ZlcnRleEF0bGFzLmpzIiwic3JjL3dlYmdsL3ZlcnRleC9WZXJ0ZXhCdWZmZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQSxhQUVBLE9BQU8sT0FBUCxDQUFpQixNQUFqQixDQUVBLFFBQVMsT0FBVCxDQUFnQixJQUFoQixDQUFzQixXQUF0QixDQUFtQyxHQUFuQyxDQUF3QyxDQUVwQyxJ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TyxJQUFQLENBQW5CLENBRUEsR0FBTSxJQUFLLFVBQVUsRUFBVixDQUFYLENBQ0EsR0FBTSxLQUFNLE9BQU8sRUFBUCxDQUFaLENBQ0EsR0FBTSxJQUFLLFVBQVUsRUFBVixDQUFYLENBQ0EsR0FBTSxLQUFNLE9BQU8sRUFBUCxDQUFaLENBRUE7QUFDQTtBQUNBLEdBQUksYUFBZSxVQUFmLEVBQTZCLGFBQWUsVUFBaEQsQ0FBNEQsQ0FFM0QsVUFBVSxJQUFWLENBQWUsRUFBZixFQUNBLFVBQVUsSUFBVixDQUFlLEVBQWYsRUFDQSxVQUFVLElBQVYsQ0FBZSxFQUFmLEVBRUEsUUFBUSxJQUFSLENBQWEsRUFBYixFQUNBLFFBQVEsSUFBUixDQUFhLEdBQWIsRUFDQSxRQUFRLElBQVIsQ0FBYSxFQUFiLEVBRUEsVUFBVSxJQUFWLENBQWUsRUFBZixFQUNBLFVBQVUsSUFBVixDQUFlLEVBQWYsRUFDQSxVQUFVLElBQVYsQ0FBZSxFQUFmLEVBRUEsUUFBUSxJQUFSLENBQWEsR0FBYixFQUNBLFFBQVEsSUFBUixDQUFhLEVBQWIsRUFDQSxRQUFRLElBQVIsQ0FBYSxHQUFiLEVBRUEsZUFDQyxFQURELENBRUMsSUFBSSxFQUFKLENBQVEsRUFBUixDQUZELENBR0MsSUFBSSxFQUFKLENBQVEsRUFBUixDQUhELENBSUMsRUFKRCxDQUtDLFNBTEQsQ0FNQyxPQU5ELEVBUUEsVUFBVSxJQUFWLENBQWUsRUFBZixFQUNBLFVBQVUsSUFBVixDQUFlLEVBQWYsRUFDQSxVQUFVLElBQVYsQ0FBZSxFQUFmLEVBRUEsUUFBUSxJQUFSLENBQWEsRUFBYixFQUNBLFFBQVEsSUFBUixDQUFhLEdBQWIsRUFDQSxRQUFRLElBQVIsQ0FBYSxFQUFiLEVBRUEsVUFBVSxJQUFWLENBQWUsRUFBZixFQUNBLFVBQVUsSUFBVixDQUFlLEVBQWYsRUFDQSxVQUFVLElBQVYsQ0FBZSxFQUFmLEVBRUEsUUFBUSxJQUFSLENBQWEsRUFBYixFQUNBLFFBQVEsSUFBUixDQUFhLEdBQWIsRUFDQSxRQUFRLElBQVIsQ0FBYSxHQUFiLEVBRUEsQ0ExQ0QsSUEwQ08sQ0FFTixVQUFVLElBQVYsQ0FBZSxFQUFmLEVBQ0EsVUFBVSxJQUFWLENBQWUsRUFBZixFQUNBLFVBQVUsSUFBVixDQUFlLEVBQWYsRUFFQSxRQUFRLElBQVIsQ0FBYSxFQUFiLEVBQ0EsUUFBUSxJQUFSLENBQWEsR0FBYixFQUNBLFFBQVEsSUFBUixDQUFhLEdBQWIsRUFFQSxVQUFVLElBQVYsQ0FBZSxFQUFmLEVBQ0EsVUFBVSxJQUFWLENBQWUsRUFBZixFQUNBLFVBQVUsSUFBVixDQUFlLEVBQWYsRUFFQSxRQUFRLElBQVIsQ0FBYSxFQUFiLEVBQ0EsUUFBUSxJQUFSLENBQWEsR0FBYixFQUNBLFFBQVEsSUFBUixDQUFhLEVBQWIsRUFFQSxVQUFVLElBQVYsQ0FBZSxFQUFmLEVBQ0EsVUFBVSxJQUFWLENBQWUsRUFBZixFQUNBLFVBQVUsSUFBVixDQUFlLEVBQWYsRUFFQSxRQUFRLElBQVIsQ0FBYSxFQUFiLEVBQ0EsUUFBUSxJQUFSLENBQWEsQ0FBRSxFQUFHLENBQUwsQ0FBUSxFQUFHLENBQVgsQ0FBYixFQUNBLFFBQVEsSUFBUixDQUFhLEdBQWIsRUFFQSxlQUNDLEVBREQsQ0FFQyxJQUFJLEVBQUosQ0FBUSxFQUFSLENBRkQsQ0FHQyxJQUFJLEVBQUosQ0FBUSxFQUFSLENBSEQsQ0FJQyxJQUFJLEVBQUosQ0FBUSxNQUFSLENBSkQsQ0FLQyxTQUxELENBTUMsT0FORCxFQVFBLFVBQVUsSUFBVixDQUFlLEVBQWYsRUFDQSxVQUFVLElBQVYsQ0FBZSxFQUFmLEVBQ0EsVUFBVSxJQUFWLENBQWUsRUFBZixFQUVBLFFBQVEsSUFBUixDQUFhLENBQUUsRUFBRyxDQUFMLENBQVEsRUFBRyxDQUFYLENBQWIsRUFDQSxRQUFRLElBQVIsQ0FBYSxFQUFiLEVBQ0EsUUFBUSxJQUFSLENBQWEsR0FBYixFQUVBLFVBQVUsSUFBVixDQUFlLEVBQWYsRUFDQSxVQUFVLElBQVYsQ0FBZSxFQUFmLEVBQ0EsVUFBVSxJQUFWLENBQWUsRUFBZixFQUVBLFFBQVEsSUFBUixDQUFhLEVBQWIsRUFDQSxR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QixLQUFLLFdBQWxDLENBQStDLEtBQUssS0FBcEQsRUFDQSxNQUFPLEtBQVAsQ0FDQSxDLDRCQUdGLE9BQU8sT0FBUCxDQUFpQixZQUFqQiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZWFyY3V0O1xuXG5mdW5jdGlvbiBlYXJjdXQoZGF0YSwgaG9sZUluZGljZXMsIGRpbSkge1xuXG4gICAgZGltID0gZGltIHx8IDI7XG5cbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGgsXG4gICAgICAgIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoLFxuICAgICAgICBvdXRlck5vZGUgPSBsaW5rZWRMaXN0KGRhdGEsIDAsIG91dGVyTGVuLCBkaW0sIHRydWUpLFxuICAgICAgICB0cmlhbmdsZXMgPSBbXTtcblxuICAgIGlmICghb3V0ZXJOb2RlKSByZXR1cm4gdHJpYW5nbGVzO1xuXG4gICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIHNpemU7XG5cbiAgICBpZiAoaGFzSG9sZXMpIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSk7XG5cbiAgICAvLyBpZiB0aGUgc2hhcGUgaXMgbm90IHRvbyBzaW1wbGUsIHdlJ2xsIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2ggbGF0ZXI7IGNhbGN1bGF0ZSBwb2x5Z29uIGJib3hcbiAgICBpZiAoZGF0YS5sZW5ndGggPiA4MCAqIGRpbSkge1xuICAgICAgICBtaW5YID0gbWF4WCA9IGRhdGFbMF07XG4gICAgICAgIG1pblkgPSBtYXhZID0gZGF0YVsxXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gZGltOyBpIDwgb3V0ZXJMZW47IGkgKz0gZGltKSB7XG4gICAgICAgICAgICB4ID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHkgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuICAgICAgICAgICAgaWYgKHggPiBtYXhYKSBtYXhYID0geDtcbiAgICAgICAgICAgIGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtaW5YLCBtaW5ZIGFuZCBzaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxuICAgICAgICBzaXplID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbiAgICB9XG5cbiAgICBlYXJjdXRMaW5rZWQob3V0ZXJOb2RlLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSk7XG5cbiAgICByZXR1cm4gdHJpYW5nbGVzO1xufVxuXG4vLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcbmZ1bmN0aW9uIGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBjbG9ja3dpc2UpIHtcbiAgICB2YXIgaSwgbGFzdDtcblxuICAgIGlmIChjbG9ja3dpc2UgPT09IChzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkgPiAwKSkge1xuICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSBlbmQgLSBkaW07IGkgPj0gc3RhcnQ7IGkgLT0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgfVxuXG4gICAgaWYgKGxhc3QgJiYgZXF1YWxzKGxhc3QsIGxhc3QubmV4dCkpIHtcbiAgICAgICAgcmVtb3ZlTm9kZShsYXN0KTtcbiAgICAgICAgbGFzdCA9IGxhc3QubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbGFzdDtcbn1cblxuLy8gZWxpbWluYXRlIGNvbGluZWFyIG9yIGR1cGxpY2F0ZSBwb2ludHNcbmZ1bmN0aW9uIGZpbHRlclBvaW50cyhzdGFydCwgZW5kKSB7XG4gICAgaWYgKCFzdGFydCkgcmV0dXJuIHN0YXJ0O1xuICAgIGlmICghZW5kKSBlbmQgPSBzdGFydDtcblxuICAgIHZhciBwID0gc3RhcnQsXG4gICAgICAgIGFnYWluO1xuICAgIGRvIHtcbiAgICAgICAgYWdhaW4gPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXAuc3RlaW5lciAmJiAoZXF1YWxzKHAsIHAubmV4dCkgfHwgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPT09IDApKSB7XG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgICAgICAgcCA9IGVuZCA9IHAucHJldjtcbiAgICAgICAgICAgIGlmIChwID09PSBwLm5leHQpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgYWdhaW4gPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoYWdhaW4gfHwgcCAhPT0gZW5kKTtcblxuICAgIHJldHVybiBlbmQ7XG59XG5cbi8vIG1haW4gZWFyIHNsaWNpbmcgbG9vcCB3aGljaCB0cmlhbmd1bGF0ZXMgYSBwb2x5Z29uIChnaXZlbiBhcyBhIGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUsIHBhc3MpIHtcbiAgICBpZiAoIWVhcikgcmV0dXJuO1xuXG4gICAgLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuICAgIGlmICghcGFzcyAmJiBzaXplKSBpbmRleEN1cnZlKGVhciwgbWluWCwgbWluWSwgc2l6ZSk7XG5cbiAgICB2YXIgc3RvcCA9IGVhcixcbiAgICAgICAgcHJldiwgbmV4dDtcblxuICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBlYXJzLCBzbGljaW5nIHRoZW0gb25lIGJ5IG9uZVxuICAgIHdoaWxlIChlYXIucHJldiAhPT0gZWFyLm5leHQpIHtcbiAgICAgICAgcHJldiA9IGVhci5wcmV2O1xuICAgICAgICBuZXh0ID0gZWFyLm5leHQ7XG5cbiAgICAgICAgaWYgKHNpemUgPyBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIHNpemUpIDogaXNFYXIoZWFyKSkge1xuICAgICAgICAgICAgLy8gY3V0IG9mZiB0aGUgdHJpYW5nbGVcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHByZXYuaSAvIGRpbSk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChlYXIuaSAvIGRpbSk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChuZXh0LmkgLyBkaW0pO1xuXG4gICAgICAgICAgICByZW1vdmVOb2RlKGVhcik7XG5cbiAgICAgICAgICAgIC8vIHNraXBwaW5nIHRoZSBuZXh0IHZlcnRpY2UgbGVhZHMgdG8gbGVzcyBzbGl2ZXIgdHJpYW5nbGVzXG4gICAgICAgICAgICBlYXIgPSBuZXh0Lm5leHQ7XG4gICAgICAgICAgICBzdG9wID0gbmV4dC5uZXh0O1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhciA9IG5leHQ7XG5cbiAgICAgICAgLy8gaWYgd2UgbG9vcGVkIHRocm91Z2ggdGhlIHdob2xlIHJlbWFpbmluZyBwb2x5Z29uIGFuZCBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnNcbiAgICAgICAgaWYgKGVhciA9PT0gc3RvcCkge1xuICAgICAgICAgICAgLy8gdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIHNsaWNpbmcgYWdhaW5cbiAgICAgICAgICAgIGlmICghcGFzcykge1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUsIDEpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZWFyID0gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhlYXIsIHRyaWFuZ2xlcywgZGltKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSwgMik7XG5cbiAgICAgICAgICAgIC8vIGFzIGEgbGFzdCByZXNvcnQsIHRyeSBzcGxpdHRpbmcgdGhlIHJlbWFpbmluZyBwb2x5Z29uIGludG8gdHdvXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBzcGxpdEVhcmN1dChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIGNoZWNrIHdoZXRoZXIgYSBwb2x5Z29uIG5vZGUgZm9ybXMgYSB2YWxpZCBlYXIgd2l0aCBhZGphY2VudCBub2Rlc1xuZnVuY3Rpb24gaXNFYXIoZWFyKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcbiAgICB2YXIgcCA9IGVhci5uZXh0Lm5leHQ7XG5cbiAgICB3aGlsZSAocCAhPT0gZWFyLnByZXYpIHtcbiAgICAgICAgaWYgKHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcbiAgICB2YXIgbWluVFggPSBhLnggPCBiLnggPyAoYS54IDwgYy54ID8gYS54IDogYy54KSA6IChiLnggPCBjLnggPyBiLnggOiBjLngpLFxuICAgICAgICBtaW5UWSA9IGEueSA8IGIueSA/IChhLnkgPCBjLnkgPyBhLnkgOiBjLnkpIDogKGIueSA8IGMueSA/IGIueSA6IGMueSksXG4gICAgICAgIG1heFRYID0gYS54ID4gYi54ID8gKGEueCA+IGMueCA/IGEueCA6IGMueCkgOiAoYi54ID4gYy54ID8gYi54IDogYy54KSxcbiAgICAgICAgbWF4VFkgPSBhLnkgPiBiLnkgPyAoYS55ID4gYy55ID8gYS55IDogYy55KSA6IChiLnkgPiBjLnkgPyBiLnkgOiBjLnkpO1xuXG4gICAgLy8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcbiAgICB2YXIgbWluWiA9IHpPcmRlcihtaW5UWCwgbWluVFksIG1pblgsIG1pblksIHNpemUpLFxuICAgICAgICBtYXhaID0gek9yZGVyKG1heFRYLCBtYXhUWSwgbWluWCwgbWluWSwgc2l6ZSk7XG5cbiAgICAvLyBmaXJzdCBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBpbiBpbmNyZWFzaW5nIHotb3JkZXJcbiAgICB2YXIgcCA9IGVhci5uZXh0WjtcblxuICAgIHdoaWxlIChwICYmIHAueiA8PSBtYXhaKSB7XG4gICAgICAgIGlmIChwICE9PSBlYXIucHJldiAmJiBwICE9PSBlYXIubmV4dCAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5uZXh0WjtcbiAgICB9XG5cbiAgICAvLyB0aGVuIGxvb2sgZm9yIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcbiAgICBwID0gZWFyLnByZXZaO1xuXG4gICAgd2hpbGUgKHAgJiYgcC56ID49IG1pblopIHtcbiAgICAgICAgaWYgKHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLnByZXZaO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vLyBnbyB0aHJvdWdoIGFsbCBwb2x5Z29uIG5vZGVzIGFuZCBjdXJlIHNtYWxsIGxvY2FsIHNlbGYtaW50ZXJzZWN0aW9uc1xuZnVuY3Rpb24gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhzdGFydCwgdHJpYW5nbGVzLCBkaW0pIHtcbiAgICB2YXIgcCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGEgPSBwLnByZXYsXG4gICAgICAgICAgICBiID0gcC5uZXh0Lm5leHQ7XG5cbiAgICAgICAgaWYgKCFlcXVhbHMoYSwgYikgJiYgaW50ZXJzZWN0cyhhLCBwLCBwLm5leHQsIGIpICYmIGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSkge1xuXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChhLmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocC5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGIuaSAvIGRpbSk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0d28gbm9kZXMgaW52b2x2ZWRcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICByZW1vdmVOb2RlKHAubmV4dCk7XG5cbiAgICAgICAgICAgIHAgPSBzdGFydCA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gcDtcbn1cblxuLy8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcbmZ1bmN0aW9uIHNwbGl0RWFyY3V0KHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSkge1xuICAgIC8vIGxvb2sgZm9yIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXG4gICAgdmFyIGEgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBiID0gYS5uZXh0Lm5leHQ7XG4gICAgICAgIHdoaWxlIChiICE9PSBhLnByZXYpIHtcbiAgICAgICAgICAgIGlmIChhLmkgIT09IGIuaSAmJiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBzcGxpdFBvbHlnb24oYSwgYik7XG5cbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuICAgICAgICAgICAgICAgIGEgPSBmaWx0ZXJQb2ludHMoYSwgYS5uZXh0KTtcbiAgICAgICAgICAgICAgICBjID0gZmlsdGVyUG9pbnRzKGMsIGMubmV4dCk7XG5cbiAgICAgICAgICAgICAgICAvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGMsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiID0gYi5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhLm5leHQ7XG4gICAgfSB3aGlsZSAoYSAhPT0gc3RhcnQpO1xufVxuXG4vLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pIHtcbiAgICB2YXIgcXVldWUgPSBbXSxcbiAgICAgICAgaSwgbGVuLCBzdGFydCwgZW5kLCBsaXN0O1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcbiAgICAgICAgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgbGlzdCA9IGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBmYWxzZSk7XG4gICAgICAgIGlmIChsaXN0ID09PSBsaXN0Lm5leHQpIGxpc3Quc3RlaW5lciA9IHRydWU7XG4gICAgICAgIHF1ZXVlLnB1c2goZ2V0TGVmdG1vc3QobGlzdCkpO1xuICAgIH1cblxuICAgIHF1ZXVlLnNvcnQoY29tcGFyZVgpO1xuXG4gICAgLy8gcHJvY2VzcyBob2xlcyBmcm9tIGxlZnQgdG8gcmlnaHRcbiAgICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxpbWluYXRlSG9sZShxdWV1ZVtpXSwgb3V0ZXJOb2RlKTtcbiAgICAgICAgb3V0ZXJOb2RlID0gZmlsdGVyUG9pbnRzKG91dGVyTm9kZSwgb3V0ZXJOb2RlLm5leHQpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRlck5vZGU7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVYKGEsIGIpIHtcbiAgICByZXR1cm4gYS54IC0gYi54O1xufVxuXG4vLyBmaW5kIGEgYnJpZGdlIGJldHdlZW4gdmVydGljZXMgdGhhdCBjb25uZWN0cyBob2xlIHdpdGggYW4gb3V0ZXIgcmluZyBhbmQgYW5kIGxpbmsgaXRcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGUoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgb3V0ZXJOb2RlID0gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKTtcbiAgICBpZiAob3V0ZXJOb2RlKSB7XG4gICAgICAgIHZhciBiID0gc3BsaXRQb2x5Z29uKG91dGVyTm9kZSwgaG9sZSk7XG4gICAgICAgIGZpbHRlclBvaW50cyhiLCBiLm5leHQpO1xuICAgIH1cbn1cblxuLy8gRGF2aWQgRWJlcmx5J3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIGEgYnJpZGdlIGJldHdlZW4gaG9sZSBhbmQgb3V0ZXIgcG9seWdvblxuZnVuY3Rpb24gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgdmFyIHAgPSBvdXRlck5vZGUsXG4gICAgICAgIGh4ID0gaG9sZS54LFxuICAgICAgICBoeSA9IGhvbGUueSxcbiAgICAgICAgcXggPSAtSW5maW5pdHksXG4gICAgICAgIG07XG5cbiAgICAvLyBmaW5kIGEgc2VnbWVudCBpbnRlcnNlY3RlZCBieSBhIHJheSBmcm9tIHRoZSBob2xlJ3MgbGVmdG1vc3QgcG9pbnQgdG8gdGhlIGxlZnQ7XG4gICAgLy8gc2VnbWVudCdzIGVuZHBvaW50IHdpdGggbGVzc2VyIHggd2lsbCBiZSBwb3RlbnRpYWwgY29ubmVjdGlvbiBwb2ludFxuICAgIGRvIHtcbiAgICAgICAgaWYgKGh5IDw9IHAueSAmJiBoeSA+PSBwLm5leHQueSkge1xuICAgICAgICAgICAgdmFyIHggPSBwLnggKyAoaHkgLSBwLnkpICogKHAubmV4dC54IC0gcC54KSAvIChwLm5leHQueSAtIHAueSk7XG4gICAgICAgICAgICBpZiAoeCA8PSBoeCAmJiB4ID4gcXgpIHtcbiAgICAgICAgICAgICAgICBxeCA9IHg7XG4gICAgICAgICAgICAgICAgaWYgKHggPT09IGh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoeSA9PT0gcC55KSByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGh5ID09PSBwLm5leHQueSkgcmV0dXJuIHAubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbSA9IHAueCA8IHAubmV4dC54ID8gcCA6IHAubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IG91dGVyTm9kZSk7XG5cbiAgICBpZiAoIW0pIHJldHVybiBudWxsO1xuXG4gICAgaWYgKGh4ID09PSBxeCkgcmV0dXJuIG0ucHJldjsgLy8gaG9sZSB0b3VjaGVzIG91dGVyIHNlZ21lbnQ7IHBpY2sgbG93ZXIgZW5kcG9pbnRcblxuICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIG9mIGhvbGUgcG9pbnQsIHNlZ21lbnQgaW50ZXJzZWN0aW9uIGFuZCBlbmRwb2ludDtcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzIGZvdW5kLCB3ZSBoYXZlIGEgdmFsaWQgY29ubmVjdGlvbjtcbiAgICAvLyBvdGhlcndpc2UgY2hvb3NlIHRoZSBwb2ludCBvZiB0aGUgbWluaW11bSBhbmdsZSB3aXRoIHRoZSByYXkgYXMgY29ubmVjdGlvbiBwb2ludFxuXG4gICAgdmFyIHN0b3AgPSBtLFxuICAgICAgICBteCA9IG0ueCxcbiAgICAgICAgbXkgPSBtLnksXG4gICAgICAgIHRhbk1pbiA9IEluZmluaXR5LFxuICAgICAgICB0YW47XG5cbiAgICBwID0gbS5uZXh0O1xuXG4gICAgd2hpbGUgKHAgIT09IHN0b3ApIHtcbiAgICAgICAgaWYgKGh4ID49IHAueCAmJiBwLnggPj0gbXggJiZcbiAgICAgICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoaHkgPCBteSA/IGh4IDogcXgsIGh5LCBteCwgbXksIGh5IDwgbXkgPyBxeCA6IGh4LCBoeSwgcC54LCBwLnkpKSB7XG5cbiAgICAgICAgICAgIHRhbiA9IE1hdGguYWJzKGh5IC0gcC55KSAvIChoeCAtIHAueCk7IC8vIHRhbmdlbnRpYWxcblxuICAgICAgICAgICAgaWYgKCh0YW4gPCB0YW5NaW4gfHwgKHRhbiA9PT0gdGFuTWluICYmIHAueCA+IG0ueCkpICYmIGxvY2FsbHlJbnNpZGUocCwgaG9sZSkpIHtcbiAgICAgICAgICAgICAgICBtID0gcDtcbiAgICAgICAgICAgICAgICB0YW5NaW4gPSB0YW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBtO1xufVxuXG4vLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG5mdW5jdGlvbiBpbmRleEN1cnZlKHN0YXJ0LCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgdmFyIHAgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLnogPT09IG51bGwpIHAueiA9IHpPcmRlcihwLngsIHAueSwgbWluWCwgbWluWSwgc2l6ZSk7XG4gICAgICAgIHAucHJldlogPSBwLnByZXY7XG4gICAgICAgIHAubmV4dFogPSBwLm5leHQ7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcC5wcmV2Wi5uZXh0WiA9IG51bGw7XG4gICAgcC5wcmV2WiA9IG51bGw7XG5cbiAgICBzb3J0TGlua2VkKHApO1xufVxuXG4vLyBTaW1vbiBUYXRoYW0ncyBsaW5rZWQgbGlzdCBtZXJnZSBzb3J0IGFsZ29yaXRobVxuLy8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcbmZ1bmN0aW9uIHNvcnRMaW5rZWQobGlzdCkge1xuICAgIHZhciBpLCBwLCBxLCBlLCB0YWlsLCBudW1NZXJnZXMsIHBTaXplLCBxU2l6ZSxcbiAgICAgICAgaW5TaXplID0gMTtcblxuICAgIGRvIHtcbiAgICAgICAgcCA9IGxpc3Q7XG4gICAgICAgIGxpc3QgPSBudWxsO1xuICAgICAgICB0YWlsID0gbnVsbDtcbiAgICAgICAgbnVtTWVyZ2VzID0gMDtcblxuICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgICAgbnVtTWVyZ2VzKys7XG4gICAgICAgICAgICBxID0gcDtcbiAgICAgICAgICAgIHBTaXplID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHBTaXplKys7XG4gICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgaWYgKCFxKSBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcVNpemUgPSBpblNpemU7XG5cbiAgICAgICAgICAgIHdoaWxlIChwU2l6ZSA+IDAgfHwgKHFTaXplID4gMCAmJiBxKSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHBTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHFTaXplID09PSAwIHx8ICFxKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBwO1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcFNpemUtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHAueiA8PSBxLnopIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFpbCkgdGFpbC5uZXh0WiA9IGU7XG4gICAgICAgICAgICAgICAgZWxzZSBsaXN0ID0gZTtcblxuICAgICAgICAgICAgICAgIGUucHJldlogPSB0YWlsO1xuICAgICAgICAgICAgICAgIHRhaWwgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwID0gcTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhaWwubmV4dFogPSBudWxsO1xuICAgICAgICBpblNpemUgKj0gMjtcblxuICAgIH0gd2hpbGUgKG51bU1lcmdlcyA+IDEpO1xuXG4gICAgcmV0dXJuIGxpc3Q7XG59XG5cbi8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIHNpemUgb2YgdGhlIGRhdGEgYm91bmRpbmcgYm94XG5mdW5jdGlvbiB6T3JkZXIoeCwgeSwgbWluWCwgbWluWSwgc2l6ZSkge1xuICAgIC8vIGNvb3JkcyBhcmUgdHJhbnNmb3JtZWQgaW50byBub24tbmVnYXRpdmUgMTUtYml0IGludGVnZXIgcmFuZ2VcbiAgICB4ID0gMzI3NjcgKiAoeCAtIG1pblgpIC8gc2l6ZTtcbiAgICB5ID0gMzI3NjcgKiAoeSAtIG1pblkpIC8gc2l6ZTtcblxuICAgIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbn1cblxuLy8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xuZnVuY3Rpb24gZ2V0TGVmdG1vc3Qoc3RhcnQpIHtcbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBsZWZ0bW9zdCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueCA8IGxlZnRtb3N0LngpIGxlZnRtb3N0ID0gcDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gbGVmdG1vc3Q7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9pbnQgbGllcyB3aXRoaW4gYSBjb252ZXggdHJpYW5nbGVcbmZ1bmN0aW9uIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBweCwgcHkpIHtcbiAgICByZXR1cm4gKGN4IC0gcHgpICogKGF5IC0gcHkpIC0gKGF4IC0gcHgpICogKGN5IC0gcHkpID49IDAgJiZcbiAgICAgICAgICAgKGF4IC0gcHgpICogKGJ5IC0gcHkpIC0gKGJ4IC0gcHgpICogKGF5IC0gcHkpID49IDAgJiZcbiAgICAgICAgICAgKGJ4IC0gcHgpICogKGN5IC0gcHkpIC0gKGN4IC0gcHgpICogKGJ5IC0gcHkpID49IDA7XG59XG5cbi8vIGNoZWNrIGlmIGEgZGlhZ29uYWwgYmV0d2VlbiB0d28gcG9seWdvbiBub2RlcyBpcyB2YWxpZCAobGllcyBpbiBwb2x5Z29uIGludGVyaW9yKVxuZnVuY3Rpb24gaXNWYWxpZERpYWdvbmFsKGEsIGIpIHtcbiAgICByZXR1cm4gYS5uZXh0LmkgIT09IGIuaSAmJiBhLnByZXYuaSAhPT0gYi5pICYmICFpbnRlcnNlY3RzUG9seWdvbihhLCBiKSAmJlxuICAgICAgICAgICBsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkgJiYgbWlkZGxlSW5zaWRlKGEsIGIpO1xufVxuXG4vLyBzaWduZWQgYXJlYSBvZiBhIHRyaWFuZ2xlXG5mdW5jdGlvbiBhcmVhKHAsIHEsIHIpIHtcbiAgICByZXR1cm4gKHEueSAtIHAueSkgKiAoci54IC0gcS54KSAtIChxLnggLSBwLngpICogKHIueSAtIHEueSk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXG5mdW5jdGlvbiBlcXVhbHMocDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHNlZ21lbnRzIGludGVyc2VjdFxuZnVuY3Rpb24gaW50ZXJzZWN0cyhwMSwgcTEsIHAyLCBxMikge1xuICAgIGlmICgoZXF1YWxzKHAxLCBxMSkgJiYgZXF1YWxzKHAyLCBxMikpIHx8XG4gICAgICAgIChlcXVhbHMocDEsIHEyKSAmJiBlcXVhbHMocDIsIHExKSkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBhcmVhKHAxLCBxMSwgcDIpID4gMCAhPT0gYXJlYShwMSwgcTEsIHEyKSA+IDAgJiZcbiAgICAgICAgICAgYXJlYShwMiwgcTIsIHAxKSA+IDAgIT09IGFyZWEocDIsIHEyLCBxMSkgPiAwO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xuZnVuY3Rpb24gaW50ZXJzZWN0c1BvbHlnb24oYSwgYikge1xuICAgIHZhciBwID0gYTtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLmkgIT09IGEuaSAmJiBwLm5leHQuaSAhPT0gYS5pICYmIHAuaSAhPT0gYi5pICYmIHAubmV4dC5pICE9PSBiLmkgJiZcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RzKHAsIHAubmV4dCwgYSwgYikpIHJldHVybiB0cnVlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgbG9jYWxseSBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIGxvY2FsbHlJbnNpZGUoYSwgYikge1xuICAgIHJldHVybiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA8IDAgP1xuICAgICAgICBhcmVhKGEsIGIsIGEubmV4dCkgPj0gMCAmJiBhcmVhKGEsIGEucHJldiwgYikgPj0gMCA6XG4gICAgICAgIGFyZWEoYSwgYiwgYS5wcmV2KSA8IDAgfHwgYXJlYShhLCBhLm5leHQsIGIpIDwgMDtcbn1cblxuLy8gY2hlY2sgaWYgdGhlIG1pZGRsZSBwb2ludCBvZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBtaWRkbGVJbnNpZGUoYSwgYikge1xuICAgIHZhciBwID0gYSxcbiAgICAgICAgaW5zaWRlID0gZmFsc2UsXG4gICAgICAgIHB4ID0gKGEueCArIGIueCkgLyAyLFxuICAgICAgICBweSA9IChhLnkgKyBiLnkpIC8gMjtcbiAgICBkbyB7XG4gICAgICAgIGlmICgoKHAueSA+IHB5KSAhPT0gKHAubmV4dC55ID4gcHkpKSAmJiAocHggPCAocC5uZXh0LnggLSBwLngpICogKHB5IC0gcC55KSAvIChwLm5leHQueSAtIHAueSkgKyBwLngpKVxuICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBpbnNpZGU7XG59XG5cbi8vIGxpbmsgdHdvIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGJyaWRnZTsgaWYgdGhlIHZlcnRpY2VzIGJlbG9uZyB0byB0aGUgc2FtZSByaW5nLCBpdCBzcGxpdHMgcG9seWdvbiBpbnRvIHR3bztcbi8vIGlmIG9uZSBiZWxvbmdzIHRvIHRoZSBvdXRlciByaW5nIGFuZCBhbm90aGVyIHRvIGEgaG9sZSwgaXQgbWVyZ2VzIGl0IGludG8gYSBzaW5nbGUgcmluZ1xuZnVuY3Rpb24gc3BsaXRQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgYTIgPSBuZXcgTm9kZShhLmksIGEueCwgYS55KSxcbiAgICAgICAgYjIgPSBuZXcgTm9kZShiLmksIGIueCwgYi55KSxcbiAgICAgICAgYW4gPSBhLm5leHQsXG4gICAgICAgIGJwID0gYi5wcmV2O1xuXG4gICAgYS5uZXh0ID0gYjtcbiAgICBiLnByZXYgPSBhO1xuXG4gICAgYTIubmV4dCA9IGFuO1xuICAgIGFuLnByZXYgPSBhMjtcblxuICAgIGIyLm5leHQgPSBhMjtcbiAgICBhMi5wcmV2ID0gYjI7XG5cbiAgICBicC5uZXh0ID0gYjI7XG4gICAgYjIucHJldiA9IGJwO1xuXG4gICAgcmV0dXJuIGIyO1xufVxuXG4vLyBjcmVhdGUgYSBub2RlIGFuZCBvcHRpb25hbGx5IGxpbmsgaXQgd2l0aCBwcmV2aW91cyBvbmUgKGluIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShpLCB4LCB5LCBsYXN0KSB7XG4gICAgdmFyIHAgPSBuZXcgTm9kZShpLCB4LCB5KTtcblxuICAgIGlmICghbGFzdCkge1xuICAgICAgICBwLnByZXYgPSBwO1xuICAgICAgICBwLm5leHQgPSBwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcC5uZXh0ID0gbGFzdC5uZXh0O1xuICAgICAgICBwLnByZXYgPSBsYXN0O1xuICAgICAgICBsYXN0Lm5leHQucHJldiA9IHA7XG4gICAgICAgIGxhc3QubmV4dCA9IHA7XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOb2RlKHApIHtcbiAgICBwLm5leHQucHJldiA9IHAucHJldjtcbiAgICBwLnByZXYubmV4dCA9IHAubmV4dDtcblxuICAgIGlmIChwLnByZXZaKSBwLnByZXZaLm5leHRaID0gcC5uZXh0WjtcbiAgICBpZiAocC5uZXh0WikgcC5uZXh0Wi5wcmV2WiA9IHAucHJldlo7XG59XG5cbmZ1bmN0aW9uIE5vZGUoaSwgeCwgeSkge1xuICAgIC8vIHZlcnRpY2UgaW5kZXggaW4gY29vcmRpbmF0ZXMgYXJyYXlcbiAgICB0aGlzLmkgPSBpO1xuXG4gICAgLy8gdmVydGV4IGNvb3JkaW5hdGVzXG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgdmVydGljZSBub2RlcyBpbiBhIHBvbHlnb24gcmluZ1xuICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcblxuICAgIC8vIHotb3JkZXIgY3VydmUgdmFsdWVcbiAgICB0aGlzLnogPSBudWxsO1xuXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxuICAgIHRoaXMucHJldlogPSBudWxsO1xuICAgIHRoaXMubmV4dFogPSBudWxsO1xuXG4gICAgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhIHN0ZWluZXIgcG9pbnRcbiAgICB0aGlzLnN0ZWluZXIgPSBmYWxzZTtcbn1cblxuLy8gcmV0dXJuIGEgcGVyY2VudGFnZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHBvbHlnb24gYXJlYSBhbmQgaXRzIHRyaWFuZ3VsYXRpb24gYXJlYTtcbi8vIHVzZWQgdG8gdmVyaWZ5IGNvcnJlY3RuZXNzIG9mIHRyaWFuZ3VsYXRpb25cbmVhcmN1dC5kZXZpYXRpb24gPSBmdW5jdGlvbiAoZGF0YSwgaG9sZUluZGljZXMsIGRpbSwgdHJpYW5nbGVzKSB7XG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoO1xuICAgIHZhciBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcblxuICAgIHZhciBwb2x5Z29uQXJlYSA9IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSkpO1xuICAgIGlmIChoYXNIb2xlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBwb2x5Z29uQXJlYSAtPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRyaWFuZ2xlc0FyZWEgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIGEgPSB0cmlhbmdsZXNbaV0gKiBkaW07XG4gICAgICAgIHZhciBiID0gdHJpYW5nbGVzW2kgKyAxXSAqIGRpbTtcbiAgICAgICAgdmFyIGMgPSB0cmlhbmdsZXNbaSArIDJdICogZGltO1xuICAgICAgICB0cmlhbmdsZXNBcmVhICs9IE1hdGguYWJzKFxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2NdKSAqIChkYXRhW2IgKyAxXSAtIGRhdGFbYSArIDFdKSAtXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbYl0pICogKGRhdGFbYyArIDFdIC0gZGF0YVthICsgMV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9seWdvbkFyZWEgPT09IDAgJiYgdHJpYW5nbGVzQXJlYSA9PT0gMCA/IDAgOlxuICAgICAgICBNYXRoLmFicygodHJpYW5nbGVzQXJlYSAtIHBvbHlnb25BcmVhKSAvIHBvbHlnb25BcmVhKTtcbn07XG5cbmZ1bmN0aW9uIHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0LCBqID0gZW5kIC0gZGltOyBpIDwgZW5kOyBpICs9IGRpbSkge1xuICAgICAgICBzdW0gKz0gKGRhdGFbal0gLSBkYXRhW2ldKSAqIChkYXRhW2kgKyAxXSArIGRhdGFbaiArIDFdKTtcbiAgICAgICAgaiA9IGk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG5cbi8vIHR1cm4gYSBwb2x5Z29uIGluIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgZm9ybSAoZS5nLiBhcyBpbiBHZW9KU09OKSBpbnRvIGEgZm9ybSBFYXJjdXQgYWNjZXB0c1xuZWFyY3V0LmZsYXR0ZW4gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBkaW0gPSBkYXRhWzBdWzBdLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0ge3ZlcnRpY2VzOiBbXSwgaG9sZXM6IFtdLCBkaW1lbnNpb25zOiBkaW19LFxuICAgICAgICBob2xlSW5kZXggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkaW07IGQrKykgcmVzdWx0LnZlcnRpY2VzLnB1c2goZGF0YVtpXVtqXVtkXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBob2xlSW5kZXggKz0gZGF0YVtpIC0gMV0ubGVuZ3RoO1xuICAgICAgICAgICAgcmVzdWx0LmhvbGVzLnB1c2goaG9sZUluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZpZXc7XG4iLCJ2YXIgaGFzaENsZWFyID0gcmVxdWlyZSgnLi9faGFzaENsZWFyJyksXG4gICAgaGFzaERlbGV0ZSA9IHJlcXVpcmUoJy4vX2hhc2hEZWxldGUnKSxcbiAgICBoYXNoR2V0ID0gcmVxdWlyZSgnLi9faGFzaEdldCcpLFxuICAgIGhhc2hIYXMgPSByZXF1aXJlKCcuL19oYXNoSGFzJyksXG4gICAgaGFzaFNldCA9IHJlcXVpcmUoJy4vX2hhc2hTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcbiIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuIiwidmFyIG1hcENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19tYXBDYWNoZUNsZWFyJyksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19tYXBDYWNoZURlbGV0ZScpLFxuICAgIG1hcENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVHZXQnKSxcbiAgICBtYXBDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX21hcENhY2hlSGFzJyksXG4gICAgbWFwQ2FjaGVTZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0O1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKSxcbiAgICBzZXRDYWNoZUFkZCA9IHJlcXVpcmUoJy4vX3NldENhY2hlQWRkJyksXG4gICAgc2V0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19zZXRDYWNoZUhhcycpO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0Q2FjaGU7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2Vha01hcDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUZpbHRlcjtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVNvbWU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbGFtcGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICBpZiAobnVtYmVyID09PSBudW1iZXIpIHtcbiAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbnVtYmVyID0gbnVtYmVyIDw9IHVwcGVyID8gbnVtYmVyIDogdXBwZXI7XG4gICAgfVxuICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBudW1iZXIgPSBudW1iZXIgPj0gbG93ZXIgPyBudW1iZXIgOiBsb3dlcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bWJlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ2xhbXA7XG4iLCJ2YXIgYmFzZUZvck93biA9IHJlcXVpcmUoJy4vX2Jhc2VGb3JPd24nKSxcbiAgICBjcmVhdGVCYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VFYWNoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKi9cbnZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VFYWNoO1xuIiwidmFyIGNyZWF0ZUJhc2VGb3IgPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRm9yJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuIiwidmFyIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvck93bjtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldEFsbEtleXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG4iLCJ2YXIgYmFzZUlzRXF1YWxEZWVwID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWxEZWVwJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWw7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBlcXVhbEJ5VGFnID0gcmVxdWlyZSgnLi9fZXF1YWxCeVRhZycpLFxuICAgIGVxdWFsT2JqZWN0cyA9IHJlcXVpcmUoJy4vX2VxdWFsT2JqZWN0cycpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbERlZXA7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWF0Y2g7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTWFza2VkID0gcmVxdWlyZSgnLi9faXNNYXNrZWQnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCJ2YXIgYmFzZU1hdGNoZXMgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlcycpLFxuICAgIGJhc2VNYXRjaGVzUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlc1Byb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIHByb3BlcnR5ID0gcmVxdWlyZSgnLi9wcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJdGVyYXRlZTtcbiIsInZhciBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5cyA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzSW4gPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzSW4nKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5c0luO1xuIiwidmFyIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWFwO1xuIiwidmFyIGJhc2VJc01hdGNoID0gcmVxdWlyZSgnLi9fYmFzZUlzTWF0Y2gnKSxcbiAgICBnZXRNYXRjaERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXRjaERhdGEnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKSxcbiAgICBnZXQgPSByZXF1aXJlKCcuL2dldCcpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXNQcm9wZXJ0eTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5O1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eURlZXA7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWNoZUhhcztcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0RnVuY3Rpb247XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBzdHJpbmdUb1BhdGggPSByZXF1aXJlKCcuL19zdHJpbmdUb1BhdGgnKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0UGF0aDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG4iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUVhY2g7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheVNvbWUgPSByZXF1aXJlKCcuL19hcnJheVNvbWUnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxBcnJheXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgbWFwVG9BcnJheSA9IHJlcXVpcmUoJy4vX21hcFRvQXJyYXknKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQnlUYWc7XG4iLCJ2YXIgZ2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxPYmplY3RzO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hdGNoRGF0YTtcbiIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmF3VGFnO1xuIiwidmFyIGFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXlGaWx0ZXInKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9scztcbiIsInZhciBEYXRhVmlldyA9IHJlcXVpcmUoJy4vX0RhdGFWaWV3JyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgUHJvbWlzZSA9IHJlcXVpcmUoJy4vX1Byb21pc2UnKSxcbiAgICBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBXZWFrTWFwID0gcmVxdWlyZSgnLi9fV2Vha01hcCcpLFxuICAgIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRhZztcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG4iLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaWN0Q29tcGFyYWJsZTtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFRvQXJyYXk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG4iLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXM7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzSW47XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuIiwiLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVBZGQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVIYXM7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvQXJyYXk7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsInZhciBtZW1vaXplQ2FwcGVkID0gcmVxdWlyZSgnLi9fbWVtb2l6ZUNhcHBlZCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVMZWFkaW5nRG90ID0gL15cXC4vLFxuICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChyZUxlYWRpbmdEb3QudGVzdChzdHJpbmcpKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nVG9QYXRoO1xuIiwidmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0tleTtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcbiIsInZhciBiYXNlQ2xhbXAgPSByZXF1aXJlKCcuL19iYXNlQ2xhbXAnKSxcbiAgICB0b051bWJlciA9IHJlcXVpcmUoJy4vdG9OdW1iZXInKTtcblxuLyoqXG4gKiBDbGFtcHMgYG51bWJlcmAgd2l0aGluIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmNsYW1wKC0xMCwgLTUsIDUpO1xuICogLy8gPT4gLTVcbiAqXG4gKiBfLmNsYW1wKDEwLCAtNSwgNSk7XG4gKiAvLyA9PiA1XG4gKi9cbmZ1bmN0aW9uIGNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdXBwZXIgPSBsb3dlcjtcbiAgICBsb3dlciA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIHVwcGVyID0gdG9OdW1iZXIodXBwZXIpO1xuICAgIHVwcGVyID0gdXBwZXIgPT09IHVwcGVyID8gdXBwZXIgOiAwO1xuICB9XG4gIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbG93ZXIgPSB0b051bWJlcihsb3dlcik7XG4gICAgbG93ZXIgPSBsb3dlciA9PT0gbG93ZXIgPyBsb3dlciA6IDA7XG4gIH1cbiAgcmV0dXJuIGJhc2VDbGFtcCh0b051bWJlcihudW1iZXIpLCBsb3dlciwgdXBwZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYW1wO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIG5vdyA9IHJlcXVpcmUoJy4vbm93JyksXG4gICAgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxhc3RBcmdzLFxuICAgICAgbGFzdFRoaXMsXG4gICAgICBtYXhXYWl0LFxuICAgICAgcmVzdWx0LFxuICAgICAgdGltZXJJZCxcbiAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICByZXN1bHQgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICByZXR1cm4gbWF4aW5nID8gbmF0aXZlTWluKHJlc3VsdCwgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgfVxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICB9XG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9XG4gICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG4iLCIvKipcbiAqIENoZWNrcyBgdmFsdWVgIHRvIGRldGVybWluZSB3aGV0aGVyIGEgZGVmYXVsdCB2YWx1ZSBzaG91bGQgYmUgcmV0dXJuZWQgaW5cbiAqIGl0cyBwbGFjZS4gVGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGBudWxsYCxcbiAqIG9yIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSBUaGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZhdWx0VG8oMSwgMTApO1xuICogLy8gPT4gMVxuICpcbiAqIF8uZGVmYXVsdFRvKHVuZGVmaW5lZCwgMTApO1xuICogLy8gPT4gMTBcbiAqL1xuZnVuY3Rpb24gZGVmYXVsdFRvKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSkgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0VG87XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGNhc3RGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2Nhc3RGdW5jdGlvbicpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGFuXG4gKiBvYmplY3QgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0XG4gKiBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmZvckluUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5mb3JJbihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICovXG5mdW5jdGlvbiBmb3JJbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgID8gb2JqZWN0XG4gICAgOiBiYXNlRm9yKG9iamVjdCwgY2FzdEZ1bmN0aW9uKGl0ZXJhdGVlKSwga2V5c0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JJbjtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xuIiwidmFyIGJhc2VIYXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VIYXNJbicpLFxuICAgIGhhc1BhdGggPSByZXF1aXJlKCcuL19oYXNQYXRoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbjtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iLCJ2YXIgYmFzZUlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Jhc2VJc1R5cGVkQXJyYXknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzSW4gPSByZXF1aXJlKCcuL19iYXNlS2V5c0luJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcbiIsInZhciBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgYmFzZU1hcCA9IHJlcXVpcmUoJy4vX2Jhc2VNYXAnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnVcbiAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICogYF8uZXZlcnlgLCBgXy5maWx0ZXJgLCBgXy5tYXBgLCBgXy5tYXBWYWx1ZXNgLCBgXy5yZWplY3RgLCBhbmQgYF8uc29tZWAuXG4gKlxuICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gKiBgYXJ5YCwgYGNodW5rYCwgYGN1cnJ5YCwgYGN1cnJ5UmlnaHRgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZXZlcnlgLFxuICogYGZpbGxgLCBgaW52ZXJ0YCwgYHBhcnNlSW50YCwgYHJhbmRvbWAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlcGVhdGAsXG4gKiBgc2FtcGxlU2l6ZWAsIGBzbGljZWAsIGBzb21lYCwgYHNvcnRCeWAsIGBzcGxpdGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gKiBgdGVtcGxhdGVgLCBgdHJpbWAsIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGFuZCBgd29yZHNgXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICogICByZXR1cm4gbiAqIG47XG4gKiB9XG4gKlxuICogXy5tYXAoWzQsIDhdLCBzcXVhcmUpO1xuICogLy8gPT4gWzE2LCA2NF1cbiAqXG4gKiBfLm1hcCh7ICdhJzogNCwgJ2InOiA4IH0sIHNxdWFyZSk7XG4gKiAvLyA9PiBbMTYsIDY0XSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICogXTtcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8ubWFwKHVzZXJzLCAndXNlcicpO1xuICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gKi9cbmZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheU1hcCA6IGJhc2VNYXA7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbm93O1xuIiwidmFyIGJhc2VQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eScpLFxuICAgIGJhc2VQcm9wZXJ0eURlZXAgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHlEZWVwJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb3BlcnR5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViQXJyYXk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwidmFyIGRlYm91bmNlID0gcmVxdWlyZSgnLi9kZWJvdW5jZScpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cbiAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRocm90dGxlO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9OdW1iZXI7XG4iLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJ0aWFsU29ydDtcblxuLy8gRmxveWQtUml2ZXN0IHNlbGVjdGlvbiBhbGdvcml0aG06XG4vLyBSZWFycmFuZ2UgaXRlbXMgc28gdGhhdCBhbGwgaXRlbXMgaW4gdGhlIFtsZWZ0LCBrXSByYW5nZSBhcmUgc21hbGxlciB0aGFuIGFsbCBpdGVtcyBpbiAoaywgcmlnaHRdO1xuLy8gVGhlIGstdGggZWxlbWVudCB3aWxsIGhhdmUgdGhlIChrIC0gbGVmdCArIDEpdGggc21hbGxlc3QgdmFsdWUgaW4gW2xlZnQsIHJpZ2h0XVxuXG5mdW5jdGlvbiBwYXJ0aWFsU29ydChhcnIsIGssIGxlZnQsIHJpZ2h0LCBjb21wYXJlKSB7XG4gICAgbGVmdCA9IGxlZnQgfHwgMDtcbiAgICByaWdodCA9IHJpZ2h0IHx8IChhcnIubGVuZ3RoIC0gMSk7XG4gICAgY29tcGFyZSA9IGNvbXBhcmUgfHwgZGVmYXVsdENvbXBhcmU7XG5cbiAgICB3aGlsZSAocmlnaHQgPiBsZWZ0KSB7XG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPiA2MDApIHtcbiAgICAgICAgICAgIHZhciBuID0gcmlnaHQgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciBtID0gayAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgdmFyIHogPSBNYXRoLmxvZyhuKTtcbiAgICAgICAgICAgIHZhciBzID0gMC41ICogTWF0aC5leHAoMiAqIHogLyAzKTtcbiAgICAgICAgICAgIHZhciBzZCA9IDAuNSAqIE1hdGguc3FydCh6ICogcyAqIChuIC0gcykgLyBuKSAqIChtIC0gbiAvIDIgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgIHZhciBuZXdMZWZ0ID0gTWF0aC5tYXgobGVmdCwgTWF0aC5mbG9vcihrIC0gbSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIHZhciBuZXdSaWdodCA9IE1hdGgubWluKHJpZ2h0LCBNYXRoLmZsb29yKGsgKyAobiAtIG0pICogcyAvIG4gKyBzZCkpO1xuICAgICAgICAgICAgcGFydGlhbFNvcnQoYXJyLCBrLCBuZXdMZWZ0LCBuZXdSaWdodCwgY29tcGFyZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdCA9IGFycltrXTtcbiAgICAgICAgdmFyIGkgPSBsZWZ0O1xuICAgICAgICB2YXIgaiA9IHJpZ2h0O1xuXG4gICAgICAgIHN3YXAoYXJyLCBsZWZ0LCBrKTtcbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW3JpZ2h0XSwgdCkgPiAwKSBzd2FwKGFyciwgbGVmdCwgcmlnaHQpO1xuXG4gICAgICAgIHdoaWxlIChpIDwgaikge1xuICAgICAgICAgICAgc3dhcChhcnIsIGksIGopO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyW2ldLCB0KSA8IDApIGkrKztcbiAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGFycltqXSwgdCkgPiAwKSBqLS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcGFyZShhcnJbbGVmdF0sIHQpID09PSAwKSBzd2FwKGFyciwgbGVmdCwgaik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgc3dhcChhcnIsIGosIHJpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqIDw9IGspIGxlZnQgPSBqICsgMTtcbiAgICAgICAgaWYgKGsgPD0gaikgcmlnaHQgPSBqIC0gMTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN3YXAoYXJyLCBpLCBqKSB7XG4gICAgdmFyIHRtcCA9IGFycltpXTtcbiAgICBhcnJbaV0gPSBhcnJbal07XG4gICAgYXJyW2pdID0gdG1wO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJidXNoO1xuXG52YXIgcXVpY2tzZWxlY3QgPSByZXF1aXJlKCdxdWlja3NlbGVjdCcpO1xuXG5mdW5jdGlvbiByYnVzaChtYXhFbnRyaWVzLCBmb3JtYXQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgcmJ1c2gpKSByZXR1cm4gbmV3IHJidXNoKG1heEVudHJpZXMsIGZvcm1hdCk7XG5cbiAgICAvLyBtYXggZW50cmllcyBpbiBhIG5vZGUgaXMgOSBieSBkZWZhdWx0OyBtaW4gbm9kZSBmaWxsIGlzIDQwJSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoaXMuX21heEVudHJpZXMgPSBNYXRoLm1heCg0LCBtYXhFbnRyaWVzIHx8IDkpO1xuICAgIHRoaXMuX21pbkVudHJpZXMgPSBNYXRoLm1heCgyLCBNYXRoLmNlaWwodGhpcy5fbWF4RW50cmllcyAqIDAuNCkpO1xuXG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgICB0aGlzLl9pbml0Rm9ybWF0KGZvcm1hdCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhcigpO1xufVxuXG5yYnVzaC5wcm90b3R5cGUgPSB7XG5cbiAgICBhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbCh0aGlzLmRhdGEsIFtdKTtcbiAgICB9LFxuXG4gICAgc2VhcmNoOiBmdW5jdGlvbiAoYmJveCkge1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICB0b0JCb3ggPSB0aGlzLnRvQkJveDtcblxuICAgICAgICBpZiAoIWludGVyc2VjdHMoYmJveCwgbm9kZSkpIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXSxcbiAgICAgICAgICAgIGksIGxlbiwgY2hpbGQsIGNoaWxkQkJveDtcblxuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNoaWxkQkJveCA9IG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZDtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250YWlucyhiYm94LCBjaGlsZEJCb3gpKSB0aGlzLl9hbGwoY2hpbGQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGNvbGxpZGVzOiBmdW5jdGlvbiAoYmJveCkge1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgdG9CQm94ID0gdGhpcy50b0JCb3g7XG5cbiAgICAgICAgaWYgKCFpbnRlcnNlY3RzKGJib3gsIG5vZGUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXSxcbiAgICAgICAgICAgIGksIGxlbiwgY2hpbGQsIGNoaWxkQkJveDtcblxuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNoaWxkQkJveCA9IG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZDtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZiB8fCBjb250YWlucyhiYm94LCBjaGlsZEJCb3gpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgbG9hZDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCEoZGF0YSAmJiBkYXRhLmxlbmd0aCkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IHRoaXMuX21pbkVudHJpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnQoZGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGJ1aWxkIHRoZSB0cmVlIHdpdGggdGhlIGdpdmVuIGRhdGEgZnJvbSBzdHJhdGNoIHVzaW5nIE9NVCBhbGdvcml0aG1cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9idWlsZChkYXRhLnNsaWNlKCksIDAsIGRhdGEubGVuZ3RoIC0gMSwgMCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRhdGEuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBzYXZlIGFzIGlzIGlmIHRyZWUgaXMgZW1wdHlcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGU7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGEuaGVpZ2h0ID09PSBub2RlLmhlaWdodCkge1xuICAgICAgICAgICAgLy8gc3BsaXQgcm9vdCBpZiB0cmVlcyBoYXZlIHRoZSBzYW1lIGhlaWdodFxuICAgICAgICAgICAgdGhpcy5fc3BsaXRSb290KHRoaXMuZGF0YSwgbm9kZSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuaGVpZ2h0IDwgbm9kZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyBzd2FwIHRyZWVzIGlmIGluc2VydGVkIG9uZSBpcyBiaWdnZXJcbiAgICAgICAgICAgICAgICB2YXIgdG1wTm9kZSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0bXBOb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbnNlcnQgdGhlIHNtYWxsIHRyZWUgaW50byB0aGUgbGFyZ2UgdHJlZSBhdCBhcHByb3ByaWF0ZSBsZXZlbFxuICAgICAgICAgICAgdGhpcy5faW5zZXJ0KG5vZGUsIHRoaXMuZGF0YS5oZWlnaHQgLSBub2RlLmhlaWdodCAtIDEsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGluc2VydDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0pIHRoaXMuX2luc2VydChpdGVtLCB0aGlzLmRhdGEuaGVpZ2h0IC0gMSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGl0ZW0sIGVxdWFsc0ZuKSB7XG4gICAgICAgIGlmICghaXRlbSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICBiYm94ID0gdGhpcy50b0JCb3goaXRlbSksXG4gICAgICAgICAgICBwYXRoID0gW10sXG4gICAgICAgICAgICBpbmRleGVzID0gW10sXG4gICAgICAgICAgICBpLCBwYXJlbnQsIGluZGV4LCBnb2luZ1VwO1xuXG4gICAgICAgIC8vIGRlcHRoLWZpcnN0IGl0ZXJhdGl2ZSB0cmVlIHRyYXZlcnNhbFxuICAgICAgICB3aGlsZSAobm9kZSB8fCBwYXRoLmxlbmd0aCkge1xuXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHsgLy8gZ28gdXBcbiAgICAgICAgICAgICAgICBub2RlID0gcGF0aC5wb3AoKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaSA9IGluZGV4ZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHsgLy8gY2hlY2sgY3VycmVudCBub2RlXG4gICAgICAgICAgICAgICAgaW5kZXggPSBmaW5kSXRlbShpdGVtLCBub2RlLmNoaWxkcmVuLCBlcXVhbHNGbik7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZW0gZm91bmQsIHJlbW92ZSB0aGUgaXRlbSBhbmQgY29uZGVuc2UgdHJlZSB1cHdhcmRzXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25kZW5zZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWdvaW5nVXAgJiYgIW5vZGUubGVhZiAmJiBjb250YWlucyhub2RlLCBiYm94KSkgeyAvLyBnbyBkb3duXG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuWzBdO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudCkgeyAvLyBnbyByaWdodFxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGdvaW5nVXAgPSBmYWxzZTtcblxuICAgICAgICAgICAgfSBlbHNlIG5vZGUgPSBudWxsOyAvLyBub3RoaW5nIGZvdW5kXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdG9CQm94OiBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbTsgfSxcblxuICAgIGNvbXBhcmVNaW5YOiBjb21wYXJlTm9kZU1pblgsXG4gICAgY29tcGFyZU1pblk6IGNvbXBhcmVOb2RlTWluWSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kYXRhOyB9LFxuXG4gICAgZnJvbUpTT046IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfYWxsOiBmdW5jdGlvbiAobm9kZSwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW107XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIG5vZGUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgZWxzZSBub2Rlc1RvU2VhcmNoLnB1c2guYXBwbHkobm9kZXNUb1NlYXJjaCwgbm9kZS5jaGlsZHJlbik7XG5cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIF9idWlsZDogZnVuY3Rpb24gKGl0ZW1zLCBsZWZ0LCByaWdodCwgaGVpZ2h0KSB7XG5cbiAgICAgICAgdmFyIE4gPSByaWdodCAtIGxlZnQgKyAxLFxuICAgICAgICAgICAgTSA9IHRoaXMuX21heEVudHJpZXMsXG4gICAgICAgICAgICBub2RlO1xuXG4gICAgICAgIGlmIChOIDw9IE0pIHtcbiAgICAgICAgICAgIC8vIHJlYWNoZWQgbGVhZiBsZXZlbDsgcmV0dXJuIGxlYWZcbiAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKGl0ZW1zLnNsaWNlKGxlZnQsIHJpZ2h0ICsgMSkpO1xuICAgICAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgICAgLy8gdGFyZ2V0IGhlaWdodCBvZiB0aGUgYnVsay1sb2FkZWQgdHJlZVxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubG9nKE4pIC8gTWF0aC5sb2coTSkpO1xuXG4gICAgICAgICAgICAvLyB0YXJnZXQgbnVtYmVyIG9mIHJvb3QgZW50cmllcyB0byBtYXhpbWl6ZSBzdG9yYWdlIHV0aWxpemF0aW9uXG4gICAgICAgICAgICBNID0gTWF0aC5jZWlsKE4gLyBNYXRoLnBvdyhNLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gY3JlYXRlTm9kZShbXSk7XG4gICAgICAgIG5vZGUubGVhZiA9IGZhbHNlO1xuICAgICAgICBub2RlLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAvLyBzcGxpdCB0aGUgaXRlbXMgaW50byBNIG1vc3RseSBzcXVhcmUgdGlsZXNcblxuICAgICAgICB2YXIgTjIgPSBNYXRoLmNlaWwoTiAvIE0pLFxuICAgICAgICAgICAgTjEgPSBOMiAqIE1hdGguY2VpbChNYXRoLnNxcnQoTSkpLFxuICAgICAgICAgICAgaSwgaiwgcmlnaHQyLCByaWdodDM7XG5cbiAgICAgICAgbXVsdGlTZWxlY3QoaXRlbXMsIGxlZnQsIHJpZ2h0LCBOMSwgdGhpcy5jb21wYXJlTWluWCk7XG5cbiAgICAgICAgZm9yIChpID0gbGVmdDsgaSA8PSByaWdodDsgaSArPSBOMSkge1xuXG4gICAgICAgICAgICByaWdodDIgPSBNYXRoLm1pbihpICsgTjEgLSAxLCByaWdodCk7XG5cbiAgICAgICAgICAgIG11bHRpU2VsZWN0KGl0ZW1zLCBpLCByaWdodDIsIE4yLCB0aGlzLmNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAgICAgZm9yIChqID0gaTsgaiA8PSByaWdodDI7IGogKz0gTjIpIHtcblxuICAgICAgICAgICAgICAgIHJpZ2h0MyA9IE1hdGgubWluKGogKyBOMiAtIDEsIHJpZ2h0Mik7XG5cbiAgICAgICAgICAgICAgICAvLyBwYWNrIGVhY2ggZW50cnkgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2godGhpcy5fYnVpbGQoaXRlbXMsIGosIHJpZ2h0MywgaGVpZ2h0IC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBfY2hvb3NlU3VidHJlZTogZnVuY3Rpb24gKGJib3gsIG5vZGUsIGxldmVsLCBwYXRoKSB7XG5cbiAgICAgICAgdmFyIGksIGxlbiwgY2hpbGQsIHRhcmdldE5vZGUsIGFyZWEsIGVubGFyZ2VtZW50LCBtaW5BcmVhLCBtaW5FbmxhcmdlbWVudDtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IHBhdGgubGVuZ3RoIC0gMSA9PT0gbGV2ZWwpIGJyZWFrO1xuXG4gICAgICAgICAgICBtaW5BcmVhID0gbWluRW5sYXJnZW1lbnQgPSBJbmZpbml0eTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBhcmVhID0gYmJveEFyZWEoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGVubGFyZ2VtZW50ID0gZW5sYXJnZWRBcmVhKGJib3gsIGNoaWxkKSAtIGFyZWE7XG5cbiAgICAgICAgICAgICAgICAvLyBjaG9vc2UgZW50cnkgd2l0aCB0aGUgbGVhc3QgYXJlYSBlbmxhcmdlbWVudFxuICAgICAgICAgICAgICAgIGlmIChlbmxhcmdlbWVudCA8IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkVubGFyZ2VtZW50ID0gZW5sYXJnZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVubGFyZ2VtZW50ID09PSBtaW5FbmxhcmdlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIG9uZSB3aXRoIHRoZSBzbWFsbGVzdCBhcmVhXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSB0YXJnZXROb2RlIHx8IG5vZGUuY2hpbGRyZW5bMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgX2luc2VydDogZnVuY3Rpb24gKGl0ZW0sIGxldmVsLCBpc05vZGUpIHtcblxuICAgICAgICB2YXIgdG9CQm94ID0gdGhpcy50b0JCb3gsXG4gICAgICAgICAgICBiYm94ID0gaXNOb2RlID8gaXRlbSA6IHRvQkJveChpdGVtKSxcbiAgICAgICAgICAgIGluc2VydFBhdGggPSBbXTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBiZXN0IG5vZGUgZm9yIGFjY29tbW9kYXRpbmcgdGhlIGl0ZW0sIHNhdmluZyBhbGwgbm9kZXMgYWxvbmcgdGhlIHBhdGggdG9vXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fY2hvb3NlU3VidHJlZShiYm94LCB0aGlzLmRhdGEsIGxldmVsLCBpbnNlcnRQYXRoKTtcblxuICAgICAgICAvLyBwdXQgdGhlIGl0ZW0gaW50byB0aGUgbm9kZVxuICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goaXRlbSk7XG4gICAgICAgIGV4dGVuZChub2RlLCBiYm94KTtcblxuICAgICAgICAvLyBzcGxpdCBvbiBub2RlIG92ZXJmbG93OyBwcm9wYWdhdGUgdXB3YXJkcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgd2hpbGUgKGxldmVsID49IDApIHtcbiAgICAgICAgICAgIGlmIChpbnNlcnRQYXRoW2xldmVsXS5jaGlsZHJlbi5sZW5ndGggPiB0aGlzLl9tYXhFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BsaXQoaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgICAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBpbnNlcnRpb24gcGF0aFxuICAgICAgICB0aGlzLl9hZGp1c3RQYXJlbnRCQm94ZXMoYmJveCwgaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgIH0sXG5cbiAgICAvLyBzcGxpdCBvdmVyZmxvd2VkIG5vZGUgaW50byB0d29cbiAgICBfc3BsaXQ6IGZ1bmN0aW9uIChpbnNlcnRQYXRoLCBsZXZlbCkge1xuXG4gICAgICAgIHZhciBub2RlID0gaW5zZXJ0UGF0aFtsZXZlbF0sXG4gICAgICAgICAgICBNID0gbm9kZS5jaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgICAgICBtID0gdGhpcy5fbWluRW50cmllcztcblxuICAgICAgICB0aGlzLl9jaG9vc2VTcGxpdEF4aXMobm9kZSwgbSwgTSk7XG5cbiAgICAgICAgdmFyIHNwbGl0SW5kZXggPSB0aGlzLl9jaG9vc2VTcGxpdEluZGV4KG5vZGUsIG0sIE0pO1xuXG4gICAgICAgIHZhciBuZXdOb2RlID0gY3JlYXRlTm9kZShub2RlLmNoaWxkcmVuLnNwbGljZShzcGxpdEluZGV4LCBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIHNwbGl0SW5kZXgpKTtcbiAgICAgICAgbmV3Tm9kZS5oZWlnaHQgPSBub2RlLmhlaWdodDtcbiAgICAgICAgbmV3Tm9kZS5sZWFmID0gbm9kZS5sZWFmO1xuXG4gICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcbiAgICAgICAgY2FsY0JCb3gobmV3Tm9kZSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgIGlmIChsZXZlbCkgaW5zZXJ0UGF0aFtsZXZlbCAtIDFdLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgIGVsc2UgdGhpcy5fc3BsaXRSb290KG5vZGUsIG5ld05vZGUpO1xuICAgIH0sXG5cbiAgICBfc3BsaXRSb290OiBmdW5jdGlvbiAobm9kZSwgbmV3Tm9kZSkge1xuICAgICAgICAvLyBzcGxpdCByb290IG5vZGVcbiAgICAgICAgdGhpcy5kYXRhID0gY3JlYXRlTm9kZShbbm9kZSwgbmV3Tm9kZV0pO1xuICAgICAgICB0aGlzLmRhdGEuaGVpZ2h0ID0gbm9kZS5oZWlnaHQgKyAxO1xuICAgICAgICB0aGlzLmRhdGEubGVhZiA9IGZhbHNlO1xuICAgICAgICBjYWxjQkJveCh0aGlzLmRhdGEsIHRoaXMudG9CQm94KTtcbiAgICB9LFxuXG4gICAgX2Nob29zZVNwbGl0SW5kZXg6IGZ1bmN0aW9uIChub2RlLCBtLCBNKSB7XG5cbiAgICAgICAgdmFyIGksIGJib3gxLCBiYm94Miwgb3ZlcmxhcCwgYXJlYSwgbWluT3ZlcmxhcCwgbWluQXJlYSwgaW5kZXg7XG5cbiAgICAgICAgbWluT3ZlcmxhcCA9IG1pbkFyZWEgPSBJbmZpbml0eTtcblxuICAgICAgICBmb3IgKGkgPSBtOyBpIDw9IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGJib3gxID0gZGlzdEJCb3gobm9kZSwgMCwgaSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgYmJveDIgPSBkaXN0QkJveChub2RlLCBpLCBNLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgICAgIG92ZXJsYXAgPSBpbnRlcnNlY3Rpb25BcmVhKGJib3gxLCBiYm94Mik7XG4gICAgICAgICAgICBhcmVhID0gYmJveEFyZWEoYmJveDEpICsgYmJveEFyZWEoYmJveDIpO1xuXG4gICAgICAgICAgICAvLyBjaG9vc2UgZGlzdHJpYnV0aW9uIHdpdGggbWluaW11bSBvdmVybGFwXG4gICAgICAgICAgICBpZiAob3ZlcmxhcCA8IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG5cbiAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYSA8IG1pbkFyZWEgPyBhcmVhIDogbWluQXJlYTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdmVybGFwID09PSBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIGFyZWFcbiAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuICAgIC8vIHNvcnRzIG5vZGUgY2hpbGRyZW4gYnkgdGhlIGJlc3QgYXhpcyBmb3Igc3BsaXRcbiAgICBfY2hvb3NlU3BsaXRBeGlzOiBmdW5jdGlvbiAobm9kZSwgbSwgTSkge1xuXG4gICAgICAgIHZhciBjb21wYXJlTWluWCA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblggOiBjb21wYXJlTm9kZU1pblgsXG4gICAgICAgICAgICBjb21wYXJlTWluWSA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblkgOiBjb21wYXJlTm9kZU1pblksXG4gICAgICAgICAgICB4TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWCksXG4gICAgICAgICAgICB5TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWSk7XG5cbiAgICAgICAgLy8gaWYgdG90YWwgZGlzdHJpYnV0aW9ucyBtYXJnaW4gdmFsdWUgaXMgbWluaW1hbCBmb3IgeCwgc29ydCBieSBtaW5YLFxuICAgICAgICAvLyBvdGhlcndpc2UgaXQncyBhbHJlYWR5IHNvcnRlZCBieSBtaW5ZXG4gICAgICAgIGlmICh4TWFyZ2luIDwgeU1hcmdpbikgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmVNaW5YKTtcbiAgICB9LFxuXG4gICAgLy8gdG90YWwgbWFyZ2luIG9mIGFsbCBwb3NzaWJsZSBzcGxpdCBkaXN0cmlidXRpb25zIHdoZXJlIGVhY2ggbm9kZSBpcyBhdCBsZWFzdCBtIGZ1bGxcbiAgICBfYWxsRGlzdE1hcmdpbjogZnVuY3Rpb24gKG5vZGUsIG0sIE0sIGNvbXBhcmUpIHtcblxuICAgICAgICBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZSk7XG5cbiAgICAgICAgdmFyIHRvQkJveCA9IHRoaXMudG9CQm94LFxuICAgICAgICAgICAgbGVmdEJCb3ggPSBkaXN0QkJveChub2RlLCAwLCBtLCB0b0JCb3gpLFxuICAgICAgICAgICAgcmlnaHRCQm94ID0gZGlzdEJCb3gobm9kZSwgTSAtIG0sIE0sIHRvQkJveCksXG4gICAgICAgICAgICBtYXJnaW4gPSBiYm94TWFyZ2luKGxlZnRCQm94KSArIGJib3hNYXJnaW4ocmlnaHRCQm94KSxcbiAgICAgICAgICAgIGksIGNoaWxkO1xuXG4gICAgICAgIGZvciAoaSA9IG07IGkgPCBNIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBleHRlbmQobGVmdEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihsZWZ0QkJveCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSBNIC0gbSAtIDE7IGkgPj0gbTsgaS0tKSB7XG4gICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBleHRlbmQocmlnaHRCQm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQpO1xuICAgICAgICAgICAgbWFyZ2luICs9IGJib3hNYXJnaW4ocmlnaHRCQm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXJnaW47XG4gICAgfSxcblxuICAgIF9hZGp1c3RQYXJlbnRCQm94ZXM6IGZ1bmN0aW9uIChiYm94LCBwYXRoLCBsZXZlbCkge1xuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBnaXZlbiB0cmVlIHBhdGhcbiAgICAgICAgZm9yICh2YXIgaSA9IGxldmVsOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgZXh0ZW5kKHBhdGhbaV0sIGJib3gpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jb25kZW5zZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgcGF0aCwgcmVtb3ZpbmcgZW1wdHkgbm9kZXMgYW5kIHVwZGF0aW5nIGJib3hlc1xuICAgICAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxLCBzaWJsaW5nczsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChwYXRoW2ldLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncyA9IHBhdGhbaSAtIDFdLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncy5zcGxpY2Uoc2libGluZ3MuaW5kZXhPZihwYXRoW2ldKSwgMSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy5jbGVhcigpO1xuXG4gICAgICAgICAgICB9IGVsc2UgY2FsY0JCb3gocGF0aFtpXSwgdGhpcy50b0JCb3gpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9pbml0Rm9ybWF0OiBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIC8vIGRhdGEgZm9ybWF0IChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZIGFjY2Vzc29ycylcblxuICAgICAgICAvLyB1c2VzIGV2YWwtdHlwZSBmdW5jdGlvbiBjb21waWxhdGlvbiBpbnN0ZWFkIG9mIGp1c3QgYWNjZXB0aW5nIGEgdG9CQm94IGZ1bmN0aW9uXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGFsZ29yaXRobXMgYXJlIHZlcnkgc2Vuc2l0aXZlIHRvIHNvcnRpbmcgZnVuY3Rpb25zIHBlcmZvcm1hbmNlLFxuICAgICAgICAvLyBzbyB0aGV5IHNob3VsZCBiZSBkZWFkIHNpbXBsZSBhbmQgd2l0aG91dCBpbm5lciBjYWxsc1xuXG4gICAgICAgIHZhciBjb21wYXJlQXJyID0gWydyZXR1cm4gYScsICcgLSBiJywgJzsnXTtcblxuICAgICAgICB0aGlzLmNvbXBhcmVNaW5YID0gbmV3IEZ1bmN0aW9uKCdhJywgJ2InLCBjb21wYXJlQXJyLmpvaW4oZm9ybWF0WzBdKSk7XG4gICAgICAgIHRoaXMuY29tcGFyZU1pblkgPSBuZXcgRnVuY3Rpb24oJ2EnLCAnYicsIGNvbXBhcmVBcnIuam9pbihmb3JtYXRbMV0pKTtcblxuICAgICAgICB0aGlzLnRvQkJveCA9IG5ldyBGdW5jdGlvbignYScsXG4gICAgICAgICAgICAncmV0dXJuIHttaW5YOiBhJyArIGZvcm1hdFswXSArXG4gICAgICAgICAgICAnLCBtaW5ZOiBhJyArIGZvcm1hdFsxXSArXG4gICAgICAgICAgICAnLCBtYXhYOiBhJyArIGZvcm1hdFsyXSArXG4gICAgICAgICAgICAnLCBtYXhZOiBhJyArIGZvcm1hdFszXSArICd9OycpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGZpbmRJdGVtKGl0ZW0sIGl0ZW1zLCBlcXVhbHNGbikge1xuICAgIGlmICghZXF1YWxzRm4pIHJldHVybiBpdGVtcy5pbmRleE9mKGl0ZW0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZXF1YWxzRm4oaXRlbSwgaXRlbXNbaV0pKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vLyBjYWxjdWxhdGUgbm9kZSdzIGJib3ggZnJvbSBiYm94ZXMgb2YgaXRzIGNoaWxkcmVuXG5mdW5jdGlvbiBjYWxjQkJveChub2RlLCB0b0JCb3gpIHtcbiAgICBkaXN0QkJveChub2RlLCAwLCBub2RlLmNoaWxkcmVuLmxlbmd0aCwgdG9CQm94LCBub2RlKTtcbn1cblxuLy8gbWluIGJvdW5kaW5nIHJlY3RhbmdsZSBvZiBub2RlIGNoaWxkcmVuIGZyb20gayB0byBwLTFcbmZ1bmN0aW9uIGRpc3RCQm94KG5vZGUsIGssIHAsIHRvQkJveCwgZGVzdE5vZGUpIHtcbiAgICBpZiAoIWRlc3ROb2RlKSBkZXN0Tm9kZSA9IGNyZWF0ZU5vZGUobnVsbCk7XG4gICAgZGVzdE5vZGUubWluWCA9IEluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1pblkgPSBJbmZpbml0eTtcbiAgICBkZXN0Tm9kZS5tYXhYID0gLUluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gaywgY2hpbGQ7IGkgPCBwOyBpKyspIHtcbiAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICBleHRlbmQoZGVzdE5vZGUsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc3ROb2RlO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgIGEubWluWCA9IE1hdGgubWluKGEubWluWCwgYi5taW5YKTtcbiAgICBhLm1pblkgPSBNYXRoLm1pbihhLm1pblksIGIubWluWSk7XG4gICAgYS5tYXhYID0gTWF0aC5tYXgoYS5tYXhYLCBiLm1heFgpO1xuICAgIGEubWF4WSA9IE1hdGgubWF4KGEubWF4WSwgYi5tYXhZKTtcbiAgICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZU5vZGVNaW5YKGEsIGIpIHsgcmV0dXJuIGEubWluWCAtIGIubWluWDsgfVxuZnVuY3Rpb24gY29tcGFyZU5vZGVNaW5ZKGEsIGIpIHsgcmV0dXJuIGEubWluWSAtIGIubWluWTsgfVxuXG5mdW5jdGlvbiBiYm94QXJlYShhKSAgIHsgcmV0dXJuIChhLm1heFggLSBhLm1pblgpICogKGEubWF4WSAtIGEubWluWSk7IH1cbmZ1bmN0aW9uIGJib3hNYXJnaW4oYSkgeyByZXR1cm4gKGEubWF4WCAtIGEubWluWCkgKyAoYS5tYXhZIC0gYS5taW5ZKTsgfVxuXG5mdW5jdGlvbiBlbmxhcmdlZEFyZWEoYSwgYikge1xuICAgIHJldHVybiAoTWF0aC5tYXgoYi5tYXhYLCBhLm1heFgpIC0gTWF0aC5taW4oYi5taW5YLCBhLm1pblgpKSAqXG4gICAgICAgICAgIChNYXRoLm1heChiLm1heFksIGEubWF4WSkgLSBNYXRoLm1pbihiLm1pblksIGEubWluWSkpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb25BcmVhKGEsIGIpIHtcbiAgICB2YXIgbWluWCA9IE1hdGgubWF4KGEubWluWCwgYi5taW5YKSxcbiAgICAgICAgbWluWSA9IE1hdGgubWF4KGEubWluWSwgYi5taW5ZKSxcbiAgICAgICAgbWF4WCA9IE1hdGgubWluKGEubWF4WCwgYi5tYXhYKSxcbiAgICAgICAgbWF4WSA9IE1hdGgubWluKGEubWF4WSwgYi5tYXhZKTtcblxuICAgIHJldHVybiBNYXRoLm1heCgwLCBtYXhYIC0gbWluWCkgKlxuICAgICAgICAgICBNYXRoLm1heCgwLCBtYXhZIC0gbWluWSk7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGEsIGIpIHtcbiAgICByZXR1cm4gYS5taW5YIDw9IGIubWluWCAmJlxuICAgICAgICAgICBhLm1pblkgPD0gYi5taW5ZICYmXG4gICAgICAgICAgIGIubWF4WCA8PSBhLm1heFggJiZcbiAgICAgICAgICAgYi5tYXhZIDw9IGEubWF4WTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0cyhhLCBiKSB7XG4gICAgcmV0dXJuIGIubWluWCA8PSBhLm1heFggJiZcbiAgICAgICAgICAgYi5taW5ZIDw9IGEubWF4WSAmJlxuICAgICAgICAgICBiLm1heFggPj0gYS5taW5YICYmXG4gICAgICAgICAgIGIubWF4WSA+PSBhLm1pblk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgbGVhZjogdHJ1ZSxcbiAgICAgICAgbWluWDogSW5maW5pdHksXG4gICAgICAgIG1pblk6IEluZmluaXR5LFxuICAgICAgICBtYXhYOiAtSW5maW5pdHksXG4gICAgICAgIG1heFk6IC1JbmZpbml0eVxuICAgIH07XG59XG5cbi8vIHNvcnQgYW4gYXJyYXkgc28gdGhhdCBpdGVtcyBjb21lIGluIGdyb3VwcyBvZiBuIHVuc29ydGVkIGl0ZW1zLCB3aXRoIGdyb3VwcyBzb3J0ZWQgYmV0d2VlbiBlYWNoIG90aGVyO1xuLy8gY29tYmluZXMgc2VsZWN0aW9uIGFsZ29yaXRobSB3aXRoIGJpbmFyeSBkaXZpZGUgJiBjb25xdWVyIGFwcHJvYWNoXG5cbmZ1bmN0aW9uIG11bHRpU2VsZWN0KGFyciwgbGVmdCwgcmlnaHQsIG4sIGNvbXBhcmUpIHtcbiAgICB2YXIgc3RhY2sgPSBbbGVmdCwgcmlnaHRdLFxuICAgICAgICBtaWQ7XG5cbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHJpZ2h0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGxlZnQgPSBzdGFjay5wb3AoKTtcblxuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0IDw9IG4pIGNvbnRpbnVlO1xuXG4gICAgICAgIG1pZCA9IGxlZnQgKyBNYXRoLmNlaWwoKHJpZ2h0IC0gbGVmdCkgLyBuIC8gMikgKiBuO1xuICAgICAgICBxdWlja3NlbGVjdChhcnIsIG1pZCwgbGVmdCwgcmlnaHQsIGNvbXBhcmUpO1xuXG4gICAgICAgIHN0YWNrLnB1c2gobGVmdCwgbWlkLCBtaWQsIHJpZ2h0KTtcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGV2ZW50LlxuICovXG5jbGFzcyBFdmVudCB7XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBFdmVudCBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBUaGUgb2JqZWN0IHRoYXQgZmlyZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gVGhlIHRpbWVzdGFtcCB3aGVuIHRoZSBldmVudCB3YXMgY3JlYXRlZC4gT3B0aW9uYWwuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih0YXJnZXQsIHRpbWVzdGFtcCA9IERhdGUubm93KCkpIHtcblx0XHR0aGlzLnRhcmdldCA9IHRhcmdldDtcblx0XHR0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBldmVudCBicm9hZGNhc3Rlci5cbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEV2ZW50QnJvYWRjYXN0ZXIge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgRXZlbnRCcm9hZGNhc3RlciBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UGxvdH0gcGxvdCAtIFRoZSBwbG90IHRvIGF0dGFjaCB0aGUgYnJvYWRjYXN0ZXIgdG8uXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihwbG90KSB7XG5cdFx0dGhpcy5wbG90ID0gcGxvdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBCcm9hZGNhc3RzIHRoZSBwcm92aWRlZCBldmVudCB0eXBlIHRvIGFsbCBjaGlsZHJlbiBvZiB0aGUgcGxvdC5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgZXZlbnQgdHlwZSB0byBicm9hZGNhc3QuXG5cdCAqL1xuXHRicm9hZGNhc3QodHlwZSkge1xuXHRcdHRoaXMucGxvdC5vbih0eXBlLCBldmVudCA9PiB7XG5cdFx0XHRjb25zdCBjaGlsZHJlbiA9IHRoaXMucGxvdC5nZXRTb3J0ZWRMYXllcnMoKTtcblx0XHRcdGZvciAobGV0IGk9Y2hpbGRyZW4ubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuXHRcdFx0XHRpZiAoIWNoaWxkcmVuW2ldLmlzSGlkZGVuKCkpIHtcblx0XHRcdFx0XHRjaGlsZHJlbltpXS5lbWl0KHR5cGUsIGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRCcm9hZGNhc3RlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRUeXBlID0gcmVxdWlyZSgnLi9FdmVudFR5cGUnKTtcbmNvbnN0IE1vdXNlRXZlbnQgPSByZXF1aXJlKCcuL01vdXNlRXZlbnQnKTtcblxuY29uc3Qgc2V0Q3Vyc29yID0gZnVuY3Rpb24ocGxvdCkge1xuXHRwbG90LmdldENvbnRhaW5lcigpLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbn07XG5cbmNvbnN0IHJlc2V0Q3Vyc29yID0gZnVuY3Rpb24ocGxvdCkge1xuXHRwbG90LmdldENvbnRhaW5lcigpLnN0eWxlLmN1cnNvciA9ICdpbmhlcml0Jztcbn07XG5cbmNvbnN0IGNvcHlFdmVudCA9IGZ1bmN0aW9uKHRhcmdldCwgZGF0YSwgZXZlbnQpIHtcblx0cmV0dXJuIG5ldyBNb3VzZUV2ZW50KFxuXHRcdHRhcmdldCxcblx0XHRldmVudC5vcmlnaW5hbEV2ZW50LFxuXHRcdHsgeDogZXZlbnQucG9zLngsIHk6IGV2ZW50LnBvcy55IH0sXG5cdFx0eyB4OiBldmVudC5weC54LCB5OiBldmVudC5weC55IH0sXG5cdFx0ZGF0YSk7XG59O1xuXG5jb25zdCBkZWxlZ2F0ZU1vdXNlTW92ZSA9IGZ1bmN0aW9uKGRlbGVnYXRvciwgY2hpbGQsIGV2ZW50LCBjb2xsaXNpb24pIHtcblx0Ly8gY3JlYXRlIGV2ZW50cyB0byBkZWxlZ2F0ZVxuXHRjb25zdCBkZWxlZ2F0aW9ucyA9IFtdO1xuXHRjb25zdCBwcmV2ID0gZGVsZWdhdG9yLnByZXZNb3VzZW92ZXI7XG5cblx0aWYgKCFjb2xsaXNpb24pIHtcblx0XHQvLyAgbm8gY29sbGlzaW9uXG5cblx0XHQvLyBjaGVjayBmb3IgcHJldlxuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHQvLyBjbGVhciBjdXJzb3Igc3R5bGVcblx0XHRcdHJlc2V0Q3Vyc29yKGRlbGVnYXRvci5wbG90KTtcblx0XHRcdC8vIHVuLWhpZ2hsaWdodCBwcmV2aW91cyB0YXJnZXRcblx0XHRcdHByZXYudGFyZ2V0LnVuaGlnaGxpZ2h0KCk7XG5cdFx0XHQvLyBgbW91c2VvdXRgIG9uIHByZXZpb3VzIHRhcmdldFxuXHRcdFx0ZGVsZWdhdGlvbnMucHVzaCh7XG5cdFx0XHRcdHR5cGU6IEV2ZW50VHlwZS5NT1VTRV9PVVQsXG5cdFx0XHRcdGV2ZW50OiBjb3B5RXZlbnQocHJldi50YXJnZXQsIHByZXYuZGF0YSwgcHJldilcblx0XHRcdH0pO1xuXHRcdFx0Ly8gdW5mbGFnIGFzIHByZXYgYG1vdXNlb3ZlcmAgdGFyZ2V0XG5cdFx0XHRkZWxlZ2F0b3IucHJldk1vdXNlb3ZlciA9IG51bGw7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cdFx0Ly8gY29sbGlzaW9uXG5cblx0XHQvLyBjaGVjayBmb3IgcHJldlxuXHRcdGlmIChwcmV2ICYmIHByZXYuZGF0YSAhPT0gY29sbGlzaW9uKSB7XG5cdFx0XHQvLyB1bi1oaWdobGlnaHQgcHJldmlvdXMgdGFyZ2V0XG5cdFx0XHRwcmV2LnRhcmdldC51bmhpZ2hsaWdodCgpO1xuXHRcdFx0Ly8gYG1vdXNlb3V0YCBvbiBwcmV2aW91cyB0YXJnZXRcblx0XHRcdGRlbGVnYXRpb25zLnB1c2goe1xuXHRcdFx0XHR0eXBlOiBFdmVudFR5cGUuTU9VU0VfT1VULFxuXHRcdFx0XHRldmVudDogY29weUV2ZW50KHByZXYudGFyZ2V0LCBwcmV2LmRhdGEsIHByZXYpXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBgbW91c2Vtb3ZlYCBvbiBjdXJyZW50IHRhcmdldFxuXHRcdGRlbGVnYXRpb25zLnB1c2goe1xuXHRcdFx0dHlwZTogRXZlbnRUeXBlLk1PVVNFX01PVkUsXG5cdFx0XHRldmVudDogY29weUV2ZW50KGNoaWxkLCBjb2xsaXNpb24sIGV2ZW50KVxuXHRcdH0pO1xuXG5cdFx0Ly8gc2V0IGN1cnNvciBmb3IgaG92ZXJcblx0XHRzZXRDdXJzb3IoZGVsZWdhdG9yLnBsb3QpO1xuXG5cdFx0Ly8gaGlnaGxpZ2h0XG5cdFx0Y2hpbGQuaGlnaGxpZ2h0KGNvbGxpc2lvbik7XG5cblx0XHRpZiAoIXByZXYgfHwgcHJldi5kYXRhICE9PSBjb2xsaXNpb24pIHtcblx0XHRcdC8vIGBtb3VzZW92ZXJgIG9uIGN1cnJlbnRcblx0XHRcdGRlbGVnYXRpb25zLnB1c2goe1xuXHRcdFx0XHR0eXBlOiBFdmVudFR5cGUuTU9VU0VfT1ZFUixcblx0XHRcdFx0ZXZlbnQ6IGNvcHlFdmVudChjaGlsZCwgY29sbGlzaW9uLCBldmVudClcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIGZsYWcgYXMgcHJldiBgbW91c2VvdmVyYFxuXHRcdGRlbGVnYXRvci5wcmV2TW91c2VvdmVyID0gZGVsZWdhdGlvbnNbZGVsZWdhdGlvbnMubGVuZ3RoLTFdLmV2ZW50O1xuXHR9XG5cblx0cmV0dXJuIGRlbGVnYXRpb25zO1xufTtcblxuY29uc3QgZGVsZWdhdGVNb3VzZVVwID0gZnVuY3Rpb24oZGVsZWdhdG9yLCBjaGlsZCwgZXZlbnQsIGNvbGxpc2lvbikge1xuXHRpZiAoY29sbGlzaW9uKSB7XG5cdFx0cmV0dXJuIFt7XG5cdFx0XHR0eXBlOiBFdmVudFR5cGUuTU9VU0VfVVAsXG5cdFx0XHRldmVudDogY29weUV2ZW50KGNoaWxkLCBjb2xsaXNpb24sIGV2ZW50KVxuXHRcdH1dO1xuXHR9XG5cdHJldHVybiBbXTtcbn07XG5cbmNvbnN0IGRlbGVnYXRlTW91c2VEb3duID0gZnVuY3Rpb24oZGVsZWdhdG9yLCBjaGlsZCwgZXZlbnQsIGNvbGxpc2lvbikge1xuXHRpZiAoY29sbGlzaW9uKSB7XG5cdFx0cmV0dXJuIFt7XG5cdFx0XHR0eXBlOiBFdmVudFR5cGUuTU9VU0VfRE9XTixcblx0XHRcdGV2ZW50OiBjb3B5RXZlbnQoY2hpbGQsIGNvbGxpc2lvbiwgZXZlbnQpXG5cdFx0fV07XG5cdH1cblx0cmV0dXJuIFtdO1xufTtcblxuY29uc3QgZGVsZWdhdGVDbGljayA9IGZ1bmN0aW9uKGRlbGVnYXRvciwgY2hpbGQsIGV2ZW50LCBjb2xsaXNpb24pIHtcblx0Ly8gY2hlY2sgaWYgbXVsdGktc2VsZWN0IGlzIGVuYWJsZWRcblx0Y29uc3QgbXVsdGlTZWxlY3QgPSBldmVudC5vcmlnaW5hbEV2ZW50LmN0cmxLZXkgfHwgZXZlbnQub3JpZ2luYWxFdmVudC5tZXRhS2V5O1xuXHRpZiAoY29sbGlzaW9uKSB7XG5cblx0XHQvLyBzZWxlY3Rcblx0XHRpZiAoIWNoaWxkLmlzU2VsZWN0ZWQoY29sbGlzaW9uKSkge1xuXHRcdFx0aWYgKCFtdWx0aVNlbGVjdCkge1xuXHRcdFx0XHQvLyBpZiBub3QgbXVsdGktc2VsZWN0LCB1bnNlbGVjdCB0aGUgZGF0YSBwcmV2IHNlbGVjdGVkIGRhdGFcblx0XHRcdFx0ZGVsZWdhdG9yLnByZXZDbGljay5mb3JFYWNoKHByZXYgPT4ge1xuXHRcdFx0XHRcdHByZXYudGFyZ2V0LnVuc2VsZWN0QWxsKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRkZWxlZ2F0b3IucHJldkNsaWNrID0gW107XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiBub3QgYWxyZWFkeSBzZWxlY3RlZCwgYWRkIHRvIHNlbGVjdGlvblxuXHRcdFx0Y2hpbGQuc2VsZWN0KGNvbGxpc2lvbiwgbXVsdGlTZWxlY3QpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAobXVsdGlTZWxlY3QpIHtcblx0XHRcdFx0Ly8gcmVtb3ZlIGlmIGFscmVhZHkgc2VsZWN0ZWRcblx0XHRcdFx0Y2hpbGQudW5zZWxlY3QoY29sbGlzaW9uKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gYGNsaWNrYCBldmVudFxuXHRcdGNvbnN0IGRlbGVnYXRpb24gPSB7XG5cdFx0XHR0eXBlOiBFdmVudFR5cGUuQ0xJQ0ssXG5cdFx0XHRldmVudDogY29weUV2ZW50KGNoaWxkLCBjb2xsaXNpb24sIGV2ZW50KVxuXHRcdH07XG5cdFx0Ly8gZmxhZyBhcyBwcmV2IGBjbGlja2AgdGFyZ2V0XG5cdFx0ZGVsZWdhdG9yLnByZXZDbGljay5wdXNoKGRlbGVnYXRpb24uZXZlbnQpO1xuXHRcdC8vIHJldHVybiBkZWxlZ2F0aW9uXG5cdFx0cmV0dXJuIFsgZGVsZWdhdGlvbiBdO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRpZiAoZGVsZWdhdG9yLnByZXZDbGljay5sZW5ndGggPiAwKSB7XG5cdFx0XHRpZiAobXVsdGlTZWxlY3QpIHtcblx0XHRcdFx0Ly8gaWYgbXVsdGktc2VsZWN0IGlzIGhlbGQsIGRvbid0IGNsZWFyIHNlbGVjdGlvbiwgYXNzdW1lIHRoZVxuXHRcdFx0XHQvLyB1c2VyIG1heSBoYXZlIG1pc2NsaWNrZWRcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdW5zZWxlY3QgdGhlIGRhdGFcblx0XHRcdGRlbGVnYXRvci5wcmV2Q2xpY2suZm9yRWFjaChwcmV2ID0+IHtcblx0XHRcdFx0cHJldi50YXJnZXQudW5zZWxlY3RBbGwoKTtcblx0XHRcdH0pO1xuXHRcdFx0Ly8gdW5mbGFnIGFzIHByZXYgYGNsaWNrYCB0YXJnZXRcblx0XHRcdGRlbGVnYXRvci5wcmV2Q2xpY2sgPSBbXTtcblx0XHR9XG5cblx0fVxuXHRyZXR1cm4gW107XG59O1xuXG5jb25zdCBkZWxlZ2F0ZURibENsaWNrID0gZnVuY3Rpb24oZGVsZWdhdG9yLCBjaGlsZCwgZXZlbnQsIGNvbGxpc2lvbikge1xuXHRpZiAoY29sbGlzaW9uKSB7XG5cdFx0cmV0dXJuIFt7XG5cdFx0XHR0eXBlOiBFdmVudFR5cGUuREJMX0NMSUNLLFxuXHRcdFx0ZXZlbnQ6IGNvcHlFdmVudChjaGlsZCwgY29sbGlzaW9uLCBldmVudClcblx0XHR9XTtcblx0fVxuXHRyZXR1cm4gW107XG59O1xuXG5jb25zdCBERUxFR0FUSU9OX0ZVTkNTID0ge1xuXHRbRXZlbnRUeXBlLk1PVVNFX01PVkVdOiBkZWxlZ2F0ZU1vdXNlTW92ZSxcblx0W0V2ZW50VHlwZS5NT1VTRV9VUF06IGRlbGVnYXRlTW91c2VVcCxcblx0W0V2ZW50VHlwZS5NT1VTRV9ET1dOXTogZGVsZWdhdGVNb3VzZURvd24sXG5cdFtFdmVudFR5cGUuQ0xJQ0tdOiBkZWxlZ2F0ZUNsaWNrLFxuXHRbRXZlbnRUeXBlLkRCTF9DTElDS106IGRlbGVnYXRlRGJsQ2xpY2ssXG59O1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBldmVudCBkZWxlZ2F0b3IuXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBFdmVudERlbGVnYXRvciB7XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBFdmVudERlbGVnYXRvciBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UGxvdH0gcGxvdCAtIFRoZSBwbG90IHRvIGF0dGFjaCB0aGUgaGFuZGxlciB0by5cblx0ICovXG5cdGNvbnN0cnVjdG9yKHBsb3QpIHtcblx0XHR0aGlzLnBsb3QgPSBwbG90O1xuXHRcdHRoaXMucHJldkNsaWNrID0gW107XG5cdFx0dGhpcy5wcmV2TW91c2VvdmVyID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWxlZ2F0ZXMgdGhlIHByb3ZpZGVkIGV2ZW50IHR5cGUgdG8gYWxsIGNoaWxkcmVuIG9mIHRoZSBwbG90LlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBldmVudCB0eXBlIHRvIGRlbGVnYXRlLlxuXHQgKi9cblx0ZGVsZWdhdGUodHlwZSkge1xuXHRcdC8vIGdldCBhcHByb3ByaWF0ZSBkZWxlZ2F0aW9uIGZ1bmN0aW9uXG5cdFx0Y29uc3QgZnVuYyA9IERFTEVHQVRJT05fRlVOQ1NbdHlwZV07XG5cdFx0aWYgKCFmdW5jKSB7XG5cdFx0XHR0aHJvdyBgRGVsZWdhdGlvbiBmb3IgZXZlbnQgdHlwZSAke3R5cGV9IGlzIG5vdCBzdXBwb3J0ZWRgO1xuXHRcdH1cblx0XHQvLyBhdHRhY2ggZGVsZWdhdGlvbiBoYW5kbGVyXG5cdFx0dGhpcy5wbG90Lm9uKHR5cGUsIGV2ZW50ID0+IHtcblx0XHRcdC8vIGdldCBjaGlsZHJlbiBzb3J0ZWQgYnkgei1pbmRleFxuXHRcdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLnBsb3QuZ2V0U29ydGVkTGF5ZXJzKCk7XG5cdFx0XHQvLyBwaWNrIGNoaWxkcmVuLCBieSBwcmlvcml0eVxuXHRcdFx0bGV0IGNvbGxpc2lvbiA9IG51bGw7XG5cdFx0XHRsZXQgY2hpbGQgPSBudWxsO1xuXHRcdFx0Zm9yIChsZXQgaT1jaGlsZHJlbi5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG5cdFx0XHRcdGlmICghY2hpbGRyZW5baV0uaXNIaWRkZW4oKSkge1xuXHRcdFx0XHRcdGNvbGxpc2lvbiA9IGNoaWxkcmVuW2ldLnBpY2soZXZlbnQucG9zKTtcblx0XHRcdFx0XHRpZiAoY29sbGlzaW9uKSB7XG5cdFx0XHRcdFx0XHRjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBkZWxlZ2F0ZSB1c2luZyBwcm92aWRlZCBmdW5jXG5cdFx0XHRjb25zdCBkZWxlZ2F0aW9ucyA9IGZ1bmModGhpcywgY2hpbGQsIGV2ZW50LCBjb2xsaXNpb24pO1xuXHRcdFx0Ly8gZGVsZWdhdGUgdGhlIGFjY3VtdWxhdGVkIGV2ZW50c1xuXHRcdFx0Zm9yIChsZXQgaT0wOyBpPGRlbGVnYXRpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGRlbGVnYXRpb24gPSBkZWxlZ2F0aW9uc1tpXTtcblx0XHRcdFx0ZGVsZWdhdGlvbi5ldmVudC50YXJnZXQuZW1pdChkZWxlZ2F0aW9uLnR5cGUsIGRlbGVnYXRpb24uZXZlbnQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnREZWxlZ2F0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRXZlbnQgdHlwZSBzdHJpbmcgY29uc3RhbnRzLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuXHQvKipcblx0ICogRW1pdHRlZCB3aGVuIHRoZSBwbG90IGlzIGNsaWNrZWQuXG5cdCAqIEBjb25zdGFudCB7c3RyaW5nfVxuXHQgKi9cblx0Q0xJQ0s6ICdjbGljaycsXG5cblx0LyoqXG5cdCAqIEVtaXR0ZWQgd2hlbiB0aGUgcGxvdCBpcyBkb3VibGUgY2xpY2tlZC5cblx0ICogQGNvbnN0YW50IHtzdHJpbmd9XG5cdCAqL1xuXHREQkxfQ0xJQ0s6ICdkYmxjbGljaycsXG5cblx0LyoqXG5cdCAqIEVtaXR0ZWQgd2hlbiBhIG1vdXNlIGJ1dHRvbiBpcyBwcmVzc2VkLlxuXHQgKiBAY29uc3RhbnQge3N0cmluZ31cblx0ICovXG5cdE1PVVNFX0RPV046ICdtb3VzZWRvd24nLFxuXG5cdC8qKlxuXHQgKiBFbWl0dGVkIHdoZW4gYSBtb3VzZSBidXR0b24gaXMgcmVsZWFzZWQuXG5cdCAqIEBjb25zdGFudCB7c3RyaW5nfVxuXHQgKi9cblx0TU9VU0VfVVA6ICdtb3VzZXVwJyxcblxuXHQvKipcblx0ICogRW1pdHRlZCB3aGVuIHRoZSBtb3VzZSBpcyBtb3ZlZCBvbiB0aGUgdGFyZ2V0LlxuXHQgKiBAY29uc3RhbnQge3N0cmluZ31cblx0ICovXG5cdE1PVVNFX01PVkU6ICdtb3VzZW1vdmUnLFxuXG5cdC8qKlxuXHQgKiBFbWl0dGVkIHdoZW4gdGhlIG1vdXNlIGlzIG1vdmVkIG9udG8gdGhlIHRhcmdldC5cblx0ICogQGNvbnN0YW50IHtzdHJpbmd9XG5cdCAqL1xuXHRNT1VTRV9PVkVSOiAnbW91c2VvdmVyJyxcblxuXHQvKipcblx0ICogRW1pdHRlZCB3aGVuIHRoZSBtb3VzZSBpcyBtb3ZlZCBvdXQgb2YgdGhlIHRhcmdldC5cblx0ICogQGNvbnN0YW50IHtzdHJpbmd9XG5cdCAqL1xuXHRNT1VTRV9PVVQ6ICdtb3VzZW91dCcsXG5cblx0LyoqXG5cdCAqIEVtaXR0ZWQgd2hlbiBhIG5ldyBwYW4gZXZlbnQgaXMgaGFuZGxlZC5cblx0ICogQGNvbnN0YW50IHtzdHJpbmd9XG5cdCAqL1xuXHRQQU5fU1RBUlQ6ICdwYW5zdGFydCcsXG5cblx0LyoqXG5cdCAqIEVtaXR0ZWQgZHVyaW5nIGVhY2ggZnJhbWUgb2YgYSBwYW4gYW5pbWF0aW9uLlxuXHQgKiBAY29uc3RhbnQge3N0cmluZ31cblx0ICovXG5cdFBBTjogJ3BhbicsXG5cblx0LyoqXG5cdCAqIEVtaXR0ZWQgb24gdGhlIGZpbmFsIGZyYW1lIG9mIGEgcGFuIGFuaW1hdGlvbi5cblx0ICogQGNvbnN0YW50IHtzdHJpbmd9XG5cdCAqL1xuXHRQQU5fRU5EOiAncGFuZW5kJyxcblxuXHQvKipcblx0ICogRW1pdHRlZCB3aGVuIGEgbmV3IHpvb20gZXZlbnQgaXMgaGFuZGxlZC5cblx0ICogQGNvbnN0YW50IHtzdHJpbmd9XG5cdCAqL1xuXHRaT09NX1NUQVJUOiAnem9vbXN0YXJ0JyxcblxuXHQvKipcblx0ICogRW1pdHRlZCBkdXJpbmcgZWFjaCBmcmFtZSBvZiBhIHpvb20gYW5pbWF0aW9uLlxuXHQgKiBAY29uc3RhbnQge3N0cmluZ31cblx0ICovXG5cdFpPT006ICd6b29tJyxcblxuXHQvKipcblx0ICogRW1pdHRlZCBvbiB0aGUgZmluYWwgZnJhbWUgb2YgYSB6b29tIGFuaW1hdGlvbi5cblx0ICogQGNvbnN0YW50IHtzdHJpbmd9XG5cdCAqL1xuXHRaT09NX0VORDogJ3pvb21lbmQnLFxuXG5cdC8qKlxuXHQgKiBFbWl0dGVkIGJlZm9yZSBwcm9jZXNzaW5nIGEgbmV3IGZyYW1lLlxuXHQgKiBAY29uc3RhbnQge3N0cmluZ31cblx0ICovXG5cdEZSQU1FOiAnZnJhbWUnLFxuXG5cdC8qKlxuXHQgKiBFbWl0dGVkIHdoZW4gcHJvY2Vzc2luZyBhIHJlc2l6ZSBldmVudC5cblx0ICogQGNvbnN0YW50IHtzdHJpbmd9XG5cdCAqL1xuXHRSRVNJWkU6ICdyZXNpemUnLFxuXG5cdC8qKlxuXHQgKiBFbWl0dGVkIHdoZW4gdGhlIHZpZXdpbmcgY2VsbCBvZiB0aGUgcGxvdCBpcyB1cGRhdGVkLlxuXHQgKiBAY29uc3RhbnQge3N0cmluZ31cblx0ICovXG5cdENFTExfVVBEQVRFOiAnY2VsbHVwZGF0ZScsXG5cblx0LyoqXG5cdCAqIEVtaXR0ZWQgd2hlbiB0aGUgbGF5ZXIgaXMgcmVmcmVzaGVkLlxuXHQgKiBAY29uc3RhbnQge3N0cmluZ31cblx0ICovXG5cdFJFRlJFU0g6ICdyZWZyZXNoJyxcblxuXHQvKipcblx0ICogRW1pdHRlZCB3aGVuIGFuIGluaXRpYWwgcmVxdWVzdCBmb3IgYSB0aWxlIGlzIG1hZGUsIHRoZSB0aWxlIGlzIG5vdFxuXHQgKiB5ZXQgcGFydCBvZiB0aGUgbGF5ZXIgYW5kIGhhcyBub3QgeWV0IGJlZW4gcmVxdWVzdGVkLlxuXHQgKiBAY29uc3RhbnQge3N0cmluZ31cblx0ICovXG5cdFRJTEVfUkVRVUVTVDogJ3RpbGVyZXF1ZXN0JyxcblxuXHQvKipcblx0ICogRW1pdHRlZCB3aGVuIGEgdGlsZSByZXF1ZXN0IGNvbXBsZXRlcyB1bnN1Y2Nlc3NmdWxseS4gVGhlIHRpbGUgaXMgbm90XG5cdCAqIGFkZGVkIHRvIHRoZSBsYXllci5cblx0ICogQGNvbnN0YW50IHtzdHJpbmd9XG5cdCAqL1xuXHRUSUxFX0ZBSUxVUkU6ICd0aWxlZmFpbHVyZScsXG5cblx0LyoqXG5cdCAqIEVtaXR0ZWQgd2hlbiBhIHRpbGUgcmVxdWVzdCBjb21wbGV0ZXMgc3VjY2Vzc2Z1bGx5LiBUaGUgdGlsZSBpcyBhZGRlZFxuXHQgKiB0byB0aGUgbGF5ZXIuXG5cdCAqIEBjb25zdGFudCB7c3RyaW5nfVxuXHQgKi9cblx0VElMRV9BREQ6ICd0aWxlYWRkJyxcblxuXHQvKipcblx0ICogRW1pdHRlZCB3aGVuIGEgdGlsZSByZXF1ZXN0IGNvbXBsZXRlcyBzdWNjZXNzZnVsbHkgYnV0IHRoZSB0aWxlIGlzIG5vXG5cdCAqIGxvbmdlciBpbiB2aWV3LiBUaGUgdGlsZSBpcyBub3QgYWRkZWQgdG8gdGhlIGxheWVyLlxuXHQgKiBAY29uc3RhbnQge3N0cmluZ31cblx0ICovXG5cdFRJTEVfRElTQ0FSRDogJ3RpbGVkaXNjYXJkJyxcblxuXHQvKipcblx0ICogRW1pdHRlZCB3aGVuIGEgdGlsZSBpcyBldmljdGVkIGZyb20gdGhlIGludGVybmFsIExSVSBjYWNoZS5cblx0ICogQGNvbnN0YW50IHtzdHJpbmd9XG5cdCAqL1xuXHRUSUxFX1JFTU9WRTogJ3RpbGVyZW1vdmUnLFxuXG5cdC8qKlxuXHQgKiBFbWl0dGVkIHdoZW4gYWxsIHZpc2libGUgdGlsZXMgaGF2ZSBiZWVuIGxvYWRlZCBmb3IgYSBsYXllci5cblx0ICogQGNvbnN0YW50IHtzdHJpbmd9XG5cdCAqL1xuXHRMT0FEOiAnbG9hZCdcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50ID0gcmVxdWlyZSgnLi9FdmVudCcpO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIG1vdXNlIGV2ZW50LlxuICovXG5jbGFzcyBNb3VzZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgTW91c2VFdmVudCBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBUaGUgb2JqZWN0IHRoYXQgZmlyZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBUaGUgb3JpZ2luYWwgRE9NIG1vdXNlIGV2ZW50IGZpcmVkIGJ5IHRoZSBicm93c2VyLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcG9zIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBtb3VzZSBldmVudCBpbiBwbG90IGNvb3JkaW5hdGVzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHggLSBUaGUgcG9zaXRpb24gb2YgdGhlIG1vdXNlIGV2ZW50IGluIHZpZXdwb3J0IHBpeGVsIGNvb3JkaW5hdGVzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih0YXJnZXQsIGV2ZW50LCBwb3MsIHB4LCBkYXRhID0gbnVsbCkge1xuXHRcdHN1cGVyKHRhcmdldCk7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gZXZlbnQ7XG5cdFx0dGhpcy5wb3MgPSBwb3M7XG5cdFx0dGhpcy5weCA9IHB4O1xuXHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNb3VzZUV2ZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudCA9IHJlcXVpcmUoJy4vRXZlbnQnKTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSByZXNpemUgZXZlbnQuXG4gKi9cbmNsYXNzIFJlc2l6ZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgUmVzaXplRXZlbnQgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IC0gVGhlIG9iamVjdCB0aGF0IGZpcmVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9sZFNpemUgLSBUaGUgb2xkIHNpemUgb2YgdGhlIHZpZXdwb3J0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbmV3U2l6ZSAtIFRoZSBuZXcgc2l6ZSBvZiB0aGUgdmlld3BvcnQuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih0YXJnZXQsIG9sZFNpemUsIG5ld1NpemUpIHtcblx0XHRzdXBlcih0YXJnZXQpO1xuXHRcdHRoaXMub2xkU2l6ZSA9IG9sZFNpemU7XG5cdFx0dGhpcy5uZXdTaXplID0gbmV3U2l6ZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc2l6ZUV2ZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudCA9IHJlcXVpcmUoJy4vRXZlbnQnKTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSB0aWxlIGV2ZW50LlxuICovXG5jbGFzcyBUaWxlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBUaWxlRXZlbnQgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IC0gVGhlIG9iamVjdCB0aGF0IGZpcmVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbGUgLSBUaGUgdGlsZSBvYmplY3QuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih0YXJnZXQsIHRpbGUpIHtcblx0XHRzdXBlcih0YXJnZXQpO1xuXHRcdHRoaXMudGlsZSA9IHRpbGU7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUaWxlRXZlbnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50VHlwZSA9IHJlcXVpcmUoJy4vZXZlbnQvRXZlbnRUeXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHQvLyBldmVudHNcblx0Q0xJQ0s6IEV2ZW50VHlwZS5DTElDSyxcblx0REJMX0NMSUNLOiBFdmVudFR5cGUuREJMX0NMSUNLLFxuXHRNT1VTRV9ET1dOOiBFdmVudFR5cGUuTU9VU0VfRE9XTixcblx0TU9VU0VfVVA6IEV2ZW50VHlwZS5NT1VTRV9VUCxcblx0TU9VU0VfTU9WRTogRXZlbnRUeXBlLk1PVVNFX01PVkUsXG5cdE1PVVNFX09WRVI6IEV2ZW50VHlwZS5NT1VTRV9PVkVSLFxuXHRNT1VTRV9PVVQ6IEV2ZW50VHlwZS5NT1VTRV9PVVQsXG5cdFBBTl9TVEFSVDogRXZlbnRUeXBlLlBBTl9TVEFSVCxcblx0UEFOOiBFdmVudFR5cGUuUEFOLFxuXHRQQU5fRU5EOiBFdmVudFR5cGUuUEFOX0VORCxcblx0Wk9PTV9TVEFSVDogRXZlbnRUeXBlLlpPT01fU1RBUlQsXG5cdFpPT006IEV2ZW50VHlwZS5aT09NLFxuXHRaT09NX0VORDogRXZlbnRUeXBlLlpPT01fRU5ELFxuXHRSRVNJWkU6IEV2ZW50VHlwZS5SRVNJWkUsXG5cdEZSQU1FOiBFdmVudFR5cGUuRlJBTUUsXG5cdFJFRlJFU0g6IEV2ZW50VHlwZS5SRUZSRVNILFxuXHRUSUxFX1JFUVVFU1Q6IEV2ZW50VHlwZS5USUxFX1JFUVVFU1QsXG5cdFRJTEVfRkFJTFVSRTogRXZlbnRUeXBlLlRJTEVfRkFJTFVSRSxcblx0VElMRV9BREQ6IEV2ZW50VHlwZS5USUxFX0FERCxcblx0VElMRV9ESVNDQVJEOiBFdmVudFR5cGUuVElMRV9ESVNDQVJELFxuXHRUSUxFX1JFTU9WRTogRXZlbnRUeXBlLlRJTEVfUkVNT1ZFLFxuXHRDRUxMX1VQREFURTogRXZlbnRUeXBlLkNFTExfVVBEQVRFLFxuXHQvLyBldmVudFxuXHRFdmVudDogcmVxdWlyZSgnLi9ldmVudC9FdmVudCcpLFxuXHRNb3VzZUV2ZW50OiByZXF1aXJlKCcuL2V2ZW50L01vdXNlRXZlbnQnKSxcblx0UmVzaXplRXZlbnQ6IHJlcXVpcmUoJy4vZXZlbnQvUmVzaXplRXZlbnQnKSxcblx0VGlsZUV2ZW50OiByZXF1aXJlKCcuL2V2ZW50L1RpbGVFdmVudCcpLFxuXHQvLyBnZW9tZXRyeVxuXHRCb3VuZHM6IHJlcXVpcmUoJy4vZ2VvbWV0cnkvQm91bmRzJyksXG5cdFJUcmVlOiByZXF1aXJlKCcuL2dlb21ldHJ5L1JUcmVlJyksXG5cdFJUcmVlUHlyYW1pZDogcmVxdWlyZSgnLi9nZW9tZXRyeS9SVHJlZVB5cmFtaWQnKSxcblx0Q2lyY2xlQ29sbGlkYWJsZTogcmVxdWlyZSgnLi9nZW9tZXRyeS9DaXJjbGVDb2xsaWRhYmxlJyksXG5cdFJlY3RhbmdsZUNvbGxpZGFibGU6IHJlcXVpcmUoJy4vZ2VvbWV0cnkvUmVjdGFuZ2xlQ29sbGlkYWJsZScpLFxuXHRSaW5nQ29sbGlkYWJsZTogcmVxdWlyZSgnLi9nZW9tZXRyeS9SaW5nQ29sbGlkYWJsZScpLFxuXHQvLyBwbG90XG5cdFBsb3Q6IHJlcXVpcmUoJy4vcGxvdC9QbG90JyksXG5cdC8vIGxheWVyXG5cdExheWVyOiByZXF1aXJlKCcuL2xheWVyL0xheWVyJyksXG5cdC8vIHRpbGUgbGF5ZXJcblx0VGlsZUxheWVyOiByZXF1aXJlKCcuL2xheWVyL3RpbGUvVGlsZUxheWVyJyksXG5cdC8vIG92ZXJsYXkgbGF5ZXJcblx0T3ZlcmxheTogcmVxdWlyZSgnLi9sYXllci9vdmVybGF5L092ZXJsYXknKSxcblx0UG9pbnRPdmVybGF5OiByZXF1aXJlKCcuL2xheWVyL292ZXJsYXkvUG9pbnRPdmVybGF5JyksXG5cdFBvbHlsaW5lT3ZlcmxheTogcmVxdWlyZSgnLi9sYXllci9vdmVybGF5L1BvbHlsaW5lT3ZlcmxheScpLFxuXHRQb2x5Z29uT3ZlcmxheTogcmVxdWlyZSgnLi9sYXllci9vdmVybGF5L1BvbHlnb25PdmVybGF5JyksXG5cdC8vIHJlbmRlcmVyXG5cdFJlbmRlcmVyOiByZXF1aXJlKCcuL3JlbmRlcmVyL1JlbmRlcmVyJyksXG5cdC8vIHRpbGUgcmVuZGVyZXJcblx0VGlsZVJlbmRlcmVyOiByZXF1aXJlKCcuL3JlbmRlcmVyL3RpbGUvVGlsZVJlbmRlcmVyJyksXG5cdC8vIHdlYmdsIHRpbGUgcmVuZGVyZXJcblx0V2ViR0xUaWxlUmVuZGVyZXI6IHJlcXVpcmUoJy4vcmVuZGVyZXIvdGlsZS9XZWJHTFRpbGVSZW5kZXJlcicpLFxuXHRJbWFnZVRpbGVSZW5kZXJlcjogcmVxdWlyZSgnLi9yZW5kZXJlci90aWxlL3NhbXBsZS9JbWFnZVRpbGVSZW5kZXJlcicpLFxuXHRJbnRlcmFjdGl2ZVRpbGVSZW5kZXJlcjogcmVxdWlyZSgnLi9yZW5kZXJlci90aWxlL3NhbXBsZS9JbnRlcmFjdGl2ZVRpbGVSZW5kZXJlcicpLFxuXHRQb2ludFRpbGVSZW5kZXJlcjogcmVxdWlyZSgnLi9yZW5kZXJlci90aWxlL3NhbXBsZS9Qb2ludFRpbGVSZW5kZXJlcicpLFxuXHRJbnN0YW5jZWRUaWxlUmVuZGVyZXI6IHJlcXVpcmUoJy4vcmVuZGVyZXIvdGlsZS9zYW1wbGUvSW5zdGFuY2VkVGlsZVJlbmRlcmVyJyksXG5cdC8vIG92ZXJsYXkgcmVuZGVyZXJcblx0T3ZlcmxheVJlbmRlcmVyOiByZXF1aXJlKCcuL3JlbmRlcmVyL292ZXJsYXkvT3ZlcmxheVJlbmRlcmVyJyksXG5cdC8vIHdlYmdsIG92ZXJsYXkgcmVuZGVyZXJcblx0V2ViR0xPdmVybGF5UmVuZGVyZXI6IHJlcXVpcmUoJy4vcmVuZGVyZXIvb3ZlcmxheS9XZWJHTE92ZXJsYXlSZW5kZXJlcicpLFxuXHRQb2ludE92ZXJsYXlSZW5kZXJlcjogcmVxdWlyZSgnLi9yZW5kZXJlci9vdmVybGF5L3NhbXBsZS9Qb2ludE92ZXJsYXlSZW5kZXJlcicpLFxuXHRQb2x5bGluZU92ZXJsYXlSZW5kZXJlcjogcmVxdWlyZSgnLi9yZW5kZXJlci9vdmVybGF5L3NhbXBsZS9Qb2x5bGluZU92ZXJsYXlSZW5kZXJlcicpLFxuXHRQb2x5Z29uT3ZlcmxheVJlbmRlcmVyOiByZXF1aXJlKCcuL3JlbmRlcmVyL292ZXJsYXkvc2FtcGxlL1BvbHlnb25PdmVybGF5UmVuZGVyZXInKSxcblx0Ly8gd2ViZ2wgc2hhZGVyXG5cdFNoYWRlcjogcmVxdWlyZSgnLi93ZWJnbC9zaGFkZXIvU2hhZGVyJyksXG5cdC8vIHdlYmdsIHRleHR1cmVcblx0VGV4dHVyZTogcmVxdWlyZSgnLi93ZWJnbC90ZXh0dXJlL1RleHR1cmUnKSxcblx0VGV4dHVyZUFycmF5OiByZXF1aXJlKCcuL3dlYmdsL3RleHR1cmUvVGV4dHVyZUFycmF5JyksXG5cdC8vIHdlYmdsIHZlcnRleFxuXHRWZXJ0ZXhBdGxhczogcmVxdWlyZSgnLi93ZWJnbC92ZXJ0ZXgvVmVydGV4QXRsYXMnKSxcblx0VmVydGV4QnVmZmVyOiByZXF1aXJlKCcuL3dlYmdsL3ZlcnRleC9WZXJ0ZXhCdWZmZXInKSxcblx0SW5kZXhCdWZmZXI6IHJlcXVpcmUoJy4vd2ViZ2wvdmVydGV4L0luZGV4QnVmZmVyJyksXG5cdC8vIHV0aWxcblx0bG9hZEJ1ZmZlcjogcmVxdWlyZSgnLi91dGlsL2xvYWRCdWZmZXInKSxcblx0bG9hZEltYWdlOiByZXF1aXJlKCcuL3V0aWwvbG9hZEltYWdlJylcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIENvbnN0YW50c1xuXG5jb25zdCBJTlNJREUgPSAweDAwOyAvLyAwMDAwXG5jb25zdCBMRUZUID0gMHgwMTsgICAvLyAwMDAxXG5jb25zdCBSSUdIVCA9IDB4MDI7ICAvLyAwMDEwXG5jb25zdCBCT1RUT00gPSAweDA0OyAvLyAwMTAwXG5jb25zdCBUT1AgPSAweDA4OyAgICAvLyAxMDAwXG5cbmNvbnN0IGNvbXB1dGVDb2RlID0gZnVuY3Rpb24oYm91bmRzLCB4LCB5KSB7XG5cdGxldCBjb2RlID0gSU5TSURFO1xuXHRpZiAoeCA8IGJvdW5kcy5sZWZ0KSB7XG5cdFx0Ly8gdG8gdGhlIGxlZnQgb2YgY2xpcCB3aW5kb3dcblx0XHRjb2RlIHw9IExFRlQ7XG5cdH0gZWxzZSBpZiAoeCA+IGJvdW5kcy5yaWdodCkge1xuXHRcdC8vIHRvIHRoZSByaWdodCBvZiBjbGlwIHdpbmRvd1xuXHRcdGNvZGUgfD0gUklHSFQ7XG5cdH1cblx0aWYgKHkgPCBib3VuZHMuYm90dG9tKSB7XG5cdFx0Ly8gYmVsb3cgdGhlIGNsaXAgd2luZG93XG5cdFx0Y29kZSB8PSBCT1RUT007XG5cdH0gZWxzZSBpZiAoeSA+IGJvdW5kcy50b3ApIHtcblx0XHQvLyBhYm92ZSB0aGUgY2xpcCB3aW5kb3dcblx0XHRjb2RlIHw9IFRPUDtcblx0fVxuXHRyZXR1cm4gY29kZTtcbn07XG5cbmNvbnN0IHN1dGhlcmxhbmRIb2RnZW1hbkNsaXAgPSBmdW5jdGlvbihib3VuZHMsIHBvaW50cykge1xuXHQvLyBTdXRoZXJsYW5kLUhvZGdlbWFuIGNsaXBwaW5nIGFsZ29yaXRobSBjbGlwcyBhIHBvbHlnb24gYWdhaW5zdCBhXG5cdC8vIHJlY3RhbmdsZS5cblxuXHRsZXQgcmVzdWx0O1xuXHRmb3IgKGxldCBjb2RlPTE7IGNvZGU8PTg7IGNvZGUqPTIpIHtcblx0XHRyZXN1bHQgPSBbXTtcblx0XHRsZXQgcHJldiA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG5cdFx0bGV0IHByZXZJbnNpZGUgPSAhKGNvbXB1dGVDb2RlKGJvdW5kcywgcHJldi54LCBwcmV2LnkpICYgY29kZSk7XG5cdFx0Zm9yIChsZXQgaT0wOyBpPHBvaW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgcCA9IHBvaW50c1tpXTtcblx0XHRcdGNvbnN0IGluc2lkZSA9ICEoY29tcHV0ZUNvZGUoYm91bmRzLCBwLngsIHAueSkgJiBjb2RlKTtcblx0XHRcdC8vIGlmIHNlZ21lbnQgZ29lcyB0aHJvdWdoIHRoZSBjbGlwIHdpbmRvdywgYWRkIGFuIGludGVyc2VjdGlvblxuXHRcdFx0aWYgKGluc2lkZSAhPT0gcHJldkluc2lkZSkge1xuXHRcdFx0XHRjb25zdCBheCA9IHByZXYueDtcblx0XHRcdFx0Y29uc3QgYXkgPSBwcmV2Lnk7XG5cdFx0XHRcdGNvbnN0IGJ4ID0gcC54O1xuXHRcdFx0XHRjb25zdCBieSA9IHAueTtcblx0XHRcdFx0bGV0IHgsIHkgPSAwO1xuXHRcdFx0XHRpZiAoY29kZSAmIFRPUCkge1xuXHRcdFx0XHRcdC8vIHBvaW50IGlzIGFib3ZlIHRoZSBjbGlwIHJlY3RhbmdsZVxuXHRcdFx0XHRcdHggPSBheCArIChieCAtIGF4KSAqIChib3VuZHMudG9wIC0gYXkpIC8gKGJ5IC0gYXkpO1xuXHRcdFx0XHRcdHkgPSBib3VuZHMudG9wO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNvZGUgJiBCT1RUT00pIHtcblx0XHRcdFx0XHQvLyBwb2ludCBpcyBiZWxvdyB0aGUgY2xpcCByZWN0YW5nbGVcblx0XHRcdFx0XHR4ID0gYXggKyAoYnggLSBheCkgKiAoYm91bmRzLmJvdHRvbSAtIGF5KSAvIChieSAtIGF5KTtcblx0XHRcdFx0XHR5ID0gYm91bmRzLmJvdHRvbTtcblx0XHRcdFx0fSBlbHNlIGlmIChjb2RlICYgUklHSFQpIHtcblx0XHRcdFx0XHQvLyBwb2ludCBpcyB0byB0aGUgcmlnaHQgb2YgY2xpcCByZWN0YW5nbGVcblx0XHRcdFx0XHR5ID0gYXkgKyAoYnkgLSBheSkgKiAoYm91bmRzLnJpZ2h0IC0gYXgpIC8gKGJ4IC0gYXgpO1xuXHRcdFx0XHRcdHggPSBib3VuZHMucmlnaHQ7XG5cdFx0XHRcdH0gZWxzZSB7IC8vaWYgKGNvZGUgJiBMRUZUKSB7XG5cdFx0XHRcdFx0Ly8gcG9pbnQgaXMgdG8gdGhlIGxlZnQgb2YgY2xpcCByZWN0YW5nbGVcblx0XHRcdFx0XHR5ID0gYXkgKyAoYnkgLSBheSkgKiAoYm91bmRzLmxlZnQgLSBheCkgLyAoYnggLSBheCk7XG5cdFx0XHRcdFx0eCA9IGJvdW5kcy5sZWZ0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlc3VsdC5wdXNoKHtcblx0XHRcdFx0XHR4OiB4LFxuXHRcdFx0XHRcdHk6IHlcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaW5zaWRlKSB7XG5cdFx0XHRcdC8vIGFkZCBhIHBvaW50IGlmIGl0J3MgaW5zaWRlXG5cdFx0XHRcdHJlc3VsdC5wdXNoKHApO1xuXHRcdFx0fVxuXHRcdFx0cHJldiA9IHA7XG5cdFx0XHRwcmV2SW5zaWRlID0gaW5zaWRlO1xuXHRcdH1cblx0XHRwb2ludHMgPSByZXN1bHQ7XG5cdFx0aWYgKCFwb2ludHMubGVuZ3RoKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblx0cmV0dXJuIHJlc3VsdC5sZW5ndGggPiAwID8gcmVzdWx0IDogbnVsbDtcbn07XG5cbmNvbnN0IGNvaGVuU3V0aGVybGFuZENsaXAgPSBmdW5jdGlvbihib3VuZHMsIGEsIGIpIHtcblx0Ly8gQ29oZW7igJNTdXRoZXJsYW5kIGNsaXBwaW5nIGFsZ29yaXRobSBjbGlwcyBhIGxpbmUgYWdhaW5zdCBhIHJlY3RhbmdsZS5cblxuXHQvLyBjb3B5IHNvIHdlIGRvbid0IGNoYW5nZSBpbi1wbGFjZVxuXHRsZXQgYXggPSBhLng7XG5cdGxldCBheSA9IGEueTtcblx0bGV0IGJ4ID0gYi54O1xuXHRsZXQgYnkgPSBiLnk7XG5cdC8vIGNvbXB1dGUgb3V0Y29kZXMgZm9yIFAwLCBQMSwgYW5kIHdoYXRldmVyIHBvaW50IGxpZXMgb3V0c2lkZSB0aGUgY2xpcCByZWN0YW5nbGVcblx0bGV0IGFDb2RlID0gY29tcHV0ZUNvZGUoYm91bmRzLCBheCwgYXkpO1xuXHRsZXQgYkNvZGUgPSBjb21wdXRlQ29kZShib3VuZHMsIGJ4LCBieSk7XG5cdGxldCBhY2NlcHQgPSBmYWxzZTtcblx0Ly8gbm9ybWFsIGFsZyBoYXMgaW5maWluaXRlIHdoaWxlIGxvb3AsIGNhcCBhdCA4IGl0ZXJhdGlvbnMganVzdCBpbiBjYXNlXG5cdGNvbnN0IE1BWF9JVEVSQVRJT05TID0gODtcblx0bGV0IGl0ZXIgPSAwO1xuXHR3aGlsZSAoaXRlciA8IE1BWF9JVEVSQVRJT05TKSB7XG5cdFx0aWYgKCEoYUNvZGUgfCBiQ29kZSkpIHtcblx0XHRcdC8vIGJpdHdpc2UgT1IgaXMgMC4gVHJpdmlhbGx5IGFjY2VwdCBhbmQgZ2V0IG91dCBvZiBsb29wXG5cdFx0XHRhY2NlcHQgPSB0cnVlO1xuXHRcdFx0YnJlYWs7XG5cdFx0fSBlbHNlIGlmIChhQ29kZSAmIGJDb2RlKSB7XG5cdFx0XHQvLyBiaXR3aXNlIEFORCBpcyBub3QgMC4gKGltcGxpZXMgYm90aCBlbmQgcG9pbnRzIGFyZSBpbiB0aGUgc2FtZVxuXHRcdFx0Ly8gcmVnaW9uIG91dHNpZGUgdGhlIHdpbmRvdykuIFJlamVjdCBhbmQgZ2V0IG91dCBvZiBsb29wXG5cdFx0XHRicmVhaztcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gZmFpbGVkIGJvdGggdGVzdHMsIHNvIGNhbGN1bGF0ZSB0aGUgbGluZSBzZWdtZW50IHRvIGNsaXBcblx0XHRcdC8vIGZyb20gYW4gb3V0c2lkZSBwb2ludCB0byBhbiBpbnRlcnNlY3Rpb24gd2l0aCBjbGlwIGVkZ2Vcblx0XHRcdGxldCB4LCB5ID0gMDtcblx0XHRcdC8vIEF0IGxlYXN0IG9uZSBlbmRwb2ludCBpcyBvdXRzaWRlIHRoZSBjbGlwIHJlY3RhbmdsZTsgcGljayBpdC5cblx0XHRcdGNvbnN0IGNvZGUgPSBhQ29kZSA/IGFDb2RlIDogYkNvZGU7XG5cdFx0XHQvLyBOb3cgZmluZCB0aGUgaW50ZXJzZWN0aW9uIHBvaW50O1xuXHRcdFx0Ly8gdXNlIGZvcm11bGFzXG5cdFx0XHQvLyB5ID0gYXkgKyBzbG9wZSAqICh4IC0gYXgpLCB4ID0gYXggKyAoMSAvIHNsb3BlKSAqICh5IC0gYXkpXG5cdFx0XHRpZiAoY29kZSAmIFRPUCkge1xuXHRcdFx0XHQvLyBwb2ludCBpcyBhYm92ZSB0aGUgY2xpcCByZWN0YW5nbGVcblx0XHRcdFx0eCA9IGF4ICsgKGJ4IC0gYXgpICogKGJvdW5kcy50b3AgLSBheSkgLyAoYnkgLSBheSk7XG5cdFx0XHRcdHkgPSBib3VuZHMudG9wO1xuXHRcdFx0fSBlbHNlIGlmIChjb2RlICYgQk9UVE9NKSB7XG5cdFx0XHRcdC8vIHBvaW50IGlzIGJlbG93IHRoZSBjbGlwIHJlY3RhbmdsZVxuXHRcdFx0XHR4ID0gYXggKyAoYnggLSBheCkgKiAoYm91bmRzLmJvdHRvbSAtIGF5KSAvIChieSAtIGF5KTtcblx0XHRcdFx0eSA9IGJvdW5kcy5ib3R0b207XG5cdFx0XHR9IGVsc2UgaWYgKGNvZGUgJiBSSUdIVCkge1xuXHRcdFx0XHQvLyBwb2ludCBpcyB0byB0aGUgcmlnaHQgb2YgY2xpcCByZWN0YW5nbGVcblx0XHRcdFx0eSA9IGF5ICsgKGJ5IC0gYXkpICogKGJvdW5kcy5yaWdodCAtIGF4KSAvIChieCAtIGF4KTtcblx0XHRcdFx0eCA9IGJvdW5kcy5yaWdodDtcblx0XHRcdH0gZWxzZSB7IC8vaWYgKGNvZGUgJiBMRUZUKSB7XG5cdFx0XHRcdC8vIHBvaW50IGlzIHRvIHRoZSBsZWZ0IG9mIGNsaXAgcmVjdGFuZ2xlXG5cdFx0XHRcdHkgPSBheSArIChieSAtIGF5KSAqIChib3VuZHMubGVmdCAtIGF4KSAvIChieCAtIGF4KTtcblx0XHRcdFx0eCA9IGJvdW5kcy5sZWZ0O1xuXHRcdFx0fVxuXHRcdFx0Ly8gbm93IHdlIG1vdmUgb3V0c2lkZSBwb2ludCB0byBpbnRlcnNlY3Rpb24gcG9pbnQgdG8gY2xpcFxuXHRcdFx0Ly8gYW5kIGdldCByZWFkeSBmb3IgbmV4dCBwYXNzLlxuXHRcdFx0aWYgKGNvZGUgPT09IGFDb2RlKSB7XG5cdFx0XHRcdGF4ID0geDtcblx0XHRcdFx0YXkgPSB5O1xuXHRcdFx0XHRhQ29kZSA9IGNvbXB1dGVDb2RlKGJvdW5kcywgYXgsIGF5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ4ID0geDtcblx0XHRcdFx0YnkgPSB5O1xuXHRcdFx0XHRiQ29kZSA9IGNvbXB1dGVDb2RlKGJvdW5kcywgYngsIGJ5KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aXRlcisrO1xuXHR9XG5cdGlmIChhY2NlcHQpIHtcblx0XHRyZXR1cm4gW1xuXHRcdFx0eyB4OiBheCwgeTogYXkgfSxcblx0XHRcdHsgeDogYngsIHk6IGJ5IH1cblx0XHRdO1xuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBzZXQgb2YgYm91bmRzLlxuICovXG5jbGFzcyBCb3VuZHMge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgQm91bmRzIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgLSBUaGUgbGVmdCBib3VuZC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IC0gVGhlIHJpZ2h0IGJvdW5kLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIC0gVGhlIGJvdHRvbSBib3VuZC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHRvcCAtIFRoZSB0b3AgYm91bmQuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCwgYm90dG9tLCB0b3ApIHtcblx0XHR0aGlzLmxlZnQgPSBsZWZ0O1xuXHRcdHRoaXMucmlnaHQgPSByaWdodDtcblx0XHR0aGlzLmJvdHRvbSA9IGJvdHRvbTtcblx0XHR0aGlzLnRvcCA9IHRvcDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHdpZHRoIG9mIHRoZSBib3VuZHMuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgYm91bmRzLlxuXHQgKi9cblx0Z2V0V2lkdGgoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQ7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSBoZWlnaHQgb2YgdGhlIGJvdW5kcy5cblx0ICpcblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgYm91bmRzLlxuXHQgKi9cblx0Z2V0SGVpZ2h0KCkge1xuXHRcdHJldHVybiB0aGlzLnRvcCAtIHRoaXMuYm90dG9tO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4dGVuZHMgdGhlIGJvdW5kcyBieSB0aGUgcHJvdmlkZWQgcG9pbnQgb3IgYm91bmRzIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R8Qm91bmRzfSBhcmcgLSBUaGUgcG9pbnQgb3IgYm91bmRzIHRvIGV4dGVuZCB0aGUgYm91bmRzIGJ5LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Qm91bmRzfSBUaGUgYm91bmRzIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0ZXh0ZW5kKGFyZykge1xuXHRcdGlmIChhcmcubGVmdCAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHRhcmcucmlnaHQgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0YXJnLmJvdHRvbSAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHRhcmcudG9wICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIGJvdW5kc1xuXHRcdFx0aWYgKGFyZy5sZWZ0IDwgdGhpcy5sZWZ0KSB7XG5cdFx0XHRcdHRoaXMubGVmdCA9IGFyZy5sZWZ0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZy5yaWdodCA+IHRoaXMucmlnaHQpIHtcblx0XHRcdFx0dGhpcy5yaWdodCA9IGFyZy5yaWdodDtcblx0XHRcdH1cblx0XHRcdGlmIChhcmcuYm90dG9tIDwgdGhpcy5ib3R0b20pIHtcblx0XHRcdFx0dGhpcy5ib3R0b20gPSBhcmcuYm90dG9tO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZy50b3AgPiB0aGlzLnRvcCkge1xuXHRcdFx0XHR0aGlzLnRvcCA9IGFyZy50b3A7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBvaW50XG5cdFx0XHRpZiAoYXJnLnggPCB0aGlzLmxlZnQpIHtcblx0XHRcdFx0dGhpcy5sZWZ0ID0gYXJnLng7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJnLnggPiB0aGlzLnJpZ2h0KSB7XG5cdFx0XHRcdHRoaXMucmlnaHQgPSBhcmcueDtcblx0XHRcdH1cblx0XHRcdGlmIChhcmcueSA8IHRoaXMuYm90dG9tKSB7XG5cdFx0XHRcdHRoaXMuYm90dG9tID0gYXJnLnk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJnLnkgPiB0aGlzLnRvcCkge1xuXHRcdFx0XHR0aGlzLnRvcCA9IGFyZy55O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGNlbnRlciBjb29yZGluYXRlIG9mIHRoZSBib3VuZHMuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjZW50ZXIgY29vcmRpbmF0ZSBvZiB0aGUgYm91bmRzLlxuXHQgKi9cblx0Z2V0Q2VudGVyKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB0aGlzLmxlZnQgKyAodGhpcy5nZXRXaWR0aCgpIC8gMiksXG5cdFx0XHR5OiB0aGlzLmJvdHRvbSArICh0aGlzLmdldEhlaWdodCgpIC8gMilcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFRlc3QgaWYgdGhlIGJvdW5kcyBlcXVhbHMgYW5vdGhlci5cblx0ICpcblx0ICogQHBhcmFtIHtCb3VuZHN9IGJvdW5kcyAtIFRoZSBib3VuZHMgb2JqZWN0IHRvIHRlc3QuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgYm91bmRzIG9iamVjdHMgYXJlIGVxdWFsLlxuXHQgKi9cblx0ZXF1YWxzKGJvdW5kcykge1xuXHRcdHJldHVybiB0aGlzLmxlZnQgPT09IGJvdW5kcy5sZWZ0ICYmXG5cdFx0XHR0aGlzLnJpZ2h0ID09PSBib3VuZHMucmlnaHQgJiZcblx0XHRcdHRoaXMuYm90dG9tID09PSBib3VuZHMuYm90dG9tICYmXG5cdFx0XHR0aGlzLnRvcCA9PT0gYm91bmRzLnRvcDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUZXN0IGlmIHRoZSBib3VuZHMgb3ZlcmxhcHMgYW5vdGhlci4gVGVzdCBpcyBpbmNsdXNpdmUgb2YgZWRnZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm91bmRzfSBib3VuZHMgLSBUaGUgYm91bmRzIG9iamVjdCB0byB0ZXN0LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGJvdW5kcyBvdmVybGFwIGVhY2hvdGhlci5cblx0ICovXG5cdG92ZXJsYXBzKGJvdW5kcykge1xuXHRcdC8vIE5PVEU6IGluY2x1c2l2ZSBvZiBlZGdlc1xuXHRcdHJldHVybiAhKHRoaXMubGVmdCA+IGJvdW5kcy5yaWdodCB8fFxuXHRcdFx0dGhpcy5yaWdodCA8IGJvdW5kcy5sZWZ0IHx8XG5cdFx0XHR0aGlzLnRvcCA8IGJvdW5kcy5ib3R0b20gfHxcblx0XHRcdHRoaXMuYm90dG9tID4gYm91bmRzLnRvcCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIGJvdW5kcy4gVGVzdCBpcyBpbmNsdXNpdmUgb2YgZWRnZXMuIElmXG5cdCAqIHRoZSBib3VuZHMgZG8gbm90IGludGVyc2VjdCwgcmV0dXJucyB1bmRlZmluZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm91bmRzfSBib3VuZHMgLSBUaGUgYm91bmRzIG9iamVjdCB0byBpbnRlcnNlY3QuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtCb3VuZHN9IFRoZSBpbnRlcnNlY3Rpb24gb2YgYm90aCBib3VuZHMuXG5cdCAqL1xuXHRpbnRlcnNlY3Rpb24oYm91bmRzKSB7XG5cdFx0Ly8gTk9URTogaW5jbHVzaXZlIG9mIGVkZ2VzXG5cdFx0aWYgKCF0aGlzLm92ZXJsYXBzKGJvdW5kcykpIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgQm91bmRzKFxuXHRcdFx0TWF0aC5tYXgodGhpcy5sZWZ0LCBib3VuZHMubGVmdCksXG5cdFx0XHRNYXRoLm1pbih0aGlzLnJpZ2h0LCBib3VuZHMucmlnaHQpLFxuXHRcdFx0TWF0aC5tYXgodGhpcy5ib3R0b20sIGJvdW5kcy5ib3R0b20pLFxuXHRcdFx0TWF0aC5taW4odGhpcy50b3AsIGJvdW5kcy50b3ApKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGlwcyB0aGUgcHJvdmlkZWQgbGluZSBzZWdtZW50IHRvIHdpdGhpbiB0aGUgZGltZW5zaW9ucyBvZiB0aGUgYm91bmRzLlxuXHQgKiBUZXN0IGlzIGluY2x1c2l2ZSBvZiBlZGdlcy5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheX0gbGluZSAtIFRoZSBsaW5lLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBjbGlwcGVkIGxpbmUsIG9yIG51bGwgaWYgaXQgaXMgb3V0c2lkZSB0aGUgYm91bmRzLlxuXHQgKi9cblx0Y2xpcExpbmUobGluZSkge1xuXHRcdGlmICghbGluZSB8fCBsaW5lLmxlbmd0aCAhPT0gMikge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBjb2hlblN1dGhlcmxhbmRDbGlwKHRoaXMsIGxpbmVbMF0sIGxpbmVbMV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsaXBzIHRoZSBwcm92aWRlZCBwb2x5bGluZSB0byB3aXRoaW4gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGJvdW5kcy4gV2lsbFxuXHQgKiByZXR1cm4gYW4gYXJyYXkgb2YgY2xpcHBlZCBwb2x5bGluZXMgYXMgcmVzdWx0LlxuXHQgKiBUZXN0IGlzIGluY2x1c2l2ZSBvZiBlZGdlcy5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheX0gcG9seWxpbmUgLSBUaGUgcG9seWxpbmUuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlc3VsdGluZyBjbGlwcGVkIHBvbHlsaW5lcywgb3IgbnVsbCBpZiBpdCBpcyBvdXRzaWRlIHRoZSBib3VuZHMuXG5cdCAqL1xuXHRjbGlwUG9seWxpbmUocG9seWxpbmUpIHtcblx0XHRpZiAoIXBvbHlsaW5lIHx8IHBvbHlsaW5lLmxlbmd0aCA8IDIpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRjb25zdCBjbGlwcGVkID0gW107XG5cdFx0bGV0IGN1cnJlbnQgPSBbXTtcblx0XHRmb3IgKGxldCBpPTE7IGk8cG9seWxpbmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGEgPSBwb2x5bGluZVtpLTFdO1xuXHRcdFx0Y29uc3QgYiA9IHBvbHlsaW5lW2ldO1xuXHRcdFx0Ly8gY2xpcCB0aGUgbGluZVxuXHRcdFx0Y29uc3QgbGluZSA9IGNvaGVuU3V0aGVybGFuZENsaXAodGhpcywgYSwgYik7XG5cdFx0XHQvLyBubyBsaW5lIGluIGJvdW5kc1xuXHRcdFx0aWYgKCFsaW5lKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgY2xpcHBlZEEgPSBsaW5lWzBdO1xuXHRcdFx0Y29uc3QgY2xpcHBlZEIgPSBsaW5lWzFdO1xuXHRcdFx0Ly8gYWRkIHNyYyBwb2ludFxuXHRcdFx0Y3VycmVudC5wdXNoKGNsaXBwZWRBKTtcblx0XHRcdGlmICgoY2xpcHBlZEIueCAhPT0gYi54ICYmIGNsaXBwZWRCLnkgIT09IGIueSkgfHxcblx0XHRcdFx0aSA9PT0gcG9seWxpbmUubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHQvLyBvbmx5IGFkZCBkZXN0aW5hdGlvbiBwb2ludCBpZiBpdCB3YXMgY2xpcHBlZCwgb3IgaXMgbGFzdFxuXHRcdFx0XHQvLyBwb2ludFxuXHRcdFx0XHRjdXJyZW50LnB1c2goY2xpcHBlZEIpO1xuXHRcdFx0XHQvLyB0aGVuIGJyZWFrIHRoZSBwb2x5bGluZVxuXHRcdFx0XHRjbGlwcGVkLnB1c2goY3VycmVudCk7XG5cdFx0XHRcdGN1cnJlbnQgPSBbXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNsaXBwZWQubGVuZ3RoID4gMCA/IGNsaXBwZWQgOiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsaXBzIHRoZSBwcm92aWRlZCBwb2ludHMgdG8gdGhvc2Ugd2l0aGluIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBib3VuZHMuXG5cdCAqIFRlc3QgaXMgaW5jbHVzaXZlIG9mIGVkZ2VzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgLSBUaGUgcG9pbnRzIHRvIGNsaXAuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGNsaXBwZWQgcG9pbnRzLCBvciBudWxsIGlmIG5vbmUgYXJlIHdpdGhpbiB0aGUgYm91bmRzLlxuXHQgKi9cblx0Y2xpcFBvaW50cyhwb2ludHMpIHtcblx0XHRpZiAoIXBvaW50cykge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdGNvbnN0IGNsaXBwZWQgPSBbXTtcblx0XHRmb3IgKGxldCBpPTA7IGk8cG9pbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcblx0XHRcdGlmIChwb2ludC54ID49IHRoaXMubGVmdCAmJlxuXHRcdFx0XHRwb2ludC54IDw9IHRoaXMucmlnaHQgJiZcblx0XHRcdFx0cG9pbnQueSA+PSB0aGlzLmJvdHRvbSAmJlxuXHRcdFx0XHRwb2ludC55IDw9IHRoaXMudG9wKSB7XG5cdFx0XHRcdGNsaXBwZWQucHVzaChwb2ludCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjbGlwcGVkLmxlbmd0aCA+IDAgPyBjbGlwcGVkIDogbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGlwcyB0aGUgcHJvdmlkZWQgcG9seWdvbiB0byB0aG9zZSB3aXRoaW4gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGJvdW5kcy5cblx0ICogVGVzdCBpcyBpbmNsdXNpdmUgb2YgZWRnZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHBvbHlnb24gLSBUaGUgcG9pbnRzIG9mIHRoZSBwb2x5Z29uIHRvIGNsaXAuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGNsaXBwZWQgcG9pbnRzIG9mIHRoZSBwb2x5Z29uLCBvciBudWxsIGlmIGl0IGlzIG5vdCB3aXRoaW4gdGhlIGJvdW5kcy5cblx0ICovXG5cdGNsaXBQb2x5Z29uKHBvbHlnb24pIHtcblx0XHRpZiAoIXBvbHlnb24gfHwgcG9seWdvbi5sZW5ndGggPCAzKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHN1dGhlcmxhbmRIb2RnZW1hbkNsaXAodGhpcywgcG9seWdvbik7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCb3VuZHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNsYW1wID0gcmVxdWlyZSgnbG9kYXNoL2NsYW1wJyk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgY2lyY2xlIGNvbGxpZGFibGUuXG4gKi9cbmNsYXNzIENpcmNsZUNvbGxpZGFibGUge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgQ2lyY2xlQ29sbGlkYWJsZSBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHRpbGUgeCBwaXhlbCBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB0aWxlIHkgcGl4ZWwgY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIFRoZSByYWRpdXMgaW4gcGl4ZWxzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geE9mZnNldCAtIFRoZSB0aWxlIHggb2Zmc2V0IGluIHBpeGVscy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHlPZmZzZXQgLSBUaGUgdGlsZSB5IG9mZnNldCBpbiBwaXhlbHMuXG5cdCAqIEBwYXJhbSB7VGlsZX0gdGlsZSAtIFRoZSB0aWxlIG9iamVjdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBBbnkgYXJiaXRyYXJ5IHVzZXIgZGF0YS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKHgsIHksIHJhZGl1cywgeE9mZnNldCwgeU9mZnNldCwgdGlsZSwgZGF0YSkge1xuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0XHR0aGlzLm1pblggPSB4ICsgeE9mZnNldCAtIHJhZGl1cztcblx0XHR0aGlzLm1heFggPSB4ICsgeE9mZnNldCArIHJhZGl1cztcblx0XHR0aGlzLm1pblkgPSB5ICsgeU9mZnNldCAtIHJhZGl1cztcblx0XHR0aGlzLm1heFkgPSB5ICsgeU9mZnNldCArIHJhZGl1cztcblx0XHR0aGlzLnRpbGUgPSB0aWxlO1xuXHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdH1cblxuXHQvKipcblx0ICogVGVzdCBpZiB0aGUgcHJvdmlkZWQgcG9zaXRpb24gaXMgd2l0aGluIHRoZSBpbm5lciBzaGFwZSBvZiB0aGUgY29sbGlkYWJsZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBwb3NpdGlvbiB0byB0ZXN0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IHBvc2l0aW9uIHRvIHRlc3QuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtib29sfSBXaGV0aGVyIG9yIG5vdCB0aGVyZSBpcyBhbiBpbnRlcnNlY3Rpb24uXG5cdCAqL1xuXHR0ZXN0UG9pbnQoeCwgeSkge1xuXHRcdC8vIGNlbnRlciBwb3Ncblx0XHRjb25zdCBjeCA9ICh0aGlzLm1pblggKyB0aGlzLm1heFgpICogMC41O1xuXHRcdGNvbnN0IGN5ID0gKHRoaXMubWluWSArIHRoaXMubWF4WSkgKiAwLjU7XG5cdFx0Ly8gZGlzdGFuY2UgdG8gcG9pbnRcblx0XHRjb25zdCBkeCA9IGN4IC0geDtcblx0XHRjb25zdCBkeSA9IGN5IC0geTtcblx0XHRyZXR1cm4gKGR4ICogZHggKyBkeSAqIGR5KSA8PSAodGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyk7XG5cdH1cblxuXHQvKipcblx0ICogVGVzdCBpZiB0aGUgcHJvdmlkZWQgcmVjdGFuZ2xlIGlzIHdpdGhpbiB0aGUgaW5uZXIgc2hhcGUgb2YgdGhlXG5cdCAqIGNvbGxpZGFibGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW5YIC0gVGhlIG1pbmltdW0geCBjb21wb25lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhYIC0gVGhlIG1heGltdW0geCBjb21wb25lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW5ZIC0gVGhlIG1pbmltdW0geSBjb21wb25lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhZIC0gVGhlIG1heGltdW0geSBjb21wb25lbnQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtib29sfSBXaGV0aGVyIG9yIG5vdCB0aGVyZSBpcyBhbiBpbnRlcnNlY3Rpb24uXG5cdCAqL1xuXHR0ZXN0UmVjdGFuZ2xlKG1pblgsIG1heFgsIG1pblksIG1heFkpIHtcblx0XHQvLyBjaXJjbGUgcG9zXG5cdFx0Y29uc3QgY3ggPSAodGhpcy5taW5YICsgdGhpcy5tYXhYKSAqIDAuNTtcblx0XHRjb25zdCBjeSA9ICh0aGlzLm1pblkgKyB0aGlzLm1heFkpICogMC41O1xuXHRcdC8vIGZpbmQgY2xvc2VzdCBwb2ludCBpbiByZWN0YW5nbGUgdG8gY2lyY2xlXG5cdFx0Y29uc3QgbmVhcmVzdFggPSBjbGFtcChjeCwgbWluWCwgbWF4WCk7XG5cdFx0Y29uc3QgbmVhcmVzdFkgPSBjbGFtcChjeSwgbWluWSwgbWF4WSk7XG5cdFx0Ly8gdGVzdCBkaXN0YW5jZVxuXHRcdGNvbnN0IGR4ID0gY3ggLSBuZWFyZXN0WDtcblx0XHRjb25zdCBkeSA9IGN5IC0gbmVhcmVzdFk7XG5cdFx0cmV0dXJuIChkeCAqIGR4ICsgZHkgKiBkeSkgPCAodGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyk7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDaXJjbGVDb2xsaWRhYmxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCByYnVzaCA9IHJlcXVpcmUoJ3JidXNoJyk7XG5jb25zdCBkZWZhdWx0VG8gPSByZXF1aXJlKCdsb2Rhc2gvZGVmYXVsdFRvJyk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIHItdHJlZS5cbiAqL1xuY2xhc3MgUlRyZWUge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgUlRyZWUgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdC5cblx0ICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLm5vZGVDYXBhY2l0eSAtIFRoZSBub2RlIGNhcGFjaXR5IG9mIHRoZSByLXRyZWUuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0dGhpcy50cmVlID0gcmJ1c2goZGVmYXVsdFRvKG9wdGlvbnMubm9kZUNhcGFjaXR5LCAzMikpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluc2VydHMgYW4gYXJyYXkgb2YgY29sbGlkYWJsZXMgaW50byB0aGUgci10cmVlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xsaWRhYmxlcyAtIFRoZSBhcnJheSBvZiBjb2xsaWRhYmxlcyB0byBpbnNlcnQuXG5cdCAqL1xuXHRpbnNlcnQoY29sbGlkYWJsZXMpIHtcblx0XHR0aGlzLnRyZWUubG9hZChjb2xsaWRhYmxlcyk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbiBhcnJheSBvZiBjb2xsaWRhYmxlcyBmcm9tIHRoZSByLXRyZWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbGxpZGFibGVzIC0gVGhlIGFycmF5IG9mIGNvbGxpZGFibGVzIHRvIHJlbW92ZS5cblx0ICovXG5cdHJlbW92ZShjb2xsaWRhYmxlcykge1xuXHRcdGNvbnN0IHRyZWUgPSB0aGlzLnRyZWU7XG5cdFx0Zm9yIChsZXQgaT0wOyBpPGNvbGxpZGFibGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0cmVlLnJlbW92ZShjb2xsaWRhYmxlc1tpXSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNlYXJjaHMgdGhlIHItdHJlZSB1c2luZyBhIHBvaW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IGNvbXBvbmVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjb21wb25lbnQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjb2xsaXNpb24gb2JqZWN0LlxuXHQgKi9cblx0c2VhcmNoUG9pbnQoeCwgeSkge1xuXHRcdGNvbnN0IGNvbGxpc2lvbnMgPSB0aGlzLnRyZWUuc2VhcmNoKHtcblx0XHRcdG1pblg6IHgsXG5cdFx0XHRtYXhYOiB4LFxuXHRcdFx0bWluWTogeSxcblx0XHRcdG1heFk6IHlcblx0XHR9KTtcblx0XHRpZiAoY29sbGlzaW9ucy5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHQvLyBpbm5lciBzaGFwZSB0ZXN0XG5cdFx0Zm9yIChsZXQgaT0wOyBpPGNvbGxpc2lvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGNvbGxpc2lvbiA9IGNvbGxpc2lvbnNbaV07XG5cdFx0XHRpZiAoY29sbGlzaW9uLnRlc3RQb2ludCh4LCB5KSkge1xuXHRcdFx0XHRyZXR1cm4gY29sbGlzaW9uO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZWFyY2hzIHRoZSByLXRyZWUgdXNpbmcgYSByZWN0YW5nbGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW5YIC0gVGhlIG1pbmltdW0geCBjb21wb25lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhYIC0gVGhlIG1heGltdW0geCBjb21wb25lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW5ZIC0gVGhlIG1pbmltdW0geSBjb21wb25lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhZIC0gVGhlIG1heGltdW0geSBjb21wb25lbnQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjb2xsaXNpb24gb2JqZWN0LlxuXHQgKi9cblx0c2VhcmNoUmVjdGFuZ2xlKG1pblgsIG1heFgsIG1pblksIG1heFkpIHtcblx0XHRjb25zdCBjb2xsaXNpb25zID0gdGhpcy50cmVlLnNlYXJjaCh7XG5cdFx0XHRtaW5YOiBtaW5YLFxuXHRcdFx0bWF4WDogbWF4WCxcblx0XHRcdG1pblk6IG1pblksXG5cdFx0XHRtYXhZOiBtYXhZXG5cdFx0fSk7XG5cdFx0aWYgKGNvbGxpc2lvbnMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0Ly8gaW5uZXIgc2hhcGUgdGVzdFxuXHRcdGZvciAobGV0IGk9MDsgaTxjb2xsaXNpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBjb2xsaXNpb24gPSBjb2xsaXNpb25zW2ldO1xuXHRcdFx0aWYgKGNvbGxpc2lvbi50ZXN0UmVjdGFuZ2xlKG1pblgsIG1heFgsIG1pblksIG1heFkpKSB7XG5cdFx0XHRcdHJldHVybiBjb2xsaXNpb247XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUlRyZWU7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGRlZmF1bHRUbyA9IHJlcXVpcmUoJ2xvZGFzaC9kZWZhdWx0VG8nKTtcbmNvbnN0IFJUcmVlID0gcmVxdWlyZSgnLi9SVHJlZScpO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHB5cmFtaWQgb2Ygci10cmVlcy5cbiAqL1xuY2xhc3MgUlRyZWVQeXJhbWlkIHtcblxuXHQvKipcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IFJUcmVlUHlyYW1pZCBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMubm9kZUNhcGFjaXR5IC0gVGhlIG5vZGUgY2FwYWNpdHkgb2YgdGhlIHItdHJlZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHR0aGlzLnRyZWVzID0gbmV3IE1hcCgpO1xuXHRcdHRoaXMuY29sbGlkYWJsZXMgPSBuZXcgTWFwKCk7XG5cdFx0dGhpcy5ub2RlQ2FwYWNpdHkgPSBkZWZhdWx0VG8ob3B0aW9ucy5ub2RlQ2FwYWNpdHksIDMyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbnNlcnRzIGFuIGFycmF5IG9mIGNvbGxpZGFibGVzIGludG8gdGhlIHItdHJlZSBmb3IgdGhlIHByb3ZpZGVkIGNvb3JkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1RpbGVDb29yZH0gY29vcmQgLSBUaGUgY29vcmQgb2YgdGhlIHRpbGUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbGxpZGFibGVzIC0gVGhlIGFycmF5IG9mIGNvbGxpZGFibGVzIHRvIGluc2VydC5cblx0ICpcblx0ICogQHJldHVybnMge1JUcmVlUHlyYW1pZH0gVGhlIFJUcmVlUHlyYW1pZCBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdGluc2VydChjb29yZCwgY29sbGlkYWJsZXMpIHtcblx0XHRpZiAoIXRoaXMudHJlZXMuaGFzKGNvb3JkLnopKSB7XG5cdFx0XHR0aGlzLnRyZWVzLnNldChjb29yZC56LCBuZXcgUlRyZWUoe1xuXHRcdFx0XHRub2RlQ2FwYWNpdHk6IHRoaXMubm9kZUNhcGFjaXR5XG5cdFx0XHR9KSk7XG5cdFx0fVxuXHRcdHRoaXMudHJlZXMuZ2V0KGNvb3JkLnopLmluc2VydChjb2xsaWRhYmxlcyk7XG5cdFx0dGhpcy5jb2xsaWRhYmxlcy5zZXQoY29vcmQuaGFzaCwgY29sbGlkYWJsZXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYW4gYXJyYXkgb2YgY29sbGlkYWJsZXMgZnJvbSB0aGUgci10cmVlIGZvciB0aGUgcHJvdmlkZWQgY29vcmQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VGlsZUNvb3JkfSBjb29yZCAtIFRoZSBjb29yZCBvZiB0aGUgdGlsZS5cblx0ICpcblx0ICogQHJldHVybnMge1JUcmVlUHlyYW1pZH0gVGhlIFJUcmVlUHlyYW1pZCBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHJlbW92ZShjb29yZCkge1xuXHRcdGNvbnN0IGNvbGxpZGFibGVzID0gdGhpcy5jb2xsaWRhYmxlcy5nZXQoY29vcmQuaGFzaCk7XG5cdFx0dGhpcy50cmVlcy5nZXQoY29vcmQueikucmVtb3ZlKGNvbGxpZGFibGVzKTtcblx0XHR0aGlzLmNvbGxpZGFibGVzLmRlbGV0ZShjb29yZC5oYXNoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZWFyY2hzIHRoZSByLXRyZWUgdXNpbmcgYSBwb2ludC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBjb21wb25lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgY29tcG9uZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gem9vbSAtIFRoZSB6b29tIGxldmVsIG9mIHRoZSBwbG90LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZXh0ZW50IC0gVGhlIHBpeGVsIGV4dGVudCBvZiB0aGUgcGxvdCB6b29tLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY29sbGlzaW9uIG9iamVjdC5cblx0ICovXG5cdHNlYXJjaFBvaW50KHgsIHksIHpvb20sIGV4dGVudCkge1xuXHRcdC8vIHBvaW50cyBhcmUgc3RvcmVkIGluIHVuLXNjYWxlZCBjb29yZGluYXRlcywgdW5zY2FsZSB0aGUgcG9pbnRcblx0XHRjb25zdCB0aWxlWm9vbSA9IE1hdGgucm91bmQoem9vbSk7XG5cdFx0Ly8gZ2V0IHRoZSB0cmVlIGZvciB0aGUgem9vbVxuXHRcdGNvbnN0IHRyZWUgPSB0aGlzLnRyZWVzLmdldCh0aWxlWm9vbSk7XG5cdFx0aWYgKCF0cmVlKSB7XG5cdFx0XHQvLyBubyBkYXRhIGZvciB0aWxlXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0Y29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCB0aWxlWm9vbSAtIHpvb20pO1xuXHRcdC8vIHVuc2NhbGVkIHBvaW50c1xuXHRcdGNvbnN0IHN4ID0geCAqIGV4dGVudCAqIHNjYWxlO1xuXHRcdGNvbnN0IHN5ID0geSAqIGV4dGVudCAqIHNjYWxlO1xuXHRcdC8vIGdldCBjb2xsaXNpb25cblx0XHRyZXR1cm4gdHJlZS5zZWFyY2hQb2ludChzeCwgc3kpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlYXJjaHMgdGhlIHItdHJlZSB1c2luZyBhIHJlY3RhbmdsZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pblggLSBUaGUgbWluaW11bSB4IGNvbXBvbmVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heFggLSBUaGUgbWF4aW11bSB4IGNvbXBvbmVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pblkgLSBUaGUgbWluaW11bSB5IGNvbXBvbmVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heFkgLSBUaGUgbWF4aW11bSB5IGNvbXBvbmVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHpvb20gLSBUaGUgem9vbSBsZXZlbCBvZiB0aGUgcGxvdC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGV4dGVudCAtIFRoZSBwaXhlbCBleHRlbnQgb2YgdGhlIHBsb3Qgem9vbS5cblx0ICpcblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIGNvbGxpc2lvbiBvYmplY3QuXG5cdCAqL1xuXHRzZWFyY2hSZWN0YW5nbGUobWluWCwgbWF4WCwgbWluWSwgbWF4WSwgem9vbSwgZXh0ZW50KSB7XG5cdFx0Ly8gcG9pbnRzIGFyZSBzdG9yZWQgaW4gdW4tc2NhbGVkIGNvb3JkaW5hdGVzLCB1bnNjYWxlIHRoZSBwb2ludFxuXHRcdGNvbnN0IHRpbGVab29tID0gTWF0aC5yb3VuZCh6b29tKTtcblx0XHQvLyBnZXQgdGhlIHRyZWUgZm9yIHRoZSB6b29tXG5cdFx0Y29uc3QgdHJlZSA9IHRoaXMudHJlZXMuZ2V0KHRpbGVab29tKTtcblx0XHRpZiAoIXRyZWUpIHtcblx0XHRcdC8vIG5vIGRhdGEgZm9yIHRpbGVcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIHRpbGVab29tIC0gem9vbSk7XG5cdFx0Ly8gdW5zY2FsZWQgcG9pbnRzXG5cdFx0Y29uc3Qgc21pblggPSBtaW5YICogZXh0ZW50ICogc2NhbGU7XG5cdFx0Y29uc3Qgc21heFggPSBtYXhYICogZXh0ZW50ICogc2NhbGU7XG5cdFx0Y29uc3Qgc21pblkgPSBtaW5ZICogZXh0ZW50ICogc2NhbGU7XG5cdFx0Y29uc3Qgc21heFkgPSBtYXhZICogZXh0ZW50ICogc2NhbGU7XG5cdFx0Ly8gZ2V0IGNvbGxpc2lvblxuXHRcdHJldHVybiB0cmVlLnNlYXJjaFJlY3RhbmdsZShzbWluWCwgc21heFgsIHNtaW5ZLCBzbWF4WSk7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSVHJlZVB5cmFtaWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgcmVjdGFuZ2xlIGNvbGxpZGFibGUuXG4gKi9cbmNsYXNzIFJlY3RhbmdsZUNvbGxpZGFibGUge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgUmVjdGFuZ2xlQ29sbGlkYWJsZSBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW5YIC0gVGhlIGxlZnQgYm91bmQgaW4gcGl4ZWxzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4WCAtIFRoZSByaWdodCBib3VuZCBpbiBwaXhlbHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW5ZIC0gVGhlIGJvdHRvbSBib3VuZCBpbiBwaXhlbHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhZIC0gVGhlIHRvcCBib3VuZCBpbiBwaXhlbHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4T2Zmc2V0IC0gVGhlIHRpbGUgeCBvZmZzZXQgaW4gcGl4ZWxzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geU9mZnNldCAtIFRoZSB0aWxlIHkgb2Zmc2V0IGluIHBpeGVscy5cblx0ICogQHBhcmFtIHtUaWxlfSB0aWxlIC0gVGhlIHRpbGUgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIEFueSBhcmJpdHJhcnkgdXNlciBkYXRhLlxuXHQgKi9cblx0Y29uc3RydWN0b3IobWluWCwgbWF4WCwgbWluWSwgbWF4WSwgeE9mZnNldCwgeU9mZnNldCwgdGlsZSwgZGF0YSkge1xuXHRcdHRoaXMubWluWCA9IG1pblggKyB4T2Zmc2V0O1xuXHRcdHRoaXMubWF4WCA9IG1heFggKyB4T2Zmc2V0O1xuXHRcdHRoaXMubWluWSA9IG1pblkgKyB5T2Zmc2V0O1xuXHRcdHRoaXMubWF4WSA9IG1heFkgKyB5T2Zmc2V0O1xuXHRcdHRoaXMudGlsZSA9IHRpbGU7XG5cdFx0dGhpcy5kYXRhID0gZGF0YTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUZXN0IGlmIHRoZSBwcm92aWRlZCBwb3NpdGlvbiBpcyB3aXRoaW4gdGhlIGlubmVyIHNoYXBlIG9mIHRoZSBjb2xsaWRhYmxlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IHBvc2l0aW9uIHRvIHRlc3QuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgcG9zaXRpb24gdG8gdGVzdC5cblx0ICpcblx0ICogQHJldHVybnMge2Jvb2x9IFdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIGFuIGludGVyc2VjdGlvbi5cblx0ICovXG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cdHRlc3RQb2ludCh4LCB5KSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogVGVzdCBpZiB0aGUgcHJvdmlkZWQgcmVjdGFuZ2xlIGlzIHdpdGhpbiB0aGUgaW5uZXIgc2hhcGUgb2YgdGhlXG5cdCAqIGNvbGxpZGFibGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW5YIC0gVGhlIG1pbmltdW0geCBjb21wb25lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhYIC0gVGhlIG1heGltdW0geCBjb21wb25lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW5ZIC0gVGhlIG1pbmltdW0geSBjb21wb25lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhZIC0gVGhlIG1heGltdW0geSBjb21wb25lbnQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtib29sfSBXaGV0aGVyIG9yIG5vdCB0aGVyZSBpcyBhbiBpbnRlcnNlY3Rpb24uXG5cdCAqL1xuXHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXHR0ZXN0UmVjdGFuZ2xlKG1pblgsIG1heFgsIG1pblksIG1heFkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY3RhbmdsZUNvbGxpZGFibGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNsYW1wID0gcmVxdWlyZSgnbG9kYXNoL2NsYW1wJyk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgY2lyY2xlIGNvbGxpZGFibGUuXG4gKi9cbmNsYXNzIFJpbmdDb2xsaWRhYmxlIHtcblxuXHQvKipcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IFJpbmdDb2xsaWRhYmxlIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgdGlsZSB4IHBpeGVsIGNvb3JkaW5hdGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHRpbGUgeSBwaXhlbCBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gVGhlIHJhZGl1cyBpbiBwaXhlbHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSByYWRpdXMgYnVmZmVyIGluIHBpeGVscyAoYWRkaXRpb25hbCBoaXQtYXJlYSBiZXlvbmQgcmFkaXVzKVxuXHQgKiBAcGFyYW0ge251bWJlcn0geE9mZnNldCAtIFRoZSB0aWxlIHggb2Zmc2V0IGluIHBpeGVscy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHlPZmZzZXQgLSBUaGUgdGlsZSB5IG9mZnNldCBpbiBwaXhlbHMuXG5cdCAqIEBwYXJhbSB7VGlsZX0gdGlsZSAtIFRoZSB0aWxlIG9iamVjdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBBbnkgYXJiaXRyYXJ5IHVzZXIgZGF0YS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKHgsIHksIHJhZGl1cywgd2lkdGgsIHhPZmZzZXQsIHlPZmZzZXQsIHRpbGUsIGRhdGEpIHtcblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdGNvbnN0IGhhbGZXaWR0aCA9IHdpZHRoICogMC41O1xuXHRcdHRoaXMubWluWCA9IHggKyB4T2Zmc2V0IC0gcmFkaXVzIC0gaGFsZldpZHRoO1xuXHRcdHRoaXMubWF4WCA9IHggKyB4T2Zmc2V0ICsgcmFkaXVzICsgaGFsZldpZHRoO1xuXHRcdHRoaXMubWluWSA9IHkgKyB5T2Zmc2V0IC0gcmFkaXVzIC0gaGFsZldpZHRoO1xuXHRcdHRoaXMubWF4WSA9IHkgKyB5T2Zmc2V0ICsgcmFkaXVzICsgaGFsZldpZHRoO1xuXHRcdHRoaXMudGlsZSA9IHRpbGU7XG5cdFx0dGhpcy5kYXRhID0gZGF0YTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUZXN0IGlmIHRoZSBwcm92aWRlZCBwb3NpdGlvbiBpcyB3aXRoaW4gdGhlIGlubmVyIHNoYXBlIG9mIHRoZSBjb2xsaWRhYmxlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IHBvc2l0aW9uIHRvIHRlc3QuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgcG9zaXRpb24gdG8gdGVzdC5cblx0ICpcblx0ICogQHJldHVybnMge2Jvb2x9IFdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIGFuIGludGVyc2VjdGlvbi5cblx0ICovXG5cdHRlc3RQb2ludCh4LCB5KSB7XG5cdFx0Ly8gY2VudGVyIHBvc1xuXHRcdGNvbnN0IGN4ID0gKHRoaXMubWluWCArIHRoaXMubWF4WCkgKiAwLjU7XG5cdFx0Y29uc3QgY3kgPSAodGhpcy5taW5ZICsgdGhpcy5tYXhZKSAqIDAuNTtcblx0XHQvLyBkaXN0YW5jZSB0byBwb2ludFxuXHRcdGNvbnN0IGR4ID0gY3ggLSB4O1xuXHRcdGNvbnN0IGR5ID0gY3kgLSB5O1xuXHRcdGNvbnN0IGRpc3RhbmNlU3FyID0gZHggKiBkeCArIGR5ICogZHk7XG5cdFx0Y29uc3QgaGFsZldpZHRoID0gdGhpcy53aWR0aCAqIDAuNTtcblx0XHRjb25zdCBpbm5lclJhZGl1cyA9IHRoaXMucmFkaXVzIC0gaGFsZldpZHRoO1xuXHRcdGNvbnN0IG91dGVyUmFkaXVzID0gdGhpcy5yYWRpdXMgKyBoYWxmV2lkdGg7XG5cdFx0cmV0dXJuIChkaXN0YW5jZVNxciA8PSAob3V0ZXJSYWRpdXMgKiBvdXRlclJhZGl1cykpICYmXG5cdFx0XHQoZGlzdGFuY2VTcXIgPj0gKGlubmVyUmFkaXVzICogaW5uZXJSYWRpdXMpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUZXN0IGlmIHRoZSBwcm92aWRlZCByZWN0YW5nbGUgaXMgd2l0aGluIHRoZSBpbm5lciBzaGFwZSBvZiB0aGVcblx0ICogY29sbGlkYWJsZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pblggLSBUaGUgbWluaW11bSB4IGNvbXBvbmVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heFggLSBUaGUgbWF4aW11bSB4IGNvbXBvbmVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pblkgLSBUaGUgbWluaW11bSB5IGNvbXBvbmVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heFkgLSBUaGUgbWF4aW11bSB5IGNvbXBvbmVudC5cblx0ICpcblx0ICogQHJldHVybnMge2Jvb2x9IFdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIGFuIGludGVyc2VjdGlvbi5cblx0ICovXG5cdHRlc3RSZWN0YW5nbGUobWluWCwgbWF4WCwgbWluWSwgbWF4WSkge1xuXHRcdC8vIGNpcmNsZSBwb3Ncblx0XHRjb25zdCBjeCA9ICh0aGlzLm1pblggKyB0aGlzLm1heFgpICogMC41O1xuXHRcdGNvbnN0IGN5ID0gKHRoaXMubWluWSArIHRoaXMubWF4WSkgKiAwLjU7XG5cdFx0Ly8gZmluZCB0aGUgZnVydGhlc3QgcG9pbnRzIG9uIHJlY3RhbmdsZSBmcm9tIHRoZSBjaXJjbGVcblx0XHRsZXQgZnVydGhlc3RYLCBmdXJ0aGVzdFkgPSAwO1xuXHRcdGlmIChNYXRoLmFicyhjeCAtIG1pblgpIDwgTWF0aC5hYnMoY3ggLSBtYXhYKSkge1xuXHRcdFx0ZnVydGhlc3RYID0gbWF4WDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZnVydGhlc3RYID0gbWluWDtcblx0XHR9XG5cdFx0aWYgKE1hdGguYWJzKGN5IC0gbWluWSkgPCBNYXRoLmFicyhjeSAtIG1heFkpKSB7XG5cdFx0XHRmdXJ0aGVzdFkgPSBtYXhZO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmdXJ0aGVzdFkgPSBtaW5ZO1xuXHRcdH1cblx0XHQvLyBjaGVjayBpZiB0aGVyZSBpcyBhbnkgaW50ZXJzZWN0aW9uIHdpdGggdGhlIGlubmVyIGNpcmNsZVxuXHRcdGNvbnN0IGZ4ID0gY3ggLSBmdXJ0aGVzdFg7XG5cdFx0Y29uc3QgZnkgPSBjeSAtIGZ1cnRoZXN0WTtcblx0XHRjb25zdCBoYWxmV2lkdGggPSB0aGlzLndpZHRoICogMC41O1xuXHRcdGNvbnN0IGlubmVyUmFkaXVzID0gdGhpcy5yYWRpdXMgLSBoYWxmV2lkdGg7XG5cdFx0aWYgKChmeCAqIGZ4ICsgZnkgKiBmeSkgPCAoaW5uZXJSYWRpdXMgKiBpbm5lclJhZGl1cykpIHtcblx0XHRcdC8vIHJlY3RhbmdsZSBpcyBjb21wbGV0ZWx5IGluc2lkZSB0aGUgcmluZyBhbmQgY2Fubm90IGludGVyc2VjdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHQvLyBvdGhlcndpc2UganVzdCBkbyBhIGNpcmNsZSAtIGFhYmIgdGVzdCBmb3Igb3V0ZXIgY2lyY2xlXG5cdFx0Ly8gZmluZCBjbG9zZXN0IHBvaW50IGluIHJlY3RhbmdsZSB0byBjaXJjbGVcblx0XHRjb25zdCBuZWFyZXN0WCA9IGNsYW1wKGN4LCBtaW5YLCBtYXhYKTtcblx0XHRjb25zdCBuZWFyZXN0WSA9IGNsYW1wKGN5LCBtaW5ZLCBtYXhZKTtcblx0XHQvLyB0ZXN0IGRpc3RhbmNlXG5cdFx0Y29uc3QgZHggPSBjeCAtIG5lYXJlc3RYO1xuXHRcdGNvbnN0IGR5ID0gY3kgLSBuZWFyZXN0WTtcblx0XHRjb25zdCBvdXRlclJhZGl1cyA9IHRoaXMucmFkaXVzICsgaGFsZldpZHRoO1xuXHRcdHJldHVybiAoZHggKiBkeCArIGR5ICogZHkpIDwgKG91dGVyUmFkaXVzICogb3V0ZXJSYWRpdXMpO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmluZ0NvbGxpZGFibGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNsYW1wID0gcmVxdWlyZSgnbG9kYXNoL2NsYW1wJyk7XG5jb25zdCBkZWZhdWx0VG8gPSByZXF1aXJlKCdsb2Rhc2gvZGVmYXVsdFRvJyk7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IEV2ZW50ID0gcmVxdWlyZSgnLi4vZXZlbnQvRXZlbnQnKTtcbmNvbnN0IEV2ZW50VHlwZSA9IHJlcXVpcmUoJy4uL2V2ZW50L0V2ZW50VHlwZScpO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGxheWVyIGNvbXBvbmVudC5cbiAqL1xuY2xhc3MgTGF5ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgTGF5ZXIgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5vcGFjaXR5IC0gVGhlIGxheWVyIG9wYWNpdHkuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnpJbmRleCAtIFRoZSBsYXllciB6LWluZGV4LlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuaGlkZGVuIC0gV2hldGhlciBvciBub3QgdGhlIGxheWVyIGlzIHZpc2libGUuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMub3BhY2l0eSA9IGRlZmF1bHRUbyhvcHRpb25zLm9wYWNpdHksIDEuMCk7XG5cdFx0dGhpcy5oaWRkZW4gPSBkZWZhdWx0VG8ob3B0aW9ucy5oaWRkZW4sIGZhbHNlKTtcblx0XHR0aGlzLnpJbmRleCA9IGRlZmF1bHRUbyhvcHRpb25zLnpJbmRleCwgMCk7XG5cdFx0dGhpcy5yZW5kZXJlciA9IGRlZmF1bHRUbyhvcHRpb25zLnJlbmRlcmVyLCBudWxsKTtcblx0XHR0aGlzLmhpZ2hsaWdodGVkID0gbnVsbDtcblx0XHR0aGlzLnNlbGVjdGVkID0gW107XG5cdFx0dGhpcy5wbG90ID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBFeGVjdXRlZCB3aGVuIHRoZSBsYXllciBpcyBhdHRhY2hlZCB0byBhIHBsb3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UGxvdH0gcGxvdCAtIFRoZSBwbG90IHRvIGF0dGFjaCB0aGUgbGF5ZXIgdG8uXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtMYXllcn0gVGhlIGxheWVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0b25BZGQocGxvdCkge1xuXHRcdGlmICghcGxvdCkge1xuXHRcdFx0dGhyb3cgJ05vIHBsb3QgYXJndW1lbnQgcHJvdmlkZWQnO1xuXHRcdH1cblx0XHQvLyBzZXQgcGxvdFxuXHRcdHRoaXMucGxvdCA9IHBsb3Q7XG5cdFx0Ly8gZmxhZyBhcyBkaXJ0eVxuXHRcdHRoaXMucGxvdC5zZXREaXJ0eSgpO1xuXHRcdC8vIGV4ZWN1dGUgcmVuZGVyZXIgaG9va1xuXHRcdGlmICh0aGlzLnJlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLnJlbmRlcmVyLm9uQWRkKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBFeGVjdXRlZCB3aGVuIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gYSBwbG90LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1Bsb3R9IHBsb3QgLSBUaGUgcGxvdCB0byByZW1vdmUgdGhlIGxheWVyIGZyb20uXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtMYXllcn0gVGhlIGxheWVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0b25SZW1vdmUocGxvdCkge1xuXHRcdGlmICghcGxvdCkge1xuXHRcdFx0dGhyb3cgJ05vIHBsb3QgYXJndW1lbnQgcHJvdmlkZWQnO1xuXHRcdH1cblx0XHQvLyBleGVjdXRlIHJlbmRlcmVyIGhvb2tcblx0XHRpZiAodGhpcy5yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5yZW5kZXJlci5vblJlbW92ZSh0aGlzKTtcblx0XHR9XG5cdFx0Ly8gY2xlYXIgc3RhdGVcblx0XHR0aGlzLmNsZWFyKCk7XG5cdFx0Ly8gZmxhZyBhcyBkaXJ0eVxuXHRcdHRoaXMucGxvdC5zZXREaXJ0eSgpO1xuXHRcdC8vIHJlbW92ZSBwbG90XG5cdFx0dGhpcy5wbG90ID0gbnVsbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgYSByZW5kZXJlciB0byB0aGUgbGF5ZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRvIGFkZCB0byB0aGUgbGF5ZXIuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtMYXllcn0gVGhlIGxheWVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0c2V0UmVuZGVyZXIocmVuZGVyZXIpIHtcblx0XHRpZiAoIXJlbmRlcmVyKSB7XG5cdFx0XHR0aHJvdyAnTm8gcmVuZGVyZXIgYXJndW1lbnQgcHJvdmlkZWQnO1xuXHRcdH1cblx0XHRpZiAodGhpcy5yZW5kZXJlciAmJiB0aGlzLnBsb3QpIHtcblx0XHRcdHRoaXMucmVuZGVyZXIub25SZW1vdmUodGhpcyk7XG5cdFx0fVxuXHRcdHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcblx0XHRpZiAodGhpcy5wbG90KSB7XG5cdFx0XHR0aGlzLnJlbmRlcmVyLm9uQWRkKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgdGhlIHJlbmRlcmVyIGZyb20gdGhlIGxheWVyLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7TGF5ZXJ9IFRoZSBsYXllciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHJlbW92ZVJlbmRlcmVyKCkge1xuXHRcdGlmICghdGhpcy5yZW5kZXJlcikge1xuXHRcdFx0dGhyb3cgJ05vIHJlbmRlcmVyIGlzIGN1cnJlbnRseSBhdHRhY2hlZCB0byB0aGUgbGF5ZXInO1xuXHRcdH1cblx0XHRpZiAodGhpcy5wbG90KSB7XG5cdFx0XHR0aGlzLnJlbmRlcmVyLm9uUmVtb3ZlKHRoaXMpO1xuXHRcdH1cblx0XHR0aGlzLnJlbmRlcmVyID0gbnVsbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSByZW5kZXJlciBvZiB0aGUgbGF5ZXIuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIG9iamVjdC5cblx0ICovXG5cdGdldFJlbmRlcmVyKCkge1xuXHRcdHJldHVybiB0aGlzLnJlbmRlcmVyO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IC0gVGhlIG9wYWNpdHkgdG8gc2V0LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7TGF5ZXJ9IFRoZSBsYXllciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHNldE9wYWNpdHkob3BhY2l0eSkge1xuXHRcdG9wYWNpdHkgPSBjbGFtcChvcGFjaXR5LCAwLCAxKTtcblx0XHRpZiAodGhpcy5vcGFjaXR5ICE9PSBvcGFjaXR5KSB7XG5cdFx0XHR0aGlzLm9wYWNpdHkgPSBvcGFjaXR5O1xuXHRcdFx0aWYgKHRoaXMucGxvdCkge1xuXHRcdFx0XHR0aGlzLnBsb3Quc2V0RGlydHkoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSBvcGFjaXR5IG9mIHRoZSBsYXllci5cblx0ICpcblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyIG9iamVjdCwuXG5cdCAqL1xuXHRnZXRPcGFjaXR5KCkge1xuXHRcdHJldHVybiB0aGlzLm9wYWNpdHk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRoZSB6LWluZGV4IG9mIHRoZSBsYXllci5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHpJbmRleCAtIFRoZSB6LWluZGV4IHRvIHNldC5cblx0ICpcblx0ICogQHJldHVybnMge0xheWVyfSBUaGUgbGF5ZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRzZXRaSW5kZXgoekluZGV4KSB7XG5cdFx0aWYgKHRoaXMuekluZGV4ICE9PSB6SW5kZXgpIHtcblx0XHRcdHRoaXMuekluZGV4ID0gekluZGV4O1xuXHRcdFx0aWYgKHRoaXMucGxvdCkge1xuXHRcdFx0XHR0aGlzLnBsb3Quc2V0RGlydHkoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSB6LWluZGV4IG9mIHRoZSBsYXllci5cblx0ICpcblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHpJbmRleCBvZiB0aGUgbGF5ZXIgb2JqZWN0LC5cblx0ICovXG5cdGdldFpJbmRleCgpIHtcblx0XHRyZXR1cm4gdGhpcy56SW5kZXg7XG5cdH1cblxuXHQvKipcblx0ICogTWFrZSB0aGUgbGF5ZXIgdmlzaWJsZS5cblx0ICpcblx0ICogQHJldHVybnMge0xheWVyfSBUaGUgbGF5ZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRzaG93KCkge1xuXHRcdGlmICh0aGlzLmhpZGRlbikge1xuXHRcdFx0dGhpcy5oaWRkZW4gPSBmYWxzZTtcblx0XHRcdGlmICh0aGlzLnBsb3QpIHtcblx0XHRcdFx0dGhpcy5wbG90LnNldERpcnR5KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1ha2UgdGhlIGxheWVyIGludmlzaWJsZS5cblx0ICpcblx0ICogQHJldHVybnMge0xheWVyfSBUaGUgbGF5ZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRoaWRlKCkge1xuXHRcdGlmICghdGhpcy5oaWRkZW4pIHtcblx0XHRcdHRoaXMuaGlkZGVuID0gdHJ1ZTtcblx0XHRcdGlmICh0aGlzLnJlbmRlcmVyKSB7XG5cdFx0XHRcdHRoaXMucmVuZGVyZXIuY2xlYXIoKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLnBsb3QpIHtcblx0XHRcdFx0dGhpcy5wbG90LnNldERpcnR5KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5ZXIgaXMgaGlkZGVuLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGxheWVyIGlzIGhpZGRlbi5cblx0ICovXG5cdGlzSGlkZGVuKCkge1xuXHRcdHJldHVybiB0aGlzLmhpZGRlbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBQaWNrIGEgcG9zaXRpb24gb2YgdGhlIGxheWVyIGZvciBhIGNvbGxpc2lvbiB3aXRoIGFueSByZW5kZXJlZCBvYmplY3RzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcG9zIC0gVGhlIHBsb3QgcG9zaXRpb24gdG8gcGljayBhdC5cblx0ICpcblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIGNvbGxpc2lvbiwgb3IgbnVsbC5cblx0ICovXG5cdHBpY2socG9zKSB7XG5cdFx0aWYgKHRoaXMucmVuZGVyZXIpIHtcblx0XHRcdHJldHVybiB0aGlzLnJlbmRlcmVyLnBpY2socG9zKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogSGlnaGxpZ2h0cyB0aGUgcHJvdmlkZWQgZGF0YS5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSB0byBoaWdobGlnaHQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtMYXllcn0gVGhlIGxheWVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0aGlnaGxpZ2h0KGRhdGEpIHtcblx0XHRpZiAodGhpcy5oaWdobGlnaHRlZCAhPT0gZGF0YSkge1xuXHRcdFx0dGhpcy5oaWdobGlnaHRlZCA9IGRhdGE7XG5cdFx0XHRpZiAodGhpcy5wbG90KSB7XG5cdFx0XHRcdHRoaXMucGxvdC5zZXREaXJ0eSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhcnMgYW55IGN1cnJlbnQgaGlnaGxpZ2h0LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7TGF5ZXJ9IFRoZSBsYXllciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHVuaGlnaGxpZ2h0KCkge1xuXHRcdGlmICh0aGlzLmhpZ2hsaWdodGVkICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLmhpZ2hsaWdodGVkID0gbnVsbDtcblx0XHRcdGlmICh0aGlzLnBsb3QpIHtcblx0XHRcdFx0dGhpcy5wbG90LnNldERpcnR5KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW55IGhpZ2hsaWdodGVkIGRhdGEuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBoaWdobGlnaHRlZCBkYXRhLlxuXHQgKi9cblx0Z2V0SGlnaGxpZ2h0ZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaGlnaGxpZ2h0ZWQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBhcmd1bWVudCBpcyBoaWdobGlnaHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSB0byB0ZXN0LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlcmUgaXMgaGlnaGxpZ2h0ZWQgZGF0YS5cblx0ICovXG5cdGlzSGlnaGxpZ2h0ZWQoZGF0YSkge1xuXHRcdHJldHVybiB0aGlzLmhpZ2hsaWdodGVkID09PSBkYXRhO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlbGVjdHMgdGhlIHByb3ZpZGVkIGRhdGEuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VsZWN0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gbXVsdGlTZWxlY3QgLSBXaGV0aGVyIG11dGxpLXNlbGVjdCBpcyBlbmFibGVkLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7TGF5ZXJ9IFRoZSBsYXllciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHNlbGVjdChkYXRhLCBtdWx0aVNlbGVjdCkge1xuXHRcdGxldCBjaGFuZ2VkID0gZmFsc2U7XG5cdFx0aWYgKG11bHRpU2VsZWN0KSB7XG5cdFx0XHQvLyBhZGQgdG8gY29sbGVjdGlvbiBpZiBtdWx0aS1zZWxlY3Rpb24gaXMgZW5hYmxlZFxuXHRcdFx0Y29uc3QgaW5kZXggPSB0aGlzLnNlbGVjdGVkLmluZGV4T2YoZGF0YSk7XG5cdFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG5cdFx0XHRcdC8vIHNlbGVjdCBwb2ludFxuXHRcdFx0XHR0aGlzLnNlbGVjdGVkLnB1c2goZGF0YSk7XG5cdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBjbGVhciBzZWxlY3Rpb24sIGFkZGluZyBvbmx5IHRoZSBsYXRlc3QgZW50cnlcblx0XHRcdGlmICh0aGlzLnNlbGVjdGVkLmxlbmd0aCAhPT0gMSB8fCB0aGlzLnNlbGVjdGVkWzBdICE9PSBkYXRhKSB7XG5cdFx0XHRcdHRoaXMuc2VsZWN0ZWQgPSBbIGRhdGEgXTtcblx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0aGlzLnBsb3QgJiYgY2hhbmdlZCkge1xuXHRcdFx0dGhpcy5wbG90LnNldERpcnR5KCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZSB0aGUgcHJvdmlkZWQgZGF0YSBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSB0byB1bnNlbGVjdC5cblx0ICpcblx0ICogQHJldHVybnMge0xheWVyfSBUaGUgbGF5ZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHR1bnNlbGVjdChkYXRhKSB7XG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLnNlbGVjdGVkLmluZGV4T2YoZGF0YSk7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0Ly8gdW5zZWxlY3QgcG9pbnRcblx0XHRcdHRoaXMuc2VsZWN0ZWQuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdGlmICh0aGlzLnBsb3QpIHtcblx0XHRcdFx0dGhpcy5wbG90LnNldERpcnR5KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFycyB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtMYXllcn0gVGhlIGxheWVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0dW5zZWxlY3RBbGwoKSB7XG5cdFx0aWYgKHRoaXMuc2VsZWN0ZWQubGVuZ3RoID4gMCkge1xuXHRcdFx0Ly8gdW5zZWxlY3QgYWxsXG5cdFx0XHR0aGlzLnNlbGVjdGVkID0gW107XG5cdFx0XHRpZiAodGhpcy5wbG90KSB7XG5cdFx0XHRcdHRoaXMucGxvdC5zZXREaXJ0eSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFueSBzZWxlY3RlZCBkYXRhLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBzZWxlY3RlZCBkYXRhLlxuXHQgKi9cblx0Z2V0U2VsZWN0ZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2VsZWN0ZWQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBhcmd1bWVudCBpcyBzZWxlY3RlZC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSB0byB0ZXN0LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGRhdGEgaXMgc2VsZWN0ZWQuXG5cdCAqL1xuXHRpc1NlbGVjdGVkKGRhdGEpIHtcblx0XHRyZXR1cm4gdGhpcy5zZWxlY3RlZC5pbmRleE9mKGRhdGEpICE9PSAtMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEcmF3IHRoZSBsYXllciBmb3IgdGhlIGZyYW1lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gVGhlIGZyYW1lIHRpbWVzdGFtcC5cblx0ICpcblx0ICogQHJldHVybnMge0xheWVyfSBUaGUgbGF5ZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRkcmF3KHRpbWVzdGFtcCkge1xuXHRcdGlmICh0aGlzLnJlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLnJlbmRlcmVyLmRyYXcodGltZXN0YW1wKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIGFueSBwZXJzaXN0ZWQgc3RhdGUgaW4gdGhlIGxheWVyLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7TGF5ZXJ9IFRoZSBsYXllciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdGNsZWFyKCkge1xuXHRcdC8vIGNsZWFyIHNlbGVjdGVkIC8gaGlnaGxpZ2h0ZWRcblx0XHRpZiAodGhpcy5oaWdobGlnaHRlZCB8fCB0aGlzLnNlbGVjdGVkLmxlbmd0aCA+IDApIHtcblx0XHRcdHRoaXMuaGlnaGxpZ2h0ZWQgPSBudWxsO1xuXHRcdFx0dGhpcy5zZWxlY3RlZCA9IFtdO1xuXHRcdH1cblx0XHQvLyBjbGVhciByZW5kZXJlciBzdGF0ZVxuXHRcdGlmICh0aGlzLnJlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLnJlbmRlcmVyLmNsZWFyKCk7XG5cdFx0fVxuXHRcdC8vIGZsYWcgYXMgZGlydHlcblx0XHRpZiAodGhpcy5wbG90KSB7XG5cdFx0XHR0aGlzLnBsb3Quc2V0RGlydHkoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIGFueSBwZXJzaXN0ZWQgc3RhdGUgaW4gdGhlIGxheWVyIGFuZCByZWZyZXNoZXMgdGhlIHVuZGVybHlpbmdcblx0ICogZGF0YS5cblx0ICpcblx0ICogQHJldHVybnMge0xheWVyfSBUaGUgbGF5ZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRyZWZyZXNoKCkge1xuXHRcdC8vIGNsZWFyIHRoZSBsYXllciBzdGF0ZVxuXHRcdHRoaXMuY2xlYXIoKTtcblx0XHQvLyBlbWl0IHJlZnJlc2ggZXZlbnRcblx0XHR0aGlzLmVtaXQoRXZlbnRUeXBlLlJFRlJFU0gsIG5ldyBFdmVudCh0aGlzKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMYXllcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRUeXBlID0gcmVxdWlyZSgnLi4vLi4vZXZlbnQvRXZlbnRUeXBlJyk7XG5jb25zdCBMYXllciA9IHJlcXVpcmUoJy4uL0xheWVyJyk7XG5cbi8vIENvbnN0YW50c1xuXG4vKipcbiAqIENlbGwgdXBkYXRlIGV2ZW50IGhhbmRsZXIgc3ltYm9sLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxuICovXG5jb25zdCBDRUxMX1VQREFURSA9IFN5bWJvbCgpO1xuXG4vKipcbiAqIENsaXBwZWQgZ2VvbWV0cnkgc3ltYm9sLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxuICovXG5jb25zdCBDTElQUEVEID0gU3ltYm9sKCk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIG92ZXJsYXkgbGF5ZXIuXG4gKi9cbmNsYXNzIE92ZXJsYXkgZXh0ZW5kcyBMYXllciB7XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBPdmVybGF5IG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3ZlcmxheSBvcHRpb25zLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5vcGFjaXR5IC0gVGhlIG92ZXJsYXkgb3BhY2l0eS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuekluZGV4IC0gVGhlIG92ZXJsYXkgei1pbmRleC5cblx0ICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmhpZGRlbiAtIFdoZXRoZXIgb3Igbm90IHRoZSBvdmVybGF5IGlzIHZpc2libGUuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcblx0XHRzdXBlcihvcHRpb25zKTtcblx0XHR0aGlzW0NMSVBQRURdID0gbnVsbDtcblx0XHR0aGlzW0NFTExfVVBEQVRFXSA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgb3ZlcmxheSBpcyBhdHRhY2hlZCB0byBhIHBsb3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UGxvdH0gcGxvdCAtIFRoZSBwbG90IHRvIGF0dGFjaCB0aGUgb3ZlcmxheSB0by5cblx0ICpcblx0ICogQHJldHVybnMge092ZXJsYXl9IFRoZSBvdmVybGF5IG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0b25BZGQocGxvdCkge1xuXHRcdHN1cGVyLm9uQWRkKHBsb3QpO1xuXHRcdC8vIGNsaXAgZXhpc3RpbmcgZ2VvbWV0cnlcblx0XHR0aGlzLnJlZnJlc2goKTtcblx0XHQvLyBjcmVhdGUgY2VsbCB1cGRhdGUgaGFuZGxlclxuXHRcdHRoaXNbQ0VMTF9VUERBVEVdID0gKCkgPT4ge1xuXHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0fTtcblx0XHQvLyBhdHRhY2ggaGFuZGxlclxuXHRcdHRoaXMucGxvdC5vbihFdmVudFR5cGUuQ0VMTF9VUERBVEUsIHRoaXNbQ0VMTF9VUERBVEVdKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBFeGVjdXRlZCB3aGVuIHRoZSBvdmVybGF5IGlzIHJlbW92ZWQgZnJvbSBhIHBsb3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UGxvdH0gcGxvdCAtIFRoZSBwbG90IHRvIHJlbW92ZSB0aGUgb3ZlcmxheSBmcm9tLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T3ZlcmxheX0gVGhlIG92ZXJsYXkgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRvblJlbW92ZShwbG90KSB7XG5cdFx0Ly8gcmVtb3ZlIGNsaXBwZWQgZ2VvbWV0cnlcblx0XHR0aGlzW0NMSVBQRURdID0gbnVsbDtcblx0XHQvLyByZW1vdmUgaGFuZGxlclxuXHRcdHRoaXMucGxvdC5yZW1vdmVMaXN0ZW5lcihFdmVudFR5cGUuQ0VMTF9VUERBVEUsIHRoaXNbQ0VMTF9VUERBVEVdKTtcblx0XHQvLyBjcmVhdGUgcmVmcmVzaCBoYW5kbGVyXG5cdFx0dGhpc1tDRUxMX1VQREFURV0gPSBudWxsO1xuXHRcdHN1cGVyLm9uUmVtb3ZlKHBsb3QpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVubXV0ZXMgYW5kIHNob3dzIHRoZSBvdmVybGF5LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T3ZlcmxheX0gVGhlIG92ZXJsYXkgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRlbmFibGUoKSB7XG5cdFx0dGhpcy5zaG93KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogTXV0ZXMgYW5kIGhpZGVzIHRoZSBvdmVybGF5LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T3ZlcmxheX0gVGhlIG92ZXJsYXkgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRkaXNhYmxlKCkge1xuXHRcdHRoaXMuaGlkZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgb3ZlcmxheSBpcyBkaXNhYmxlZC5cblx0ICpcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvdmVybGF5IGlzIGRpc2FibGVkLlxuXHQgKi9cblx0aXNEaXNhYmxlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5pc0hpZGRlbigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFycyBhbnkgcGVyc2lzdGVkIHN0YXRlIGluIHRoZSBvdmVybGF5IGFuZCByZWZyZXNoZXMgdGhlIHVuZGVybHlpbmdcblx0ICogZGF0YS4gVGhpcyBpbnZvbHZlcyByZWZyZXNoaW5nIHRoZSBzdG9yZWQgY2xpcHBlZCBnZW9tZXRyeSBvZiB0aGVcblx0ICogb3ZlcmxheSBiYXNlZCB0aGUgY3VycmVudCByZW5kZXJpbmcgY2VsbCBvZiB0aGUgcGxvdC5cblx0ICpcblx0ICogQHJldHVybnMge092ZXJsYXl9IFRoZSBvdmVybGF5IG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0cmVmcmVzaCgpIHtcblx0XHRpZiAodGhpcy5wbG90KSB7XG5cdFx0XHR0aGlzW0NMSVBQRURdID0gdGhpcy5jbGlwR2VvbWV0cnkodGhpcy5wbG90LmNlbGwpO1xuXHRcdH1cblx0XHRzdXBlci5yZWZyZXNoKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogR2l2ZW4gYW4gYXJyYXkgb2YgcG9pbnQgYmFzZWQgZ2VvbWV0cnksIHJldHVybiB0aGUgY2xpcHBlZCBnZW9tZXRyeS5cblx0ICpcblx0ICogQHBhcmFtIHtDZWxsfSBjZWxsIC0gVGhlIHJlbmRlcmluZyBjZWxsLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBvZiBjbGlwcGVkIGdlb21ldHJ5LlxuXHQgKi9cblx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblx0Y2xpcEdlb21ldHJ5KGNlbGwpIHtcblx0XHR0aHJvdyAnYGNsaXBHZW9tZXRyeWAgbXVzdCBiZSBvdmVycmlkZGVuJztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjbGlwcGVkIGdlb21ldHJ5IGZvciB0aGUgb3ZlcmxheS5cblx0ICpcblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2YgY2xpcHBlZCBnZW9tZXRyeS5cblx0ICovXG5cdGdldENsaXBwZWRHZW9tZXRyeSgpIHtcblx0XHRyZXR1cm4gdGhpc1tDTElQUEVEXTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE92ZXJsYXk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE92ZXJsYXkgPSByZXF1aXJlKCcuL092ZXJsYXknKTtcblxuLy8gUHJpdmF0ZSBNZXRob2RzXG5cbmNvbnN0IGNsaXBQb2ludHMgPSBmdW5jdGlvbihjZWxsLCBwb2ludHMpIHtcblx0Y29uc3QgY2xpcHBlZCA9IFtdO1xuXHRwb2ludHMuZm9yRWFjaChwdHMgPT4ge1xuXHRcdGNvbnN0IGNsaXBwZWRQb2ludHMgPSBjZWxsLmJvdW5kcy5jbGlwUG9pbnRzKHB0cyk7XG5cdFx0aWYgKCFjbGlwcGVkUG9pbnRzKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGZvciAobGV0IGk9MDsgaTxjbGlwcGVkUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjbGlwcGVkLnB1c2goY2VsbC5wcm9qZWN0KGNsaXBwZWRQb2ludHNbaV0pKTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gY2xpcHBlZDtcbn07XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgcG9pbnQgb3ZlcmxheS5cbiAqL1xuY2xhc3MgUG9pbnRPdmVybGF5IGV4dGVuZHMgT3ZlcmxheSB7XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBQb2ludE92ZXJsYXkgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBsYXllciBvcHRpb25zLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5vcGFjaXR5IC0gVGhlIGxheWVyIG9wYWNpdHkuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnpJbmRleCAtIFRoZSBsYXllciB6LWluZGV4LlxuXHQgKi9cblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cdFx0dGhpcy5wb2ludHMgPSBuZXcgTWFwKCk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkIGEgc2V0IG9mIHBvaW50cyB0byByZW5kZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIFRoZSBpZCB0byBzdG9yZSB0aGUgcG9pbnRzIHVuZGVyLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgLSBUaGUgcG9pbnRzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UG9pbnRPdmVybGF5fSBUaGUgb3ZlcmxheSBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdGFkZFBvaW50cyhpZCwgcG9pbnRzKSB7XG5cdFx0dGhpcy5wb2ludHMuc2V0KGlkLCBwb2ludHMpO1xuXHRcdGlmICh0aGlzLnBsb3QpIHtcblx0XHRcdHRoaXMucmVmcmVzaCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYSBzZXQgb2YgcG9pbnRzIGJ5IGlkIGZyb20gdGhlIG92ZXJsYXkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIFRoZSBpZCB0byBzdG9yZSB0aGUgcG9pbnRzIHVuZGVyLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UG9pbnRPdmVybGF5fSBUaGUgb3ZlcmxheSBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHJlbW92ZVBvaW50cyhpZCkge1xuXHRcdHRoaXMucG9pbnRzLmRlbGV0ZShpZCk7XG5cdFx0aWYgKHRoaXMucGxvdCkge1xuXHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbGwgcG9pbnRzIGZyb20gdGhlIGxheWVyLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UG9pbnRPdmVybGF5fSBUaGUgb3ZlcmxheSBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdGNsZWFyUG9pbnRzKCkge1xuXHRcdHRoaXMuY2xlYXIoKTtcblx0XHR0aGlzLnBvaW50cyA9IG5ldyBNYXAoKTtcblx0XHRpZiAodGhpcy5wbG90KSB7XG5cdFx0XHR0aGlzLnJlZnJlc2goKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogR2l2ZW4gYW4gYXJyYXkgb2YgcG9pbnQgYmFzZWQgZ2VvbWV0cnksIHJldHVybiB0aGUgY2xpcHBlZCBnZW9tZXRyeS5cblx0ICpcblx0ICogQHBhcmFtIHtDZWxsfSBjZWxsIC0gVGhlIHJlbmRlcmluZyBjZWxsLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBvZiBjbGlwcGVkIGdlb21ldHJ5LlxuXHQgKi9cblx0Y2xpcEdlb21ldHJ5KGNlbGwpIHtcblx0XHRyZXR1cm4gY2xpcFBvaW50cyhjZWxsLCB0aGlzLnBvaW50cyk7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludE92ZXJsYXk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE92ZXJsYXkgPSByZXF1aXJlKCcuL092ZXJsYXknKTtcblxuLy8gUHJpdmF0ZSBNZXRob2RzXG5cbmNvbnN0IGNsaXBQb2x5Z29ucyA9IGZ1bmN0aW9uKGNlbGwsIHBvbHlnb25zKSB7XG5cdGNvbnN0IGNsaXBwZWQgPSBbXTtcblx0cG9seWdvbnMuZm9yRWFjaChwb2x5Z29uID0+IHtcblx0XHRjb25zdCBjbGlwcGVkUG9seWdvbiA9IGNlbGwuYm91bmRzLmNsaXBQb2x5Z29uKHBvbHlnb24pO1xuXHRcdGlmICghY2xpcHBlZFBvbHlnb24pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Y29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KGNsaXBwZWRQb2x5Z29uLmxlbmd0aCk7XG5cdFx0Zm9yIChsZXQgaT0wOyBpPGNsaXBwZWRQb2x5Z29uLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRyZXN1bHRbaV0gPSBjZWxsLnByb2plY3QoY2xpcHBlZFBvbHlnb25baV0pO1xuXHRcdH1cblx0XHRjbGlwcGVkLnB1c2gocmVzdWx0KTtcblx0fSk7XG5cdHJldHVybiBjbGlwcGVkO1xufTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBwb2x5Z29uIG92ZXJsYXkuXG4gKi9cbmNsYXNzIFBvbHlnb25PdmVybGF5IGV4dGVuZHMgT3ZlcmxheSB7XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBQb2x5Z29uT3ZlcmxheSBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIGxheWVyIG9wdGlvbnMuXG5cdCAqIEBwYXJhbSB7UmVuZGVyZXJ9IG9wdGlvbnMucmVuZGVyZXIgLSBUaGUgbGF5ZXIgcmVuZGVyZXIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm9wYWNpdHkgLSBUaGUgbGF5ZXIgb3BhY2l0eS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuekluZGV4IC0gVGhlIGxheWVyIHotaW5kZXguXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcblx0XHRzdXBlcihvcHRpb25zKTtcblx0XHR0aGlzLnBvbHlnb25zID0gbmV3IE1hcCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCBhIHNldCBvZiBwb2ludHMgdG8gcmVuZGVyIGFzIGEgc2luZ2xlIHBvbHlnb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIFRoZSBpZCB0byBzdG9yZSB0aGUgcG9seWdvbiB1bmRlci5cblx0ICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIC0gVGhlIHBvbHlnb24gcG9pbnRzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UG9seWdvbk92ZXJsYXl9IFRoZSBvdmVybGF5IG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0YWRkUG9seWdvbihpZCwgcG9pbnRzKSB7XG5cdFx0dGhpcy5wb2x5Z29ucy5zZXQoaWQsIHBvaW50cyk7XG5cdFx0aWYgKHRoaXMucGxvdCkge1xuXHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhIHBvbHlnb24gYnkgaWQgZnJvbSB0aGUgb3ZlcmxheS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIGlkIHRvIHN0b3JlIHRoZSBwb2x5Z29uIHVuZGVyLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UG9seWdvbk92ZXJsYXl9IFRoZSBvdmVybGF5IG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0cmVtb3ZlUG9seWdvbihpZCkge1xuXHRcdHRoaXMucG9seWdvbnMuZGVsZXRlKGlkKTtcblx0XHRpZiAodGhpcy5wbG90KSB7XG5cdFx0XHR0aGlzLnJlZnJlc2goKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlIGFsbCBwb2x5Z29ucyBmcm9tIHRoZSBsYXllci5cblx0ICpcblx0ICogQHJldHVybnMge1BvbHlnb25PdmVybGF5fSBUaGUgb3ZlcmxheSBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdGNsZWFyUG9seWxpbmVzKCkge1xuXHRcdHRoaXMuY2xlYXIoKTtcblx0XHR0aGlzLnBvbHlnb25zID0gbmV3IE1hcCgpO1xuXHRcdGlmICh0aGlzLnBsb3QpIHtcblx0XHRcdHRoaXMucmVmcmVzaCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBHaXZlbiBhbiBhcnJheSBvZiBwb2ludCBiYXNlZCBnZW9tZXRyeSwgcmV0dXJuIHRoZSBjbGlwcGVkIGdlb21ldHJ5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0NlbGx9IGNlbGwgLSBUaGUgcmVuZGVyaW5nIGNlbGwuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFycmF5IG9mIGNsaXBwZWQgZ2VvbWV0cnkuXG5cdCAqL1xuXHRjbGlwR2VvbWV0cnkoY2VsbCkge1xuXHRcdHJldHVybiBjbGlwUG9seWdvbnMoY2VsbCwgdGhpcy5wb2x5Z29ucyk7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uT3ZlcmxheTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgT3ZlcmxheSA9IHJlcXVpcmUoJy4vT3ZlcmxheScpO1xuXG4vLyBQcml2YXRlIE1ldGhvZHNcblxuY29uc3QgY2xpcFBvbHlsaW5lcyA9IGZ1bmN0aW9uKGNlbGwsIHBvbHlsaW5lcykge1xuXHRjb25zdCBjbGlwcGVkID0gW107XG5cdHBvbHlsaW5lcy5mb3JFYWNoKHBvbHlsaW5lID0+IHtcblx0XHQvLyBjbGlwIHRoZSBwb2x5bGluZSwgcmVzdWx0aW5nIGluIG11bHRpcGxlIGNsaXBwZWQgcG9seWxpbmVzXG5cdFx0Y29uc3QgY2xpcHBlZFBvbHlsaW5lcyA9IGNlbGwuYm91bmRzLmNsaXBQb2x5bGluZShwb2x5bGluZSk7XG5cdFx0aWYgKCFjbGlwcGVkUG9seWxpbmVzKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGZvciAobGV0IGk9MDsgaTxjbGlwcGVkUG9seWxpbmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBjbGlwcGVkUG9seWxpbmUgPSBjbGlwcGVkUG9seWxpbmVzW2ldO1xuXHRcdFx0Zm9yIChsZXQgaj0wOyBqPGNsaXBwZWRQb2x5bGluZS5sZW5ndGg7IGorKykge1xuXHRcdFx0XHQvLyBwcm9qZWN0IGluIHBsYWNlXG5cdFx0XHRcdGNsaXBwZWRQb2x5bGluZVtqXSA9IGNlbGwucHJvamVjdChjbGlwcGVkUG9seWxpbmVbal0pO1xuXHRcdFx0fVxuXHRcdFx0Y2xpcHBlZC5wdXNoKGNsaXBwZWRQb2x5bGluZSk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGNsaXBwZWQ7XG59O1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHBvbHlsaW5lIG92ZXJsYXkuXG4gKi9cbmNsYXNzIFBvbHlsaW5lT3ZlcmxheSBleHRlbmRzIE92ZXJsYXkge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgUG9seWxpbmVPdmVybGF5IG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgbGF5ZXIgb3B0aW9ucy5cblx0ICogQHBhcmFtIHtSZW5kZXJlcn0gb3B0aW9ucy5yZW5kZXJlciAtIFRoZSBsYXllciByZW5kZXJlci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMub3BhY2l0eSAtIFRoZSBsYXllciBvcGFjaXR5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy56SW5kZXggLSBUaGUgbGF5ZXIgei1pbmRleC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuXHRcdHN1cGVyKG9wdGlvbnMpO1xuXHRcdHRoaXMucG9seWxpbmVzID0gbmV3IE1hcCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCBhIHNldCBvZiBwb2ludHMgdG8gcmVuZGVyIGFzIGEgc2luZ2xlIHBvbHlsaW5lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBUaGUgaWQgdG8gc3RvcmUgdGhlIHBvbHlsaW5lIHVuZGVyLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgLSBUaGUgcG9seWxpbmUgcG9pbnRzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UG9seWxpbmVPdmVybGF5fSBUaGUgb3ZlcmxheSBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdGFkZFBvbHlsaW5lKGlkLCBwb2ludHMpIHtcblx0XHR0aGlzLnBvbHlsaW5lcy5zZXQoaWQsIHBvaW50cyk7XG5cdFx0aWYgKHRoaXMucGxvdCkge1xuXHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhIHBvbHlsaW5lIGJ5IGlkIGZyb20gdGhlIG92ZXJsYXkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIFRoZSBpZCB0byBzdG9yZSB0aGUgcG9seWxpbmUgdW5kZXIuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtQb2x5bGluZU92ZXJsYXl9IFRoZSBvdmVybGF5IG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0cmVtb3ZlUG9seWxpbmUoaWQpIHtcblx0XHR0aGlzLnBvbHlsaW5lcy5kZWxldGUoaWQpO1xuXHRcdGlmICh0aGlzLnBsb3QpIHtcblx0XHRcdHRoaXMucmVmcmVzaCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIHBvbHlsaW5lcyBmcm9tIHRoZSBsYXllci5cblx0ICpcblx0ICogQHJldHVybnMge1BvbHlsaW5lT3ZlcmxheX0gVGhlIG92ZXJsYXkgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRjbGVhclBvbHlsaW5lcygpIHtcblx0XHR0aGlzLmNsZWFyKCk7XG5cdFx0dGhpcy5wb2x5bGluZXMgPSBuZXcgTWFwKCk7XG5cdFx0aWYgKHRoaXMucGxvdCkge1xuXHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdpdmVuIGFuIGFycmF5IG9mIHBvaW50IGJhc2VkIGdlb21ldHJ5LCByZXR1cm4gdGhlIGNsaXBwZWQgZ2VvbWV0cnkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Q2VsbH0gY2VsbCAtIFRoZSByZW5kZXJpbmcgY2VsbC5cblx0ICpcblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2YgY2xpcHBlZCBnZW9tZXRyeS5cblx0ICovXG5cdGNsaXBHZW9tZXRyeShjZWxsKSB7XG5cdFx0cmV0dXJuIGNsaXBQb2x5bGluZXMoY2VsbCwgdGhpcy5wb2x5bGluZXMpO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUG9seWxpbmVPdmVybGF5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBDb25zdGFudHNcblxuLyoqXG4gKiBNYXhpbXVtIHNhZmUgaW50ZWdlci5cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnQge251bWJlcn1cbiAqL1xuY29uc3QgTUFYX1NBRkVfSU5UID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxuLy8gUHJpdmF0ZSBNZXRob2RzXG5cbmxldCB1aWQgPSAxO1xuY29uc3QgZ2V0VUlEID0gZnVuY3Rpb24oKSB7XG5cdHVpZCA9ICh1aWQgKyAxKSAlIE1BWF9TQUZFX0lOVDtcblx0cmV0dXJuIHVpZDtcbn07XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgdGlsZS5cbiAqL1xuY2xhc3MgVGlsZSB7XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBUaWxlIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtUaWxlQ29vcmR9IGNvb3JkIC0gVGhlIGNvb3JkIG9mIHRoZSB0aWxlLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoY29vcmQpIHtcblx0XHR0aGlzLmNvb3JkID0gY29vcmQ7XG5cdFx0dGhpcy51aWQgPSBnZXRVSUQoKTtcblx0XHR0aGlzLmRhdGEgPSBudWxsO1xuXHRcdHRoaXMuZXJyID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIFByaXZhdGUgTWV0aG9kc1xuXG5jb25zdCBtb2QgPSBmdW5jdGlvbihuLCBtKSB7XG5cdHJldHVybiAoKG4gJSBtKSArIG0pICUgbTtcbn07XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgdGlsZSBjb29yZGluYXRlLlxuICovXG5jbGFzcyBUaWxlQ29vcmQge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgVGlsZUNvb3JkIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHogLSBUaGUgeiBjb21wb25lbnQgb2YgdGhlIHRpbGUgY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHRpbGUgY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHRpbGUgY29vcmRpbmF0ZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKHosIHgsIHkpIHtcblx0XHR0aGlzLnogPSB6O1xuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLmhhc2ggPSBgJHt0aGlzLnp9OiR7dGhpcy54fToke3RoaXMueX1gO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIFhZWiBVUkwgc3RyaW5nLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgWFlaIFVSTCBzdHJpbmcuXG5cdCAqL1xuXHR4eXooKSB7XG5cdFx0Y29uc3QgZGltID0gTWF0aC5wb3coMiwgdGhpcy56KTtcblx0XHRyZXR1cm4gYCR7dGhpcy56fS8ke3RoaXMueH0vJHtkaW0gLSAxIC0gdGhpcy55fWA7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgVE1TIFVSTCBzdHJpbmcuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBUTVMgVVJMIHN0cmluZy5cblx0ICovXG5cdHRtcygpIHtcblx0XHRyZXR1cm4gYCR7dGhpcy56fS8ke3RoaXMueH0vJHt0aGlzLnl9YDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUZXN0IGlmIHRoZSBib3VuZHMgZXF1YWxzIGFub3RoZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VGlsZUNvb3JkfSBjb29yZCAtIFRoZSBjb29yZCBvYmplY3QgdG8gdGVzdC5cblx0ICpcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBjb29yZCBvYmplY3RzIGFyZSBlcXVhbC5cblx0ICovXG5cdGVxdWFscyhjb29yZCkge1xuXHRcdHJldHVybiB0aGlzLnogPT09IGNvb3JkLnogJiZcblx0XHRcdHRoaXMueCA9PT0gY29vcmQueCAmJlxuXHRcdFx0dGhpcy55ID09PSBjb29yZC55O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgYW5jZXN0b3IgY29vcmQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IG9mIHRoZSBhbmNlc3RvciBmcm9tIHRoZSBjb29yZC4gT3B0aW9uYWwuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtUaWxlQ29vcmR9IFRoZSBhbmNlc3RvciBjb29yZC5cblx0ICovXG5cdGdldEFuY2VzdG9yKG9mZnNldCA9IDEpIHtcblx0XHRjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIG9mZnNldCk7XG5cdFx0cmV0dXJuIG5ldyBUaWxlQ29vcmQoXG5cdFx0XHR0aGlzLnogLSBvZmZzZXQsXG5cdFx0XHRNYXRoLmZsb29yKHRoaXMueCAvIHNjYWxlKSxcblx0XHRcdE1hdGguZmxvb3IodGhpcy55IC8gc2NhbGUpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGRlc2NlbmRhbnRzIG9mIHRoZSBjb29yZC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgb2YgdGhlIGRlc2NlbmRhbnRzIGZyb20gdGhlIGNvb3JkLiBPcHRpb25hbC5cblx0ICpcblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2YgZGVzY2VuZGFudCBjb29yZHMuXG5cdCAqL1xuXHRnZXREZXNjZW5kYW50cyhvZmZzZXQgPSAxKSB7XG5cdFx0Y29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCBvZmZzZXQpO1xuXHRcdGNvbnN0IGNvb3JkcyA9IG5ldyBBcnJheShzY2FsZSpzY2FsZSk7XG5cdFx0Zm9yIChsZXQgeD0wOyB4PHNjYWxlOyB4KyspIHtcblx0XHRcdGNvbnN0IHN0cmlkZSA9IHggKiBzY2FsZTtcblx0XHRcdGZvciAobGV0IHk9MDsgeTxzY2FsZTsgeSsrKSB7XG5cdFx0XHRcdGNvb3Jkc1tzdHJpZGUgKyB5XSA9IG5ldyBUaWxlQ29vcmQoXG5cdFx0XHRcdFx0dGhpcy56ICsgb2Zmc2V0LFxuXHRcdFx0XHRcdHRoaXMueCAqIHNjYWxlICsgeCxcblx0XHRcdFx0XHR0aGlzLnkgKiBzY2FsZSArIHkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY29vcmRzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRlc3QgaWYgdGhlIGNvb3JkIGlzIGFuIGFuY2VzdG9yIG9mIHRoZSBwcm92aWRlZCBjb29yZC5cblx0ICpcblx0ICogQHBhcmFtIHtUaWxlQ29vcmR9IGNvb3JkIC0gVGhlIGNvb3JkIG9iamVjdCB0byB0ZXN0LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIHByb3ZpZGVkIGNvb3JkIGlzIGFuIGFuY2VzdG9yLlxuXHQgKi9cblx0aXNBbmNlc3Rvck9mKGNvb3JkKSB7XG5cdFx0aWYgKHRoaXMueiA+PSBjb29yZC56KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGNvbnN0IGRpZmYgPSBjb29yZC56IC0gdGhpcy56O1xuXHRcdGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMiwgZGlmZik7XG5cdFx0Y29uc3QgeCA9IE1hdGguZmxvb3IoY29vcmQueCAvIHNjYWxlKTtcblx0XHRpZiAodGhpcy54ICE9PSB4KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGNvbnN0IHkgPSBNYXRoLmZsb29yKGNvb3JkLnkgLyBzY2FsZSk7XG5cdFx0cmV0dXJuIHRoaXMueSA9PT0geTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUZXN0IGlmIHRoZSBjb29yZCBpcyBhIGRlc2NlbmRhbnQgb2YgdGhlIHByb3ZpZGVkIGNvb3JkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1RpbGVDb29yZH0gY29vcmQgLSBUaGUgY29vcmQgb2JqZWN0IHRvIHRlc3QuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZWQgY29vcmQgaXMgYSBkZXNjZW5kYW50LlxuXHQgKi9cblx0aXNEZXNjZW5kYW50T2YoY29vcmQpIHtcblx0XHRyZXR1cm4gY29vcmQuaXNBbmNlc3Rvck9mKHRoaXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG5vcm1hbGl6ZWQgY29vcmQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtUaWxlQ29vcmR9IFRoZSBub3JtYWxpemVkIGNvb3JkLlxuXHQgKi9cblx0bm9ybWFsaXplKCkge1xuXHRcdGNvbnN0IGRpbSA9IE1hdGgucG93KDIsIHRoaXMueik7XG5cdFx0cmV0dXJuIG5ldyBUaWxlQ29vcmQoXG5cdFx0XHR0aGlzLnosXG5cdFx0XHRtb2QodGhpcy54LCBkaW0pLFxuXHRcdFx0bW9kKHRoaXMueSwgZGltKSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgcGxvdCBjb29yZGluYXRlIGZvciB0aGUgYm90dG9tLWxlZnQgY29ybmVyIG9mIHRoZSBjb29yZC5cblx0ICpcblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIHBsb3QgcG9zaXRpb24gb2YgdGhlIGNvb3JkLlxuXHQgKi9cblx0Z2V0UG9zaXRpb24oKSB7XG5cdFx0Y29uc3QgZGltID0gTWF0aC5wb3coMiwgdGhpcy56KTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdGhpcy54IC8gZGltLFxuXHRcdFx0eTogdGhpcy55IC8gZGltXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBwbG90IGNvb3JkaW5hdGUgZm9yIHRoZSBjZW50ZXIgb2YgdGhlIGNvb3JkLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcGxvdCBwb3NpdGlvbiBvZiB0aGUgY2VudGVyLlxuXHQgKi9cblx0Z2V0Q2VudGVyKCkge1xuXHRcdGNvbnN0IGRpbSA9IE1hdGgucG93KDIsIHRoaXMueik7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6ICh0aGlzLnggKyAwLjUpIC8gZGltLFxuXHRcdFx0eTogKHRoaXMueSArIDAuNSkgLyBkaW1cblx0XHR9O1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGlsZUNvb3JkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkZWZhdWx0VG8gPSByZXF1aXJlKCdsb2Rhc2gvZGVmYXVsdFRvJyk7XG5jb25zdCBMYXllciA9IHJlcXVpcmUoJy4uL0xheWVyJyk7XG5jb25zdCBUaWxlUHlyYW1pZCA9IHJlcXVpcmUoJy4vVGlsZVB5cmFtaWQnKTtcblxuLy8gUHJpdmF0ZSBNZXRob2RzXG5cbmNvbnN0IHJlcXVlc3RWaXNpYmxlVGlsZXMgPSBmdW5jdGlvbihsYXllcikge1xuXHQvLyBnZXQgdmlzaWJsZSBjb29yZHNcblx0Y29uc3QgY29vcmRzID0gbGF5ZXIucGxvdC5nZXRUYXJnZXRWaXNpYmxlQ29vcmRzKCk7XG5cdC8vIHJlcXVlc3QgdGlsZXNcblx0bGF5ZXIucmVxdWVzdFRpbGVzKGNvb3Jkcyk7XG59O1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHRpbGUtYmFzZWQgbGF5ZXIuXG4gKi9cbmNsYXNzIFRpbGVMYXllciBleHRlbmRzIExheWVyIHtcblxuXHQvKipcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IFRpbGVMYXllciBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIGxheWVyIG9wdGlvbnMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm9wYWNpdHkgLSBUaGUgbGF5ZXIgb3BhY2l0eS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuekluZGV4IC0gVGhlIGxheWVyIHotaW5kZXguXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5oaWRkZW4gLSBXaGV0aGVyIG9yIG5vdCB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cblx0ICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLm11dGVkIC0gV2hldGhlciBvciBub3QgdGhlIGxheWVyIGlzIG11dGVkLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jYWNoZVNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgdGVtcG9yYXJ5IHRpbGUgY2FjaGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm51bVBlcnNpc3RlbnRMZXZlbHMgLSBUaGUgbnVtYmVyIG9mIHBlcnNpc3RlbnQgbGV2ZWxzIGluIHRoZSB0aWxlIHB5cmFtaWQuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcblx0XHRzdXBlcihvcHRpb25zKTtcblx0XHR0aGlzLm11dGVkID0gZGVmYXVsdFRvKG9wdGlvbnMubXV0ZWQsIGZhbHNlKTtcblx0XHR0aGlzLnB5cmFtaWQgPSBuZXcgVGlsZVB5cmFtaWQodGhpcywgb3B0aW9ucyk7XG5cdH1cblxuXHQvKipcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgbGF5ZXIgaXMgYXR0YWNoZWQgdG8gYSBwbG90LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1Bsb3R9IHBsb3QgLSBUaGUgcGxvdCB0byBhdHRhY2ggdGhlIGxheWVyIHRvLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7VGlsZUxheWVyfSBUaGUgbGF5ZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRvbkFkZChwbG90KSB7XG5cdFx0c3VwZXIub25BZGQocGxvdCk7XG5cdFx0Ly8gcmVxdWVzdCB0aWxlcyBpZiBub3QgbXV0ZWRcblx0XHRpZiAoIXRoaXMuaXNNdXRlZCgpKSB7XG5cdFx0XHRyZXF1ZXN0VmlzaWJsZVRpbGVzKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBFeGVjdXRlZCB3aGVuIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gYSBwbG90LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1Bsb3R9IHBsb3QgLSBUaGUgcGxvdCB0byByZW1vdmUgdGhlIGxheWVyIGZyb20uXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtUaWxlTGF5ZXJ9IFRoZSBsYXllciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdG9uUmVtb3ZlKHBsb3QpIHtcblx0XHQvLyBjbGVhciB0aGUgdW5kZXJseWluZyBweXJhbWlkXG5cdFx0dGhpcy5weXJhbWlkLmNsZWFyKCk7XG5cdFx0c3VwZXIub25SZW1vdmUocGxvdCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdGlsZSBweXJhbWlkIG9mIHRoZSBsYXllci5cblx0ICpcblx0ICogQHJldHVybnMge1RpbGVQeXJhbWlkfSBUaGUgdGlsZSBweXJhbWlkIG9iamVjdC5cblx0ICovXG5cdGdldFB5cmFtaWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMucHlyYW1pZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBNYWtlIHRoZSBsYXllciBpbnZpc2libGUuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtUaWxlTGF5ZXJ9IFRoZSBsYXllciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdGhpZGUoKSB7XG5cdFx0c3VwZXIuaGlkZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIE11dGVzIHRoZSBsYXllciwgaXQgd2lsbCBubyBsb25nZXIgc2VuZCBhbnkgdGlsZSByZXF1ZXN0cy5cblx0ICpcblx0ICogQHJldHVybnMge1RpbGVMYXllcn0gVGhlIGxheWVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0bXV0ZSgpIHtcblx0XHR0aGlzLm11dGVkID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBVbm11dGVzIHRoZSBsYXllciBhbmQgaW1tZWRpYXRlbHkgcmVxdWVzdHMgYWxsIHZpc2libGUgdGlsZXMuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtUaWxlTGF5ZXJ9IFRoZSBsYXllciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHVubXV0ZSgpIHtcblx0XHRpZiAodGhpcy5pc011dGVkKCkpIHtcblx0XHRcdHRoaXMubXV0ZWQgPSBmYWxzZTtcblx0XHRcdGlmICh0aGlzLnBsb3QpIHtcblx0XHRcdFx0Ly8gcmVxdWVzdCB2aXNpYmxlIHRpbGVzXG5cdFx0XHRcdHJlcXVlc3RWaXNpYmxlVGlsZXModGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5ZXIgaXMgbXV0ZWQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgbGF5ZXIgaXMgbXV0ZWQuXG5cdCAqL1xuXHRpc011dGVkKCkge1xuXHRcdHJldHVybiB0aGlzLm11dGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVubXV0ZXMgYW5kIHNob3dzIHRoZSBsYXllci5cblx0ICpcblx0ICogQHJldHVybnMge1RpbGVMYXllcn0gVGhlIGxheWVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0ZW5hYmxlKCkge1xuXHRcdHRoaXMuc2hvdygpO1xuXHRcdHRoaXMudW5tdXRlKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogTXV0ZXMgYW5kIGhpZGVzIHRoZSBsYXllci5cblx0ICpcblx0ICogQHJldHVybnMge1RpbGVMYXllcn0gVGhlIGxheWVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0ZGlzYWJsZSgpIHtcblx0XHR0aGlzLmhpZGUoKTtcblx0XHR0aGlzLm11dGUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGxheWVyIGlzIGRpc2FibGVkIChtdXRlZCBhbmQgaGlkZGVuKS5cblx0ICpcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBsYXllciBpcyBkaXNhYmxlZC5cblx0ICovXG5cdGlzRGlzYWJsZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNNdXRlZCgpICYmIHRoaXMuaXNIaWRkZW4oKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhcnMgYW55IHBlcnNpc3RlZCBzdGF0ZSBpbiB0aGUgbGF5ZXIgYW5kIHJlZnJlc2hlcyB0aGUgdW5kZXJseWluZ1xuXHQgKiBkYXRhLiBUaGlzIGludm9sdmVzIGVtcHR5aW5nIHRoZSB0aWxlIHB5cmFtaWQgYW5kIHJlLXJlcXVlc3RpbmcgYWxsIHRoZVxuXHQgKiB0aWxlcy5cblx0ICpcblx0ICogQHJldHVybnMge1RpbGVMYXllcn0gVGhlIGxheWVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0IC8qKlxuIFx0ICogQ2xlYXJzIGFueSBwZXJzaXN0ZWQgc3RhdGUgaW4gdGhlIGxheWVyIGFuZCByZWZyZXNoZXMgdGhlIHVuZGVybHlpbmdcbiBcdCAqIGRhdGEuXG4gXHQgKi9cblx0cmVmcmVzaCgpIHtcblx0XHQvLyBjbGVhciB0aGUgdW5kZXJseWluZyBweXJhbWlkXG5cdFx0dGhpcy5weXJhbWlkLmNsZWFyKCk7XG5cdFx0Ly8gcmVxdWVzdCBpZiBhdHRhY2hlZCBhbmQgbm90IG11dGVkXG5cdFx0aWYgKHRoaXMucGxvdCAmJiAhdGhpcy5pc011dGVkKCkpIHtcblx0XHRcdC8vIHJlcXVlc3QgdmlzaWJsZSB0aWxlc1xuXHRcdFx0cmVxdWVzdFZpc2libGVUaWxlcyh0aGlzKTtcblx0XHR9XG5cdFx0c3VwZXIucmVmcmVzaCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlcXVlc3QgYSBzcGVjaWZpYyB0aWxlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1RpbGVDb29yZH0gY29vcmQgLSBUaGUgY29vcmQgb2YgdGhlIHRpbGUgdG8gcmVxdWVzdC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZSAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlIHVwb24gY29tcGxldGlvbi5cblx0ICovXG5cdHJlcXVlc3RUaWxlKGNvb3JkLCBkb25lKSB7XG5cdFx0ZG9uZShudWxsLCBudWxsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXF1ZXN0IGFuIGFycmF5IG9mIHRpbGVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb29yZHMgLSBUaGUgY29vcmRzIG9mIHRoZSB0aWxlcyB0byByZXF1ZXN0LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7VGlsZUxheWVyfSBUaGUgbGF5ZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRyZXF1ZXN0VGlsZXMoY29vcmRzKSB7XG5cdFx0aWYgKHRoaXMuaXNNdXRlZCgpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0dGhpcy5weXJhbWlkLnJlcXVlc3RUaWxlcyhjb29yZHMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGlsZUxheWVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHBhcnRpYWwgdGlsZS5cbiAqL1xuY2xhc3MgVGlsZVBhcnRpYWwge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgVGlsZVBhcnRpYWwgb2JqZWN0LlxuXHQgKlxuXHQgKiBBIFRpbGVQYXJ0aWFsIGlzIHVzZWQgdG8gcmVuZGVyIGF0IGxlYXN0IGEgcG9ydGlvbiBvZiBhIG1pc3NpbmcgdGlsZSBhdFxuXHQgKiB0aGUgY2xvc2VzdCBhdmFpbGFibGUgbGV2ZWwtb2YtZGV0YWlsLiBUaGVyZSBhcmUgdGhyZWUgY2FzZXMgb2Zcblx0ICogaW5zdGFudGlhdGlvbi5cblx0ICpcblx0ICogQSkgQ2xvc2VzdCBhdmFpbGFibGUgbGV2ZWwtb2YtZGV0YWlsIGlzIGFuIGFuY2VzdG9yIHRpbGUuXG5cdCAqICAgIC0gVGhlIFwidGFyZ2V0XCIgdGlsZSBpcyBjb21wbGV0ZWx5IGNvdmVyZWQgYnkgYSBwb3J0aW9uIG9mIHRoZSBcImZvdW5kXCJcblx0ICogICAgICB0aWxlLlxuXHQgKiAgICAtIFRoZXJlIGlzIG5vIHBvc2l0aW9uYWwgb2Zmc2V0IG5vciBzY2FsaW5nIG9mIHRoZSBcImZvdW5kXCIgdGlsZSwgaXRcblx0ICogICAgICB3aWxsIGNvdmVyIHRoZSBcInRhcmdldFwiIHRpbGUgaW4gaXRzIGVudGlyZWx5LlxuXHQgKiAgICAtIFRoZXJlIGlzIGEgdXYgb2Zmc2V0IHRvIHJlbmRlciB0aGUgcmVsZXZhbnQgcG9ydGlvbiBvZiB0aGUgXCJmb3VuZFwiXG5cdCAqICAgICAgdGlsZS5cblx0ICpcblx0ICogQikgQ2xvc2VzdCBhdmFpbGFibGUgbGV2ZWwtb2YtZGV0YWlsIGlzIGEgZGVzY2VuZGFudCB0aWxlLlxuXHQgKiAgICAtIFRoZSBcInRhcmdldFwiIHRpbGUgaXMgcGFydGlhbGx5IGNvdmVyZWQgYnkgdGhlIFwiZm91bmRcIiB0aWxlLlxuXHQgKiAgICAtIFRoZXJlIGlzIGEgcG9zaXRpb25hbCBvZmZzZXQgYW5kIHNjYWxlIG9mIHRoZSBcImZvdW5kXCIgdGlsZSByZWxhdGl2ZVxuXHQgKiAgICAgIHRvIHRoZSBcInRhcmdldFwiIHRpbGUuXG5cdCAqICAgIC0gVGhlcmUgaXMgbm8gdXYgb2Zmc2V0LCB0aGUgXCJmb3VuZFwiIHRpbGUgaXMgcmVuZGVyZWQgaW4gaXRzIGVudGlyZXR5LlxuXHQgKlxuXHQgKiBDKSBDbG9zZXN0IGF2YWlsYWJsZSBsZXZlbC1vZi1kZXRhaWwgaXMgYW4gYW5jZXN0b3Igb2YgdGhlIFwidGFyZ2V0XCIsIGJ1dFxuXHQgKiAgICBpcyB1c2VkIHRvIGNvdmVyIGEgbWlzc2luZyBkZXNjZW5kYW50LiBUaGlzIG9jY3VycyB3aGVuIG9uZSBvciBtb3JlXG5cdCAqICAgIGRlc2NlbmRhbnQgdGlsZXMgY292ZXIgYSBwb3J0aW9uIG9mIHRoZSBcInRhcmdldFwiIHRpbGUsIGJ1dCBhbiBhbmNlc3RvclxuXHQgKiAgICBpcyByZXF1aXJlZCB0byBmaWxsIGluIGEgbWlzc2luZyBkZXNjZW5kYW50LlxuXHQgKiAgICAtIFRoZSBcInRhcmdldFwiIHRpbGUgaXMgcGFydGlhbGx5IGNvdmVyZWQgYnkgdGhlIFwiZm91bmRcIiB0aWxlLlxuXHQgKiAgICAtIFRoZXJlIGlzIGEgcG9zaXRpb25hbCBvZmZzZXQgYW5kIHNjYWxlIG9mIHRoZSBcImZvdW5kXCIgdGlsZSByZWxhdGl2ZVxuXHQgKiAgICAgIHRvIHRoZSBkZXNjZW5kYW50IHRoZSB0aWxlIGlzIGNvdmVyaW5nLlxuXHQgKiAgICAtIFRoZXJlIGlzIGEgdXYgb2Zmc2V0IHRvIHJlbmRlciB0aGUgcmVsZXZhbnQgcG9ydGlvbiBvZiB0aGUgXCJmb3VuZFwiXG5cdCAqICAgICAgdGlsZSB3aGljaCBjb3ZlcnMgdGhlIGRlc2NlbmRhbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Q29vcmR9IHRhcmdldCAtIFRoZSBjb29yZGluYXRlIG9mIHRoZSB0aWxlIHRoYXQgaXMgYmVpbmcgc3Vic3RpdHV0ZWQuXG5cdCAqIEBwYXJhbSB7VGlsZX0gdGlsZSAtIFRoZSB0aWxlIGRhdGEgb2YgdGhlIHBhcnRpYWwgZm91bmQuXG5cdCAqIEBwYXJhbSB7Q29vcmR9IHJlbGF0aXZlIC0gVGhlIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUgdG8gcG9zaXRpb24gdGhlIGZvdW5kIHRpbGUgcmVsYXRpdmUgdG8uXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih0YXJnZXQsIHRpbGUsIHJlbGF0aXZlKSB7XG5cdFx0dGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cdFx0dGhpcy50aWxlID0gdGlsZTtcblx0XHR0aGlzLnJlbGF0aXZlID0gcmVsYXRpdmU7XG5cdH1cblxuXHQvKipcblx0ICogSW5zdGFudGlhdGUgYSBUaWxlUGFydGlhbCBvYmplY3QgZnJvbSB0aGUgdGlsZSBpdHNlbGYuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VGlsZX0gdGlsZSAtIFRoZSB0aWxlIGRhdGEgb2YgdGhlIHBhcnRpYWwuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtUaWxlUGFydGlhbH0gVGhlIFRpbGVQYXJ0aWFsIG9iamVjdC5cblx0ICovXG5cdHN0YXRpYyBmcm9tVGlsZSh0aWxlKSB7XG5cdFx0cmV0dXJuIG5ldyBUaWxlUGFydGlhbCh0aWxlLCB0aWxlLCBudWxsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZSBhIFRpbGVQYXJ0aWFsIG9iamVjdCBmcm9tIGFuIGFuY2VzdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Nvb3JkfSB0YXJnZXQgLSBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSB0aGF0IGlzIGJlaW5nIHN1YnN0aXR1dGVkLlxuXHQgKiBAcGFyYW0ge1RpbGV9IHRpbGUgLSBUaGUgdGlsZSBhbmNlc3RvciBkYXRhIG9mIHRoZSBwYXJ0aWFsLlxuXHQgKiBAcGFyYW0ge0Nvb3JkfSByZWxhdGl2ZSAtIFRoZSBjb29yZGluYXRlIG9mIHRoZSB0aWxlIHRvIHBvc2l0aW9uIHRoZSBmb3VuZCB0aWxlIHJlbGF0aXZlIHRvLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7VGlsZVBhcnRpYWx9IFRoZSBUaWxlUGFydGlhbCBvYmplY3QuXG5cdCAqL1xuXHRzdGF0aWMgZnJvbUFuY2VzdG9yKHRhcmdldCwgdGlsZSwgcmVsYXRpdmUpIHtcblx0XHRyZXR1cm4gbmV3IFRpbGVQYXJ0aWFsKHRhcmdldCwgdGlsZSwgcmVsYXRpdmUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlIGEgVGlsZVBhcnRpYWwgb2JqZWN0IGZyb20gYSBkZXNjZW5kYW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Nvb3JkfSB0YXJnZXQgLSBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSB0aGF0IGlzIGJlaW5nIHN1YnN0aXR1dGVkLlxuXHQgKiBAcGFyYW0ge1RpbGV9IHRpbGUgLSBUaGUgdGlsZSBhbmNlc3RvciBkYXRhIG9mIHRoZSBwYXJ0aWFsLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7VGlsZVBhcnRpYWx9IFRoZSBUaWxlUGFydGlhbCBvYmplY3QuXG5cdCAqL1xuIFx0c3RhdGljIGZyb21EZXNjZW5kYW50KHRhcmdldCwgdGlsZSkge1xuIFx0XHRyZXR1cm4gbmV3IFRpbGVQYXJ0aWFsKHRhcmdldCwgdGlsZSwgbnVsbCk7XG4gXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGlsZVBhcnRpYWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGRlZmF1bHRUbyA9IHJlcXVpcmUoJ2xvZGFzaC9kZWZhdWx0VG8nKTtcbmNvbnN0IHRocm90dGxlID0gcmVxdWlyZSgnbG9kYXNoL3Rocm90dGxlJyk7XG5jb25zdCBFdmVudFR5cGUgPSByZXF1aXJlKCcuLi8uLi9ldmVudC9FdmVudFR5cGUnKTtcbmNvbnN0IFRpbGVFdmVudCA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50L1RpbGVFdmVudCcpO1xuY29uc3QgTFJVQ2FjaGUgPSByZXF1aXJlKCcuLi8uLi91dGlsL0xSVUNhY2hlJyk7XG5jb25zdCBUaWxlID0gcmVxdWlyZSgnLi9UaWxlJyk7XG5jb25zdCBUaWxlUGFydGlhbCA9IHJlcXVpcmUoJy4vVGlsZVBhcnRpYWwnKTtcblxuLy8gQ29uc3RhbnRzXG5cbi8qKlxuICogbnVtYmVyIG9mIHRoZSB0aWxlcyBoZWxkIGluIHRoZSBweXJhbWlkLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7bnVtYmVyfVxuICovXG5jb25zdCBDQUNIRV9TSVpFID0gMjU2O1xuXG4vKipcbiAqIG51bWJlciBvZiBwZXJzaXN0ZW50IHpvb20gbGV2ZWxzIGhlbGQgaW4gdGhlIHB5cmFtaWRzLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7bnVtYmVyfVxuICovXG5jb25zdCBQRVJTSVNUQU5UX0xFVkVMUyA9IDQ7XG5cbi8qKlxuICogTG9hZGVkIGV2ZW50IHRocm90dGxlIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnQge251bWJlcn1cbiAqL1xuY29uc3QgTE9BREVEX1RIUk9UVExFX01TID0gMjAwO1xuXG4vKipcbiAqIFRoZSBtYXhpbXVtIGRpc3RhbmNlIHRvIHRyYXZlcnNlIHdoZW4gY2hlY2tpbmcgZm9yIHRpbGUgZGVzY2VuZGFudHMuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50IHtudW1iZXJ9XG4gKi9cbmNvbnN0IE1BWF9ERVNDRU5ERU5UX0RJU1QgPSA0O1xuXG4vLyBQcml2YXRlIE1ldGhvZHNcblxuY29uc3QgYWRkID0gZnVuY3Rpb24ocHlyYW1pZCwgdGlsZSkge1xuXHRpZiAodGlsZS5jb29yZC56IDwgcHlyYW1pZC5udW1QZXJzaXN0ZW50TGV2ZWxzKSB7XG5cdFx0Ly8gcGVyc2lzdGVudCB0aWxlc1xuXHRcdGlmIChweXJhbWlkLnBlcnNpc3RlbnRzLmhhcyh0aWxlLmNvb3JkLmhhc2gpKSB7XG5cdFx0XHR0aHJvdyBgVGlsZSBvZiBjb29yZCAke3RpbGUuY29vcmQuaGFzaH0gYWxyZWFkeSBleGlzdHMgaW4gdGhlIHB5cmFtaWRgO1xuXHRcdH1cblx0XHRweXJhbWlkLnBlcnNpc3RlbnRzLnNldCh0aWxlLmNvb3JkLmhhc2gsIHRpbGUpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIG5vbi1wZXJzaXN0ZW50IHRpbGVzXG5cdFx0aWYgKHB5cmFtaWQudGlsZXMuaGFzKHRpbGUuY29vcmQuaGFzaCkpIHtcblx0XHRcdHRocm93IGBUaWxlIG9mIGNvb3JkICR7dGlsZS5jb29yZC5oYXNofSBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgcHlyYW1pZGA7XG5cdFx0fVxuXHRcdHB5cmFtaWQudGlsZXMuc2V0KHRpbGUuY29vcmQuaGFzaCwgdGlsZSk7XG5cdH1cblx0Ly8gc3RvcmUgaW4gbGV2ZWwgYXJyYXlzXG5cdGlmICghcHlyYW1pZC5sZXZlbHMuaGFzKHRpbGUuY29vcmQueikpIHtcblx0XHRweXJhbWlkLmxldmVscy5zZXQodGlsZS5jb29yZC56LCBbXSk7XG5cdH1cblx0cHlyYW1pZC5sZXZlbHMuZ2V0KHRpbGUuY29vcmQueikucHVzaCh0aWxlKTtcblx0Ly8gZW1pdCBhZGRcblx0cHlyYW1pZC5sYXllci5lbWl0KEV2ZW50VHlwZS5USUxFX0FERCwgbmV3IFRpbGVFdmVudChweXJhbWlkLmxheWVyLCB0aWxlKSk7XG59O1xuXG5jb25zdCByZW1vdmUgPSBmdW5jdGlvbihweXJhbWlkLCB0aWxlKSB7XG5cdC8vIG9ubHkgY2hlY2sgZm9yIHBlcnNpc3RlbnQgc2luY2Ugd2UgaXQgd2lsbCBhbHJlYWR5IGJlIHJlbW92ZWQgZnJvbSBscnVcblx0Ly8gY2FjaGVcblx0aWYgKHRpbGUuY29vcmQueiA8IHB5cmFtaWQubnVtUGVyc2lzdGVudExldmVscykge1xuXHRcdGlmICghcHlyYW1pZC5wZXJzaXN0ZW50cy5oYXModGlsZS5jb29yZC5oYXNoKSkge1xuXHRcdFx0dGhyb3cgYFRpbGUgb2YgY29vcmQgJHt0aWxlLmNvb3JkLmhhc2h9IGRvZXMgbm90IGV4aXN0cyBpbiB0aGUgcHlyYW1pZGA7XG5cdFx0fVxuXHRcdHB5cmFtaWQucGVyc2lzdGVudHMuZGVsZXRlKHRpbGUuY29vcmQuaGFzaCk7XG5cdH1cblx0Ly8gcmVtb3ZlIGZyb20gbGV2ZWxzXG5cdGNvbnN0IGxldmVsID0gcHlyYW1pZC5sZXZlbHMuZ2V0KHRpbGUuY29vcmQueik7XG5cdGxldmVsLnNwbGljZShsZXZlbC5pbmRleE9mKHRpbGUpLCAxKTtcblx0aWYgKGxldmVsLmxlbmd0aCA9PT0gMCkge1xuXHRcdHB5cmFtaWQubGV2ZWxzLmRlbGV0ZSh0aWxlLmNvb3JkLnopO1xuXHR9XG5cdC8vIGVtaXQgcmVtb3ZlXG5cdHB5cmFtaWQubGF5ZXIuZW1pdChFdmVudFR5cGUuVElMRV9SRU1PVkUsIG5ldyBUaWxlRXZlbnQocHlyYW1pZC5sYXllciwgdGlsZSkpO1xufTtcblxuY29uc3Qgc3VtUG93ZXJPZkZvdXIgPSBmdW5jdGlvbihuKSB7XG5cdHJldHVybiAoMS8zKSAqIChNYXRoLnBvdyg0LCBuKSAtIDEpO1xufTtcblxuY29uc3QgY2hlY2tJZkxvYWRlZCA9IGZ1bmN0aW9uKHB5cmFtaWQpIHtcblx0Ly8gaWYgbm8gbW9yZSBwZW5kaW5nIHRpbGVzLCBlbWl0IGxvYWRcblx0aWYgKHB5cmFtaWQucGVuZGluZy5zaXplID09PSAwKSB7XG5cdFx0cHlyYW1pZC5lbWl0TG9hZChuZXcgVGlsZUV2ZW50KHB5cmFtaWQubGF5ZXIsIG51bGwpKTtcblx0fVxufTtcblxuY29uc3Qgc29ydEFyb3VuZENlbnRlciA9IGZ1bmN0aW9uKHBsb3QsIHBhaXJzKSB7XG5cdC8vIGdldCB0aGUgcGxvdCBjZW50ZXIgcG9zaXRpb25cblx0Y29uc3QgY2VudGVyID0gcGxvdC5nZXRUYXJnZXRWaWV3cG9ydENlbnRlcigpO1xuXHQvLyBzb3J0IHRoZSByZXF1ZXN0cyBieSBkaXN0YW5jZSBmcm9tIGNlbnRlciB0aWxlXG5cdHBhaXJzLnNvcnQoKGEsIGIpID0+IHtcblx0XHRjb25zdCBhQ2VudGVyID0gYS5jb29yZC5nZXRDZW50ZXIoKTtcblx0XHRjb25zdCBiQ2VudGVyID0gYi5jb29yZC5nZXRDZW50ZXIoKTtcblx0XHRjb25zdCBkYXggPSBjZW50ZXIueCAtIGFDZW50ZXIueDtcblx0XHRjb25zdCBkYXkgPSBjZW50ZXIueSAtIGFDZW50ZXIueTtcblx0XHRjb25zdCBkYnggPSBjZW50ZXIueCAtIGJDZW50ZXIueDtcblx0XHRjb25zdCBkYnkgPSBjZW50ZXIueSAtIGJDZW50ZXIueTtcblx0XHRjb25zdCBkYSA9IGRheCAqIGRheCArIGRheSAqIGRheTtcblx0XHRjb25zdCBkYiA9IGRieCAqIGRieCArIGRieSAqIGRieTtcblx0XHRyZXR1cm4gZGEgLSBkYjtcblx0fSk7XG5cdHJldHVybiBwYWlycztcbn07XG5cbmNvbnN0IHJlbW92ZUR1cGxpY2F0ZXMgPSBmdW5jdGlvbihwYWlycykge1xuXHRjb25zdCBzZWVuID0gbmV3IE1hcCgpO1xuXHRyZXR1cm4gcGFpcnMuZmlsdGVyKGZ1bmN0aW9uKHBhaXIpIHtcblx0XHRjb25zdCBoYXNoID0gcGFpci5uY29vcmQuaGFzaDtcblx0XHRyZXR1cm4gc2Vlbi5oYXMoaGFzaCkgPyBmYWxzZSA6IChzZWVuLnNldChoYXNoLCB0cnVlKSk7XG5cdH0pO1xufTtcblxuY29uc3QgcmVtb3ZlUGVuZGluZ09yRXhpc3RpbmcgPSBmdW5jdGlvbihweXJhbWlkLCBwYWlycykge1xuXHRyZXR1cm4gcGFpcnMuZmlsdGVyKHBhaXIgPT4ge1xuXHRcdC8vIHdlIGFscmVhZHkgaGF2ZSB0aGUgdGlsZSwgb3IgaXQncyBjdXJyZW50bHkgcGVuZGluZ1xuXHRcdC8vIE5PVEU6IHVzZSBgZ2V0YCBoZXJlIHRvIHVwZGF0ZSB0aGUgcmVjZW50bmVzcyBvZiB0aGUgdGlsZSBpbiBMUlVcblx0XHRyZXR1cm4gIXB5cmFtaWQuZ2V0KHBhaXIubmNvb3JkKSAmJiAhcHlyYW1pZC5pc1BlbmRpbmcocGFpci5uY29vcmQpO1xuXHR9KTtcbn07XG5cbmNvbnN0IGZsYWdUaWxlQXNTdGFsZSA9IGZ1bmN0aW9uKHB5cmFtaWQsIHRpbGUpIHtcblx0Y29uc3QgaGFzaCA9IHRpbGUuY29vcmQuaGFzaDtcblx0bGV0IHVpZHMgPSBweXJhbWlkLnN0YWxlLmdldChoYXNoKTtcblx0aWYgKCF1aWRzKSB7XG5cdFx0dWlkcyA9IG5ldyBNYXAoKTtcblx0XHRweXJhbWlkLnN0YWxlLnNldChoYXNoLCB1aWRzKTtcblx0fVxuXHR1aWRzLnNldCh0aWxlLnVpZCwgdHJ1ZSk7XG59O1xuXG5jb25zdCBpc1RpbGVTdGFsZSA9IGZ1bmN0aW9uKHB5cmFtaWQsIHRpbGUpIHtcblx0Y29uc3QgaGFzaCA9IHRpbGUuY29vcmQuaGFzaDtcblx0Ly8gY2hlY2sgaWYgdWlkIGlzIGZsYWdnZWQgYXMgc3RhbGVcblx0Y29uc3QgdWlkcyA9IHB5cmFtaWQuc3RhbGUuZ2V0KGhhc2gpO1xuXHRpZiAodWlkcyAmJiB1aWRzLmhhcyh0aWxlLnVpZCkpIHtcblx0XHQvLyB0aWxlIGlzIHN0YWxlXG5cdFx0dWlkcy5kZWxldGUodGlsZS51aWQpO1xuXHRcdGlmICh1aWRzLnNpemUgPT09IDApIHtcblx0XHRcdHB5cmFtaWQuc3RhbGUuZGVsZXRlKGhhc2gpO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBzaG91bGREaXNjYXJkID0gZnVuY3Rpb24ocHlyYW1pZCwgdGlsZSkge1xuXHRjb25zdCBwbG90ID0gcHlyYW1pZC5sYXllci5wbG90O1xuXHRpZiAoIXBsb3QpIHtcblx0XHQvLyBsYXllciBoYXMgYmVlbiByZW1vdmVkIGZyb20gcGxvdCwgZGlzY2FyZCB0aWxlXG5cdFx0Ly8gTk9URTogdGhpcyBzaG91bGQgX05FVkVSXyBoYXBwZW4sIHNpbmNlIHdoZW4gYSBsYXllciBpcyByZW1vdmUgZnJvbVxuXHRcdC8vIHRoZSBwbG90LCB0aGUgcGVuZGluZyB0aWxlcyBhcmUgYWxsIGZsYWdnZWQgYXMgc3RhbGUuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0Ly8gY2hlY2sgaWYgdGlsZSBpcyBpbiB2aWV3LCBpZiBub3QsIGRpc2NhcmRcblx0Y29uc3Qgdmlld3BvcnQgPSBwbG90LmdldFRhcmdldFZpZXdwb3J0KCk7XG5cdHJldHVybiAhdmlld3BvcnQuaXNJblZpZXcodGlsZS5jb29yZCwgcGxvdC53cmFwYXJvdW5kKTtcbn07XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgcHlyYW1pZCBvZiB0aWxlcy5cbiAqL1xuY2xhc3MgVGlsZVB5cmFtaWQge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgVGlsZVB5cmFtaWQgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0xheWVyfSBsYXllciAtIFRoZSBsYXllciBvYmplY3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHB5cmFtaWQgb3B0aW9ucy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2FjaGVTaXplIC0gVGhlIHNpemUgb2YgdGhlIHRpbGUgY2FjaGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm51bVBlcnNpc3RlbnRMZXZlbHMgLSBUaGUgbnVtYmVyIG9mIHBlcnNpc3RlbnQgbGV2ZWxzIGluIHRoZSBweXJhbWlkLlxuXHQgKi9cblx0Y29uc3RydWN0b3IobGF5ZXIsIG9wdGlvbnMgPSB7fSkge1xuXHRcdGlmICghbGF5ZXIpIHtcblx0XHRcdHRocm93ICdObyBsYXllciBwYXJhbWV0ZXIgcHJvdmlkZWQnO1xuXHRcdH1cblx0XHR0aGlzLmNhY2hlU2l6ZSA9IGRlZmF1bHRUbyhvcHRpb25zLmNhY2hlU2l6ZSwgQ0FDSEVfU0laRSk7XG5cdFx0dGhpcy5udW1QZXJzaXN0ZW50TGV2ZWxzID0gZGVmYXVsdFRvKG9wdGlvbnMubnVtUGVyc2lzdGVudExldmVscywgUEVSU0lTVEFOVF9MRVZFTFMpO1xuXHRcdHRoaXMubGF5ZXIgPSBsYXllcjtcblx0XHR0aGlzLmxldmVscyA9IG5ldyBNYXAoKTtcblx0XHR0aGlzLnBlcnNpc3RlbnRzID0gbmV3IE1hcCgpO1xuXHRcdHRoaXMucGVuZGluZyA9IG5ldyBNYXAoKTtcblx0XHR0aGlzLnN0YWxlID0gbmV3IE1hcCgpO1xuXHRcdHRoaXMudGlsZXMgPSBuZXcgTFJVQ2FjaGUoe1xuXHRcdFx0Y2FwYWNpdHk6IHRoaXMuY2FjaGVTaXplLFxuXHRcdFx0b25SZW1vdmU6IHRpbGUgPT4ge1xuXHRcdFx0XHRyZW1vdmUodGhpcywgdGlsZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0Ly8gY3JlYXRlIHRocm90dGxlZCBlbWl0IGxvYWQgZXZlbnQgZm9yIHRoaXMgbGF5ZXJcblx0XHR0aGlzLmVtaXRMb2FkID0gdGhyb3R0bGUoZXZlbnQgPT4ge1xuXHRcdFx0dGhpcy5sYXllci5lbWl0KEV2ZW50VHlwZS5MT0FELCBldmVudCk7XG5cdFx0fSwgTE9BREVEX1RIUk9UVExFX01TKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0b3RhbCBjYXBhY2l0eSBvZiB0aGUgdGlsZSBweXJhbWlkLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgdG90YWwgY2FwYWNpdHkgb2YgdGhlIHB5cmFtaWQuXG5cdCAqL1xuXHRnZXRDYXBhY2l0eSgpIHtcblx0XHRyZXR1cm4gdGhpcy5jYWNoZVNpemUgKyBzdW1Qb3dlck9mRm91cih0aGlzLm51bVBlcnNpc3RlbnRMZXZlbHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVtcHRpZXMgdGhlIGN1cnJlbnQgcHlyYW1pZCBvZiBhbGwgdGlsZXMsIGZsYWdzIGFueSBwZW5kaW5nIHRpbGVzIGFzXG5cdCAqIHN0YWxlLlxuXHQgKi9cblx0Y2xlYXIoKSB7XG5cdFx0Ly8gYW55IHBlbmRpbmcgdGlsZXMgYXJlIG5vdyBmbGFnZ2VkIGFzIHN0YWxlXG5cdFx0dGhpcy5wZW5kaW5nLmZvckVhY2godGlsZSA9PiB7XG5cdFx0XHQvLyBmbGFnIHVpZCBhcyBzdGFsZVxuXHRcdFx0ZmxhZ1RpbGVBc1N0YWxlKHRoaXMsIHRpbGUpO1xuXHRcdH0pO1xuXHRcdHRoaXMucGVuZGluZyA9IG5ldyBNYXAoKTsgLy8gZnJlc2ggbWFwXG5cdFx0Ly8gY2xlYXIgcGVyc2lzdGVudCB0aWxlc1xuXHRcdHRoaXMucGVyc2lzdGVudHMuZm9yRWFjaCh0aWxlID0+IHtcblx0XHRcdHJlbW92ZSh0aGlzLCB0aWxlKTtcblx0XHR9KTtcblx0XHR0aGlzLnBlcnNpc3RlbnRzLmNsZWFyKCk7XG5cdFx0Ly8gY2xlYXIgbHJ1IGNhY2hlXG5cdFx0dGhpcy50aWxlcy5jbGVhcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRlc3Qgd2hldGhlciBvciBub3QgYSBjb29yZCBpcyBoZWxkIGluIGNhY2hlIGluIHRoZSBweXJhbWlkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1RpbGVDb29yZH0gbmNvb3JkIC0gVGhlIG5vcm1hbGl6ZWQgY29vcmQgdG8gdGVzdC5cblx0ICpcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBjb29yZCBleGlzdHMgaW4gdGhlIHB5cmFtaWQuXG5cdCAqL1xuXHRoYXMobmNvb3JkKSB7XG5cdFx0aWYgKG5jb29yZC56IDwgdGhpcy5udW1QZXJzaXN0ZW50TGV2ZWxzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wZXJzaXN0ZW50cy5oYXMobmNvb3JkLmhhc2gpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy50aWxlcy5oYXMobmNvb3JkLmhhc2gpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEl0ZXJhdGVzIG92ZXIgYW5kIGV4ZWN1dGVzIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBmb3IgYWxsIHRpbGVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdGlsZS5cblx0ICovXG5cdGZvckVhY2goZm4pIHtcblx0XHR0aGlzLnBlcnNpc3RlbnRzLmZvckVhY2goZm4pO1xuXHRcdHRoaXMudGlsZXMuZm9yRWFjaChmbik7XG5cdH1cblxuXHQvKipcblx0ICogVGVzdCB3aGV0aGVyIG9yIG5vdCBhIGNvb3JkIGlzIGN1cnJlbnRseSBwZW5kaW5nLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1RpbGVDb29yZH0gbmNvb3JkIC0gVGhlIG5vcm1hbGl6ZWQgY29vcmQgdG8gdGVzdC5cblx0ICpcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBjb29yZCBpcyBjdXJyZW50bHkgcGVuZGluZy5cblx0ICovXG5cdGlzUGVuZGluZyhuY29vcmQpIHtcblx0XHRyZXR1cm4gdGhpcy5wZW5kaW5nLmhhcyhuY29vcmQuaGFzaCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdGlsZSBtYXRjaGluZyB0aGUgcHJvdmlkZWQgY29vcmQuIElmIHRoZSB0aWxlIGRvZXMgbm90XG5cdCAqIGV4aXN0LCByZXR1cm5zIHVuZGVmaW5lZC5cblx0ICpcblx0ICogQHBhcmFtIHtUaWxlQ29vcmR9IG5jb29yZCAtIFRoZSBub3JtYWxpemVkIGNvb3JkIG9mIHRoZSB0aWxlIHRvIHJldHVybi5cblx0ICpcblx0ICogQHJldHVybnMge1RpbGV9IFRoZSB0aWxlIG9iamVjdC5cblx0ICovXG5cdGdldChuY29vcmQpIHtcblx0XHRpZiAobmNvb3JkLnogPCB0aGlzLm51bVBlcnNpc3RlbnRMZXZlbHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnBlcnNpc3RlbnRzLmdldChuY29vcmQuaGFzaCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnRpbGVzLmdldChuY29vcmQuaGFzaCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYW5jZXN0b3IgdGlsZSBvZiB0aGUgY29vcmQgYXQgdGhlIHByb3ZpZGVkIG9mZnNldC4gSWYgbm9cblx0ICogdGlsZSBleGlzdHMgaW4gdGhlIHB5cmFtaWQsIHJldHVybnMgdW5kZWZpbmVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1RpbGVDb29yZH0gbmNvb3JkIC0gVGhlIG5vcm1hbGl6ZWQgY29vcmQgb2YgdGhlIHRpbGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0IC0gVGhlIG9mZnNldCBmcm9tIHRoZSB0aWxlLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7VGlsZX0gVGhlIGFuY2VzdG9yIHRpbGUgb2YgdGhlIHByb3ZpZGVkIGNvb3JkLlxuXHQgKi9cblx0Z2V0QW5jZXN0b3IobmNvb3JkLCBkaXN0KSB7XG5cdFx0Y29uc3QgYW5jZXN0b3IgPSBuY29vcmQuZ2V0QW5jZXN0b3IoZGlzdCk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0KGFuY2VzdG9yKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkZXNjZW5kYW50IHRpbGVzIG9mIHRoZSBjb29yZCBhdCB0aGUgcHJvdmlkZWQgb2Zmc2V0LiBJZiBhdFxuXHQgKiBsZWFzdCBvbmUgdGlsZSBleGlzdHMgaW4gdGhlIHB5cmFtaWQsIGFuIGFycmF5IG9mIHNpemUgNF5kaXN0IHdpbGwgYmVcblx0ICogcmV0dXJuZWQuIEVhY2ggZWxlbWVudCB3aWxsIGVpdGhlciBiZSBhIHRpbGUgKGluIHRoZSBjYXNlIHRoYXQgaXQgZXhpc3RzKVxuXHQgKiBvciBhIGNvb3JkIChpbiB0aGUgY2FzZSB0aGF0IGl0IGRvZXMgbm90IGV4aXN0KS4gSWYgbm8gZGVzY2VuZGFudCB0aWxlc1xuXHQgKiBhcmUgZm91bmQgaW4gdGhlIHB5cmFtaWQsIHJldHVybnMgdW5kZWZpbmVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1RpbGVDb29yZH0gbmNvb3JkIC0gVGhlIG5vcm1hbGl6ZWQgY29vcmQgb2YgdGhlIHRpbGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0IC0gVGhlIG9mZnNldCBmcm9tIHRoZSB0aWxlLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBkZXNjZW5kYW50IHRpbGVzIGFuZCBvciBjb29yZGluYXRlcyBvZiB0aGUgcHJvdmlkZWQgY29vcmQuXG5cdCAqL1xuXHRnZXREZXNjZW5kYW50cyhuY29vcmQsIGRpc3QpIHtcblx0XHQvLyBnZXQgY29vcmQgZGVzY2VuZGFudHNcblx0XHRjb25zdCBkZXNjZW5kYW50cyA9IG5jb29yZC5nZXREZXNjZW5kYW50cyhkaXN0KTtcblx0XHQvLyBjaGVjayBpZiB3ZSBoYXZlIGFueVxuXHRcdGxldCBmb3VuZCA9IGZhbHNlO1xuXHRcdGZvciAobGV0IGk9MDsgaTxkZXNjZW5kYW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuaGFzKGRlc2NlbmRhbnRzW2ldKSkge1xuXHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBpZiBzbyByZXR1cm4gd2hhdCB3ZSBoYXZlXG5cdFx0aWYgKGZvdW5kKSB7XG5cdFx0XHRjb25zdCByZXMgPSBuZXcgQXJyYXkoZGVzY2VuZGFudHMubGVuZ3RoKTtcblx0XHRcdGZvciAobGV0IGk9MDsgaTxkZXNjZW5kYW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBkZXNjZW5kYW50ID0gZGVzY2VuZGFudHNbaV07XG5cdFx0XHRcdC8vIGFkZCB0aWxlIGlmIGl0IGV4aXN0cywgY29vcmQgaWYgaXQgZG9lc24ndFxuXHRcdFx0XHRyZXNbaV0gPSB0aGlzLmdldChkZXNjZW5kYW50KSB8fCBkZXNjZW5kYW50O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXF1ZXN0cyB0aWxlcyBmb3IgdGhlIHByb3ZpZGVkIGNvb3Jkcy4gSWYgdGhlIHRpbGVzIGFscmVhZHkgZXhpc3Rcblx0ICogaW4gdGhlIHB5cmFtaWQgb3IgaXMgY3VycmVudGx5IHBlbmRpbmcgbm8gcmVxdWVzdCBpcyBtYWRlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb29yZHMgLSBUaGUgYXJyYXkgb2YgY29vcmRzIHRvIHJlcXVlc3QuXG5cdCAqL1xuXHRyZXF1ZXN0VGlsZXMoY29vcmRzKSB7XG5cblx0XHQvLyB3ZSBuZWVkIGJvdGggdGhlIG5vcm1hbGl6ZWQgYW4gdW4tbm9ybWFsaXplZCBjb29yZHMuXG5cdFx0Ly8gbm9ybWFsaXplZCBjb29yZHMgYXJlIHVzZWQgZm9yIHJlcXVlc3RzIHdoaWxlIHVuLW5vcm1hbGl6ZWQgYXJlIHVzZWRcblx0XHQvLyB0byBzb3J0IHRoZW0gYXJvdW5kIHRoZSB2aWV3cG9ydCBjZW50ZXJcblx0XHRsZXQgcGFpcnMgPSBjb29yZHMubWFwKGNvb3JkID0+IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGNvb3JkOiBjb29yZCxcblx0XHRcdFx0bmNvb3JkOiBjb29yZC5ub3JtYWxpemUoKVxuXHRcdFx0fTtcblx0XHR9KTtcblxuXHRcdC8vIHJlbW92ZSBhbnkgZHVwbGljYXRlc1xuXHRcdHBhaXJzID0gcmVtb3ZlRHVwbGljYXRlcyhwYWlycyk7XG5cblx0XHQvLyByZW1vdmUgYW55IHRpbGVzIHdlIGFscmVhZHkgaGF2ZSBvciB0aGF0IGFyZSBjdXJyZW50bHkgcGVuZGluZ1xuXHRcdHBhaXJzID0gcmVtb3ZlUGVuZGluZ09yRXhpc3RpbmcodGhpcywgcGFpcnMpO1xuXG5cdFx0Ly8gc29ydCBjb29yZHMgYnkgZGlzdGFuY2UgZnJvbSB2aWV3cG9ydCBjZW50ZXJcblx0XHRwYWlycyA9IHNvcnRBcm91bmRDZW50ZXIodGhpcy5sYXllci5wbG90LCBwYWlycyk7XG5cblx0XHQvLyBnZW5lcmF0ZSB0aWxlcyBhbmQgZmxhZyBhcyBwZW5kaW5nXG5cdFx0Ly8gTk9URTogd2UgZmxhZyB0aGVtIGFsbCBub3cgaW5jYXNlIGEgYGNsZWFyYCBpcyBjYWxsZWQgaW5zaWRlIHRoZVxuXHRcdC8vIGByZXF1ZXN0VGlsZWAgY2FsbC5cblx0XHRjb25zdCB0aWxlcyA9IHBhaXJzLm1hcChwYWlyID0+IHtcblx0XHRcdGNvbnN0IHRpbGUgPSBuZXcgVGlsZShwYWlyLm5jb29yZCk7XG5cdFx0XHQvLyBhZGQgdGlsZSB0byBwZW5kaW5nIGFycmF5XG5cdFx0XHR0aGlzLnBlbmRpbmcuc2V0KHRpbGUuY29vcmQuaGFzaCwgdGlsZSk7XG5cdFx0XHRyZXR1cm4gdGlsZTtcblx0XHR9KTtcblxuXHRcdC8vIHJlcXVlc3QgdGhlIHRpbGVzXG5cdFx0Zm9yIChsZXQgaT0wOyBpPHRpbGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCB0aWxlID0gdGlsZXNbaV07XG5cdFx0XHQvLyBlbWl0IHJlcXVlc3Rcblx0XHRcdHRoaXMubGF5ZXIuZW1pdChFdmVudFR5cGUuVElMRV9SRVFVRVNULCBuZXcgVGlsZUV2ZW50KHRoaXMubGF5ZXIsIHRpbGUpKTtcblx0XHRcdC8vIHJlcXVlc3QgdGlsZVxuXHRcdFx0dGhpcy5sYXllci5yZXF1ZXN0VGlsZSh0aWxlLmNvb3JkLCAoZXJyLCBkYXRhKSA9PiB7XG5cdFx0XHRcdC8vIGNoZWNrIGlmIHN0YWxlLCBjbGVhcnMgdGlsZXMgYW55IGZsYWdnZWQgYXMgc3RhbGVcblx0XHRcdFx0Y29uc3QgaXNTdGFsZSA9IGlzVGlsZVN0YWxlKHRoaXMsIHRpbGUpO1xuXHRcdFx0XHQvLyBpZiBub3Qgc3RhbGUgcmVtb3ZlIHRpbGUgZnJvbSBwZW5kaW5nXG5cdFx0XHRcdGlmICghaXNTdGFsZSkge1xuXHRcdFx0XHRcdHRoaXMucGVuZGluZy5kZWxldGUodGlsZS5jb29yZC5oYXNoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBjaGVjayBlcnJcblx0XHRcdFx0aWYgKGVyciAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdC8vIGFkZCBlcnJcblx0XHRcdFx0XHR0aWxlLmVyciA9IGVycjtcblx0XHRcdFx0XHQvLyBlbWl0IGZhaWx1cmVcblx0XHRcdFx0XHR0aGlzLmxheWVyLmVtaXQoRXZlbnRUeXBlLlRJTEVfRkFJTFVSRSwgbmV3IFRpbGVFdmVudCh0aGlzLmxheWVyLCB0aWxlKSk7XG5cdFx0XHRcdFx0Ly8gaWYgbm90IHN0YWxlLCBjaGVjayBpZiBsb2FkZWRcblx0XHRcdFx0XHRpZiAoIWlzU3RhbGUpIHtcblx0XHRcdFx0XHRcdGNoZWNrSWZMb2FkZWQodGhpcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBhZGQgZGF0YSB0byB0aGUgdGlsZVxuXHRcdFx0XHR0aWxlLmRhdGEgPSBkYXRhO1xuXHRcdFx0XHQvLyBjaGVjayBpZiB0aWxlIHNob3VsZCBiZSBkaXNjYXJkZWRcblx0XHRcdFx0aWYgKGlzU3RhbGUgfHwgc2hvdWxkRGlzY2FyZCh0aGlzLCB0aWxlKSkge1xuXHRcdFx0XHRcdC8vIGVtaXQgZGlzY2FyZFxuXHRcdFx0XHRcdHRoaXMubGF5ZXIuZW1pdChFdmVudFR5cGUuVElMRV9ESVNDQVJELCBuZXcgVGlsZUV2ZW50KHRoaXMubGF5ZXIsIHRpbGUpKTtcblx0XHRcdFx0XHQvLyBpZiBub3Qgc3RhbGUsIGNoZWNrIGlmIGxvYWRlZFxuXHRcdFx0XHRcdGlmICghaXNTdGFsZSkge1xuXHRcdFx0XHRcdFx0Y2hlY2tJZkxvYWRlZCh0aGlzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGFkZCB0byB0aWxlIHB5cmFtaWRcblx0XHRcdFx0YWRkKHRoaXMsIHRpbGUpO1xuXHRcdFx0XHQvLyBjaGVjayBpZiBsb2FkZWRcblx0XHRcdFx0Y2hlY2tJZkxvYWRlZCh0aGlzKTtcblx0XHRcdFx0Ly8gZmxhZyBhcyBkaXJ0eVxuXHRcdFx0XHR0aGlzLmxheWVyLnBsb3Quc2V0RGlydHkoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBJZiB0aGUgdGlsZSBleGlzdHMgaW4gdGhlIHB5cmFtaWQsIHJldHVybiBpdC4gT3RoZXJ3aXNlIHJldHVybiB0aGVcblx0ICogY2xvc2VzdCBhdmFpbGFibGUgbGV2ZWwtb2YtZGV0YWlsIGZvciB0aWxlLCB0aGlzIG1heSBiZSBhIHNpbmdsZSBhbmNlc3RvclxuXHQgKiBvciBtdWx0aXBsZSBkZXNjZW5kYW50cywgb3IgYSBjb21iaW5hdGlvbiBvZiBib3RoLlxuXHQgKlxuXHQgKiBJZiBubyBhbmNlc3RvciBvciBkZXNjZW5kYW50cyBleGlzdCwgcmV0dXJuIHVuZGVmaW5lZC5cblx0ICpcblx0ICogQHBhcmFtIHtUaWxlQ29vcmR9IG5jb29yZCAtIFRoZSBub3JtYWxpemVkIGNvb3JkIG9mIHRoZSB0aWxlLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBvZiB0aWxlIHBhcnRpYWxzIHRoYXQgY2xvc2VzdCBtYXRjaCB0aGUgcHJvdmlkZWQgY29vcmQuXG5cdCAqL1xuXHRnZXRBdmFpbGFibGVMT0QobmNvb3JkKSB7XG5cdFx0Ly8gY2hlY2sgaWYgd2UgaGF2ZSB0aGUgdGlsZVxuXHRcdGNvbnN0IHRpbGUgPSB0aGlzLmdldChuY29vcmQpO1xuXHRcdGlmICh0aWxlKSB7XG5cdFx0XHQvLyBpZiBleGlzdHMsIHJldHVybiBpdFxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0VGlsZVBhcnRpYWwuZnJvbVRpbGUodGlsZSlcblx0XHRcdF07XG5cdFx0fVxuXHRcdC8vIGlmIG5vdCwgZmluZCB0aGUgY2xvc2VzdCBhdmFpbGFibGUgbGV2ZWwtb2YtZGV0YWlsXG5cblx0XHQvLyBmaXJzdCwgZ2V0IHRoZSBhdmFpbGFibGUgbGV2ZWxzIG9mIGRldGFpbCwgYXNjZW5kaW5nIGluIGRpc3RhbmNlXG5cdFx0Ly8gZnJvbSB0aGUgb3JpZ2luYWwgY29vcmQgem9vbVxuXHRcdGNvbnN0IHpvb20gPSBuY29vcmQuejtcblx0XHRjb25zdCBsZXZlbHMgPSBbXTtcblx0XHR0aGlzLmxldmVscy5mb3JFYWNoKChfLCBrZXkpID0+IHtcblx0XHRcdGlmIChrZXkgIT09IHpvb20pIHtcblx0XHRcdFx0bGV2ZWxzLnB1c2goa2V5KTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRsZXZlbHMuc29ydCgoYSwgYikgPT4ge1xuXHRcdFx0Ly8gZ2l2ZSBwcmlvcml0eSB0byBhbmNlc3RvciBsZXZlbHMgc2luY2UgdGhleSBhcmUgY2hlYXBlclxuXHRcdFx0Y29uc3QgZGEgPSAoYSA+IHpvb20pID8gKGEgLSB6b29tKSA6ICh6b29tIC0gYSAtIDAuNSk7XG5cdFx0XHRjb25zdCBkYiA9IChiID4gem9vbSkgPyAoYiAtIHpvb20pIDogKHpvb20gLSBiIC0gMC41KTtcblx0XHRcdHJldHVybiBkYSAtIGRiO1xuXHRcdH0pO1xuXG5cdFx0Y29uc3QgcmVzdWx0cyA9IFtdO1xuXHRcdGNvbnN0IHF1ZXVlID0gW107XG5cdFx0bGV0IGN1cnJlbnQgPSBuY29vcmQ7XG5cdFx0bGV0IGxldmVsID0gbGV2ZWxzLnNoaWZ0KCk7XG5cblx0XHQvLyBzZWNvbmQsIGl0ZXJhdGUgdGhyb3VnaCBhdmFpbGFibGUgbGV2ZWxzIHNlYXJjaGluZyBmb3IgdGhlIGNsb3Nlc3Rcblx0XHQvLyBsZXZlbC1vZi1kZXRhaWwgZm9yIHRoZSBjdXJyZW50IGhlYWQgb2YgdGhlIHF1ZXVlXG5cdFx0d2hpbGUgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCAmJiBsZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG5cblx0XHRcdGlmIChsZXZlbCA8IGN1cnJlbnQueikge1xuXHRcdFx0XHQvLyB0cnkgdG8gZmluZCBhbmNlc3RvclxuXHRcdFx0XHRjb25zdCBkaXN0ID0gY3VycmVudC56IC0gbGV2ZWw7XG5cdFx0XHRcdGNvbnN0IGFuY2VzdG9yID0gdGhpcy5nZXRBbmNlc3RvcihjdXJyZW50LCBkaXN0KTtcblx0XHRcdFx0aWYgKGFuY2VzdG9yKSB7XG5cdFx0XHRcdFx0Ly8gdGlsZSBmb3VuZCwgY3JlYXRlIGEgdGlsZSBwYXJ0aWFsIGZyb20gdGhlIGFuY2VzdG9yXG5cdFx0XHRcdFx0cmVzdWx0cy5wdXNoKFxuXHRcdFx0XHRcdFx0VGlsZVBhcnRpYWwuZnJvbUFuY2VzdG9yKFxuXHRcdFx0XHRcdFx0XHRuY29vcmQsIC8vIHRhcmdldFxuXHRcdFx0XHRcdFx0XHRhbmNlc3RvciwgLy8gdGlsZVxuXHRcdFx0XHRcdFx0XHRjdXJyZW50KSk7IC8vIHJlbGF0aXZlXG5cdFx0XHRcdFx0Ly8gcG9wIG5leHQgY29vcmQgdG8gc2VhcmNoIG9mZiB0aGUgcXVldWVcblx0XHRcdFx0XHRjdXJyZW50ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gZGVzY2VuZGFudCBjaGVja3MgYXJlIG11Y2ggbW9yZSBleHBlbnNpdmUsIHNvIGxpbWl0IHRoaXNcblx0XHRcdFx0Ly8gYmFzZWQgb24gZGlzdGFuY2UgdG8gdGhlIG9yaWdpbmFsIGNvb3JkIHpvb21cblx0XHRcdFx0Ly8gTk9URTogdGhpcyBkaXN0YW5jZSBjYWxjdWxhdGlvbiBpcyBzYWZlIGJlY2F1c2UgaXQgaXMgYWx3YXlzXG5cdFx0XHRcdC8vIHRydWUgdGhhdCBcImN1cnJlbnQueiA+PSB6b29tXCIgYmVjYXVzZSBvbmx5IGRlc2NlbmRhbnQgY29vcmRzXG5cdFx0XHRcdC8vIGFyZSBhcHBlbmRlZCB0byB0aGUgcXVldWUuXG5cdFx0XHRcdC8vIHRoZXJlZm9yZSBpbiB0aGUgY2FzZSB0aGF0IFwibGV2ZWwgPj0gY3VycmVudC56XCIsIHRoZW5cblx0XHRcdFx0Ly8gXCJsZXZlbCA+PSB6b29tXCIgbXVzdCBiZSB0cnVlIGFzIHdlbGwuXG5cdFx0XHRcdGNvbnN0IG5kaXN0ID0gbGV2ZWwgLSB6b29tO1xuXHRcdFx0XHRpZiAobmRpc3QgPCBNQVhfREVTQ0VOREVOVF9ESVNUKSB7XG5cdFx0XHRcdFx0Ly8gdHJ5IHRvIGZpbmQgZGVzY2VuZGFudFxuXHRcdFx0XHRcdGNvbnN0IGRpc3QgPSBsZXZlbCAtIGN1cnJlbnQuejtcblx0XHRcdFx0XHRjb25zdCBkZXNjZW5kYW50cyA9IHRoaXMuZ2V0RGVzY2VuZGFudHMoY3VycmVudCwgZGlzdCk7XG5cdFx0XHRcdFx0aWYgKGRlc2NlbmRhbnRzKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBqPTA7IGo8ZGVzY2VuZGFudHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZGVzY2VuZGFudCA9IGRlc2NlbmRhbnRzW2pdO1xuXHRcdFx0XHRcdFx0XHRpZiAoZGVzY2VuZGFudC5jb29yZCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIHRpbGUgZm91bmQsICBjcmVhdGUgYSB0aWxlIHBhcnRpYWwgZnJvbSB0aGVcblx0XHRcdFx0XHRcdFx0XHQvLyBkZXNjZW5kYW50XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKFxuXHRcdFx0XHRcdFx0XHRcdFx0VGlsZVBhcnRpYWwuZnJvbURlc2NlbmRhbnQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5jb29yZCwgLy8gdGFyZ2V0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRlc2NlbmRhbnQpKTsgLy8gdGlsZVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8vIG5vIHRpbGUgZm91bmQsIGRlc2NlbmRhbnQgaXMgYSBjb29yZFxuXHRcdFx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goZGVzY2VuZGFudCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjdXJyZW50ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIG5vdGhpbmcgZm91bmQgaW4gbGV2ZWwsIHdlIGNhbiBzYWZlbHkgcmVtb3ZlIGl0IGZyb20gdGhlIHNlYXJjaFxuXHRcdFx0bGV2ZWwgPSBsZXZlbHMuc2hpZnQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIChyZXN1bHRzLmxlbmd0aCA+IDApID8gcmVzdWx0cyA6IHVuZGVmaW5lZDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGVQeXJhbWlkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCb3VuZHMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9Cb3VuZHMnKTtcblxuLyoqXG4gKiBUaGUgc2l6ZSBvZiB0aGUgY2VsbCwgaW4gcGl4ZWxzLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7bnVtYmVyfVxuICovXG5jb25zdCBDRUxMX1NJWkUgPSBNYXRoLnBvdygyLCAxNik7XG5cbi8qKlxuICogVGhlIGhhbGYgc2l6ZSBvZiB0aGUgY2VsbCwgaW4gcGl4ZWxzLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7bnVtYmVyfVxuICovXG5jb25zdCBDRUxMX0hBTEZfU0laRSA9IENFTExfU0laRSAvIDI7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgY2VsbCBmb3IgY2xpcHBpbmcgYSByZW5kZXJpbmcgc3BhY2UuXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDZWxsIHtcblxuXHQvKipcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IENlbGwgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gem9vbSAtIFRoZSB6b29tIHRoZSB0aGUgY2VsbHMgaXMgZ2VuZXJhdGVkIGZvci5cblx0ICogQHBhcmFtIHtPYmplY3R9IGNlbnRlciAtIFRoZSBwbG90IHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNlbGwuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBleHRlbnQgLSBUaGUgcGl4ZWwgZXh0ZW50IG9mIHRoZSBwbG90IGF0IHRoZSB0aW1lIG9mIGdlbmVyYXRpb24uXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih6b29tLCBjZW50ZXIsIGV4dGVudCkge1xuXHRcdGNvbnN0IGhhbGZTaXplID0gQ0VMTF9IQUxGX1NJWkUgLyBleHRlbnQ7XG5cdFx0Y29uc3Qgb2Zmc2V0ID0ge1xuXHRcdFx0eDogY2VudGVyLnggLSBoYWxmU2l6ZSxcblx0XHRcdHk6IGNlbnRlci55IC0gaGFsZlNpemVcblx0XHR9O1xuXHRcdHRoaXMuem9vbSA9IHpvb207XG5cdFx0dGhpcy5oYWxmU2l6ZSA9IGhhbGZTaXplO1xuXHRcdHRoaXMuY2VudGVyID0gY2VudGVyO1xuXHRcdHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuXHRcdHRoaXMuZXh0ZW50ID0gZXh0ZW50O1xuXHRcdHRoaXMuYm91bmRzID0gbmV3IEJvdW5kcyhcblx0XHRcdGNlbnRlci54IC0gaGFsZlNpemUsXG5cdFx0XHRjZW50ZXIueCArIGhhbGZTaXplLFxuXHRcdFx0Y2VudGVyLnkgLSBoYWxmU2l6ZSxcblx0XHRcdGNlbnRlci55ICsgaGFsZlNpemUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFByb2plY3QgYSBub3JtYWxpemVkIHBsb3QgY29vcmRpbmF0ZSB0byB0aGUgcGl4ZWwgc3BhY2Ugb2YgdGhlIGNlbGwuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwb3MgLSBUaGUgbm9ybWFsaXplZCBwbG90IGNvb3JkaW5hdGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIC0gVGhlIHpvb20gb2YgdGhlIHBsb3QgcGl4ZWwgc3BhY2UgdG8gcHJvamVjdCB0by4gT3B0aW9uYWwuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjb29yZGluYXRlIGluIGNlbGwgcGl4ZWwgc3BhY2UuXG5cdCAqL1xuXHRwcm9qZWN0KHBvcywgem9vbSA9IHRoaXMuem9vbSkge1xuXHRcdGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMiwgem9vbSAtIHRoaXMuem9vbSkgKiB0aGlzLmV4dGVudDtcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogKHBvcy54IC0gdGhpcy5vZmZzZXQueCkgKiBzY2FsZSxcblx0XHRcdHk6IChwb3MueSAtIHRoaXMub2Zmc2V0LnkpICogc2NhbGVcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFVucHJvamVjdCBhIGNvb3JkaW5hdGUgZnJvbSB0aGUgcGl4ZWwgc3BhY2Ugb2YgdGhlIGNlbGwgdG8gYSBub3JtYWxpemVkXG5cdCAqIHBsb3QgY29vcmRpbmF0ZS5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHB4IC0gVGhlIHBsb3QgcGl4ZWwgY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHpvb20gLSBUaGUgem9vbSBvZiB0aGUgcGxvdCBwaXhlbCBzcGFjZSB0byB1bnByb2plY3QgZnJvbS4gT3B0aW9uYWwuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBub3JtYWxpemVkIHBsb3QgY29vcmRpbmF0ZS5cblx0ICovXG5cdHVucHJvamVjdChweCwgem9vbSA9IHRoaXMuem9vbSkge1xuXHRcdGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMiwgem9vbSAtIHRoaXMuem9vbSkgKiB0aGlzLmV4dGVudDtcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogKHB4LnggLyBzY2FsZSkgKyB0aGlzLm9mZnNldC54LFxuXHRcdFx0eTogKHB4LnkgLyBzY2FsZSkgKyB0aGlzLm9mZnNldC55XG5cdFx0fTtcblx0fVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2VsbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY2xhbXAgPSByZXF1aXJlKCdsb2Rhc2gvY2xhbXAnKTtcbmNvbnN0IGRlZmF1bHRUbyA9IHJlcXVpcmUoJ2xvZGFzaC9kZWZhdWx0VG8nKTtcbmNvbnN0IHRocm90dGxlID0gcmVxdWlyZSgnbG9kYXNoL3Rocm90dGxlJyk7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IEV2ZW50VHlwZSA9IHJlcXVpcmUoJy4uL2V2ZW50L0V2ZW50VHlwZScpO1xuY29uc3QgRXZlbnRCcm9hZGNhc3RlciA9IHJlcXVpcmUoJy4uL2V2ZW50L0V2ZW50QnJvYWRjYXN0ZXInKTtcbmNvbnN0IEV2ZW50RGVsZWdhdG9yID0gcmVxdWlyZSgnLi4vZXZlbnQvRXZlbnREZWxlZ2F0b3InKTtcbmNvbnN0IEV2ZW50ID0gcmVxdWlyZSgnLi4vZXZlbnQvRXZlbnQnKTtcbmNvbnN0IFJlc2l6ZUV2ZW50ID0gcmVxdWlyZSgnLi4vZXZlbnQvUmVzaXplRXZlbnQnKTtcbmNvbnN0IFJlbmRlckJ1ZmZlciA9IHJlcXVpcmUoJy4uL3dlYmdsL1JlbmRlckJ1ZmZlcicpO1xuY29uc3QgQ2xpY2tIYW5kbGVyID0gcmVxdWlyZSgnLi9oYW5kbGVyL0NsaWNrSGFuZGxlcicpO1xuY29uc3QgTW91c2VIYW5kbGVyID0gcmVxdWlyZSgnLi9oYW5kbGVyL01vdXNlSGFuZGxlcicpO1xuY29uc3QgUGFuSGFuZGxlciA9IHJlcXVpcmUoJy4vaGFuZGxlci9QYW5IYW5kbGVyJyk7XG5jb25zdCBab29tSGFuZGxlciA9IHJlcXVpcmUoJy4vaGFuZGxlci9ab29tSGFuZGxlcicpO1xuY29uc3QgQ2VsbCA9IHJlcXVpcmUoJy4vQ2VsbCcpO1xuY29uc3QgVmlld3BvcnQgPSByZXF1aXJlKCcuL1ZpZXdwb3J0Jyk7XG5cbi8vIENvbnN0YW50c1xuXG4vKipcbiAqIFBhbiByZXF1ZXN0IHRocm90dGxlIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnQge251bWJlcn1cbiAqL1xuY29uc3QgUEFOX1RIUk9UVExFX01TID0gMTAwO1xuXG4vKipcbiAqIFJlc2l6ZSByZXF1ZXN0IHRocm90dGxlIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnQge251bWJlcn1cbiAqL1xuY29uc3QgUkVTSVpFX1RIUk9UVExFX01TID0gMjAwO1xuXG4vKipcbiAqIFpvb20gcmVxdWVzdCB0aHJvdHRsZSBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50IHtudW1iZXJ9XG4gKi9cbmNvbnN0IFpPT01fVEhST1RUTEVfTVMgPSA0MDA7XG5cbi8qKlxuICogVGhlIG1heGltdW0gem9vbSBkZWx0YSB1bnRpbCBhIGNlbGwgdXBkYXRlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7bnVtYmVyfVxuICovXG5jb25zdCBDRUxMX1pPT01fREVMVEEgPSAxLjA7XG5cbi8qKlxuICogVGhlIG1heGltdW0gem9vbSBsZXZlbCBzdXBwb3J0ZWQuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50IHtudW1iZXJ9XG4gKi9cbmNvbnN0IE1BWF9aT09NID0gMjQ7XG5cbi8qKlxuICogQ2xpY2sgaGFuZGxlciBzeW1ib2wuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50IHtTeW1ib2x9XG4gKi9cbmNvbnN0IENMSUNLID0gU3ltYm9sKCk7XG5cbi8qKlxuICogTW91c2UgaGFuZGxlciBzeW1ib2wuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50IHtTeW1ib2x9XG4gKi9cbmNvbnN0IE1PVVNFID0gU3ltYm9sKCk7XG5cbi8qKlxuICogUGFuIGhhbmRsZXIgc3ltYm9sLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxuICovXG5jb25zdCBQQU4gPSBTeW1ib2woKTtcblxuLyoqXG4gKiBab29tIGhhbmRsZXIgc3ltYm9sLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxuICovXG5jb25zdCBaT09NID0gU3ltYm9sKCk7XG5cbi8qKlxuICogRXZlbnQgaGFuZGxlcnMgc3ltYm9sLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxuICovXG5jb25zdCBIQU5ETEVSUyA9IFN5bWJvbCgpO1xuXG4vKipcbiAqIEV2ZW50IGRlbGVnYXRvcnMgc3ltYm9sLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxuICovXG5jb25zdCBERUxFR0FUT1IgPSBTeW1ib2woKTtcblxuLyoqXG4gKiBFdmVudCBicm9hZGNhc3RlcnMgc3ltYm9sLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxuICovXG5jb25zdCBCUk9BRENBU1RFUiA9IFN5bWJvbCgpO1xuXG4vKipcbiAqIERpcnR5IHBsb3Qgc3ltYm9sLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxuICovXG5jb25zdCBESVJUWSA9IFN5bWJvbCgpO1xuXG4vLyBQcml2YXRlIE1ldGhvZHNcblxuY29uc3QgcmVxdWVzdFRpbGVzID0gZnVuY3Rpb24oKSB7XG5cdC8vIGdldCBhbGwgdmlzaWJsZSBjb29yZHMgaW4gdGhlIHRhcmdldCB2aWV3cG9ydFxuXHRjb25zdCBjb29yZHMgPSB0aGlzLmdldFRhcmdldFZpc2libGVDb29yZHMoKTtcblx0Ly8gZm9yIGVhY2ggbGF5ZXJcblx0dGhpcy5sYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG5cdFx0aWYgKGxheWVyLnJlcXVlc3RUaWxlcykge1xuXHRcdFx0Ly8gcmVxdWVzdCB0aWxlc1xuXHRcdFx0bGF5ZXIucmVxdWVzdFRpbGVzKGNvb3Jkcyk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5jb25zdCByZXNpemUgPSBmdW5jdGlvbihwbG90KSB7XG5cdGNvbnN0IGN1cnJlbnQgPSB7XG5cdFx0d2lkdGg6IHBsb3QuY29udGFpbmVyLm9mZnNldFdpZHRoLFxuXHRcdGhlaWdodDogcGxvdC5jb250YWluZXIub2Zmc2V0SGVpZ2h0XG5cdH07XG5cdGNvbnN0IHByZXYgPSBwbG90LmdldFZpZXdwb3J0UGl4ZWxTaXplKCk7XG5cdGNvbnN0IGNlbnRlciA9IHBsb3Qudmlld3BvcnQuZ2V0Q2VudGVyKCk7XG5cblx0aWYgKHByZXYud2lkdGggIT09IGN1cnJlbnQud2lkdGggfHxcblx0XHRwcmV2LmhlaWdodCAhPT0gY3VycmVudC5oZWlnaHQgfHxcblx0XHRwbG90LnBpeGVsUmF0aW8gIT09IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB7XG5cdFx0Ly8gc3RvcmUgZGV2aWNlIHBpeGVsIHJhdGlvXG5cdFx0cGxvdC5waXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG5cdFx0Ly8gcmVzaXplIGNhbnZhc1xuXHRcdHBsb3QuY2FudmFzLnN0eWxlLndpZHRoID0gY3VycmVudC53aWR0aCArICdweCc7XG5cdFx0cGxvdC5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gY3VycmVudC5oZWlnaHQgKyAncHgnO1xuXHRcdHBsb3QuY2FudmFzLndpZHRoID0gY3VycmVudC53aWR0aCAqIHBsb3QucGl4ZWxSYXRpbztcblx0XHRwbG90LmNhbnZhcy5oZWlnaHQgPSBjdXJyZW50LmhlaWdodCAqIHBsb3QucGl4ZWxSYXRpbztcblx0XHQvLyByZXNpemUgcmVuZGVyYnVmZmVyXG5cdFx0cGxvdC5yZW5kZXJCdWZmZXIucmVzaXplKFxuXHRcdFx0Y3VycmVudC53aWR0aCAqIHBsb3QucGl4ZWxSYXRpbyxcblx0XHRcdGN1cnJlbnQuaGVpZ2h0ICogcGxvdC5waXhlbFJhdGlvKTtcblx0XHQvLyB1cGRhdGUgdmlld3BvcnRcblx0XHRjb25zdCBleHRlbnQgPSBwbG90LmdldFBpeGVsRXh0ZW50KCk7XG5cdFx0cGxvdC52aWV3cG9ydC53aWR0aCA9IGN1cnJlbnQud2lkdGggLyBleHRlbnQ7XG5cdFx0cGxvdC52aWV3cG9ydC5oZWlnaHQgPSBjdXJyZW50LmhlaWdodCAvIGV4dGVudDtcblx0XHQvLyByZS1jZW50ZXIgdmlld3BvcnRcblx0XHRwbG90LnZpZXdwb3J0LmNlbnRlck9uKGNlbnRlcik7XG5cdFx0Ly8gcmVxdWVzdCB0aWxlc1xuXHRcdHBsb3QucmVzaXplUmVxdWVzdCgpO1xuXHRcdC8vIGVtaXQgcmVzaXplXG5cdFx0cGxvdC5zZXREaXJ0eSgpO1xuXHRcdHBsb3QuZW1pdChFdmVudFR5cGUuUkVTSVpFLCBuZXcgUmVzaXplRXZlbnQocGxvdCwgcHJldiwgY3VycmVudCkpO1xuXHR9XG59O1xuXG5jb25zdCB1cGRhdGVDZWxsID0gZnVuY3Rpb24ocGxvdCkge1xuXHRjb25zdCB6b29tID0gcGxvdC5nZXRUYXJnZXRab29tKCk7XG5cdGNvbnN0IGNlbnRlciA9IHBsb3QuZ2V0VGFyZ2V0Vmlld3BvcnRDZW50ZXIoKTtcblx0Y29uc3QgZXh0ZW50ID0gcGxvdC5nZXRUYXJnZXRQaXhlbEV4dGVudCgpO1xuXHRjb25zdCBzaXplID0gcGxvdC5nZXRWaWV3cG9ydFBpeGVsU2l6ZSgpO1xuXHRjb25zdCBjZWxsID0gbmV3IENlbGwoem9vbSwgY2VudGVyLCBleHRlbnQpO1xuXHRsZXQgcmVmcmVzaCA9IGZhbHNlO1xuXHQvLyBjaGVjayBpZiBubyBjZWxsIGV4aXN0c1xuXHRpZiAoIXBsb3QuY2VsbCkge1xuXHRcdHJlZnJlc2ggPSB0cnVlO1xuXHR9IGVsc2Uge1xuXHRcdC8vIGNoZWNrIGlmIHdlIGFyZSBvdXRzaWRlIG9mIG9uZSB6b29tIGxldmVsIGZyb20gbGFzdFxuXHRcdGNvbnN0IHpvb21EaXN0ID0gTWF0aC5hYnMocGxvdC5jZWxsLnpvb20gLSBjZWxsLnpvb20pO1xuXHRcdGlmICh6b29tRGlzdCA+PSBDRUxMX1pPT01fREVMVEEpIHtcblx0XHRcdHJlZnJlc2ggPSB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBjaGVjayBpZiB3ZSBhcmUgd2l0aGluZyBidWZmZXIgZGlzdGFuY2Ugb2YgdGhlIGNlbGwgYm91bmRzXG5cdFx0XHRjb25zdCB4RGlzdCA9IHBsb3QuY2VsbC5oYWxmU2l6ZSAtIChzaXplLndpZHRoIC8gcGxvdC5jZWxsLmV4dGVudCk7XG5cdFx0XHRjb25zdCB5RGlzdCA9IHBsb3QuY2VsbC5oYWxmU2l6ZSAtIChzaXplLmhlaWdodCAvIHBsb3QuY2VsbC5leHRlbnQpO1xuXHRcdFx0aWYgKE1hdGguYWJzKGNlbGwuY2VudGVyLnggLSBwbG90LmNlbGwuY2VudGVyLngpID4geERpc3QgfHxcblx0XHRcdFx0TWF0aC5hYnMoY2VsbC5jZW50ZXIueSAtIHBsb3QuY2VsbC5jZW50ZXIueSkgPiB5RGlzdCkge1xuXHRcdFx0XHRyZWZyZXNoID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0aWYgKHJlZnJlc2gpIHtcblx0XHQvLyB1cGRhdGUgY2VsbFxuXHRcdHBsb3QuY2VsbCA9IGNlbGw7XG5cdFx0Ly8gZW1pdCBjZWxsIHJlZnJlc2hcblx0XHRwbG90LmVtaXQoRXZlbnRUeXBlLkNFTExfVVBEQVRFLCBuZXcgRXZlbnQoY2VsbCkpO1xuXHR9XG59O1xuXG5jb25zdCByZXNldCA9IGZ1bmN0aW9uKHBsb3QpIHtcblx0aWYgKCFwbG90LndyYXBhcm91bmQpIHtcblx0XHQvLyBpZiB0aGVyZSBpcyBubyB3cmFwYXJvdW5kLCBkbyBub3QgcmVzZXRcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyByZXNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydCByZWxhdGl2ZSB0byB0aGUgcGxvdCBzdWNoIHRoYXRcblx0Ly8gdGhlIHBsb3QgbmF0aXZlIGNvb3JkaW5hdGUgcmFuZ2UgaXMgd2l0aGluIHRoZSB2aWV3cG9ydHMgYm91bmRzLlxuXG5cdC8vIGdldCB2aWV3cG9ydCB3aWR0aCBpbiBwbG90IGNvb3Jkc1xuXHRjb25zdCB3aWR0aCA9IE1hdGguY2VpbChwbG90LnZpZXdwb3J0LndpZHRoIC8gMS4wKTtcblxuXHQvLyBwYXN0IHRoZSBsZWZ0IGJvdW5kIG9mIHRoZSB2aWV3cG9ydFxuXHRpZiAocGxvdC52aWV3cG9ydC54ID4gMS4wKSB7XG5cdFx0cGxvdC52aWV3cG9ydC54IC09IHdpZHRoO1xuXHRcdGlmIChwbG90LmlzUGFubmluZygpKSB7XG5cdFx0XHRwbG90LnBhbkFuaW1hdGlvbi5zdGFydC54IC09IHdpZHRoO1xuXHRcdH1cblx0fVxuXHQvLyBwYXN0IHRoZSByaWdodCBib3VuZCBvZiB0aGUgdmlld3BvcnRcblx0aWYgKHBsb3Qudmlld3BvcnQueCArIHBsb3Qudmlld3BvcnQud2lkdGggPCAwKSB7XG5cdFx0cGxvdC52aWV3cG9ydC54ICs9IHdpZHRoO1xuXHRcdGlmIChwbG90LmlzUGFubmluZygpKSB7XG5cdFx0XHRwbG90LnBhbkFuaW1hdGlvbi5zdGFydC54ICs9IHdpZHRoO1xuXHRcdH1cblx0fVxufTtcblxuY29uc3QgZnJhbWUgPSBmdW5jdGlvbihwbG90KSB7XG5cblx0Ly8gZ2V0IGZyYW1lIHRpbWVzdGFtcFxuXHRjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuXG5cdC8vIGVtaXQgZnJhbWUgZXZlbnRcblx0cGxvdC5lbWl0KEV2ZW50VHlwZS5GUkFNRSwgbmV3IEV2ZW50KHBsb3QsIHRpbWVzdGFtcCkpO1xuXG5cdC8vIHVwZGF0ZSBzaXplXG5cdHJlc2l6ZShwbG90KTtcblxuXHRpZiAoIXBsb3QuZGlydHlDaGVja2luZyB8fCBwbG90LmlzRGlydHkoKSkge1xuXG5cdFx0Ly8gY2xlYXIgZmxhZyBub3csIHRoaXMgd2F5IGxheWVycyB0aGF0IG1heSBiZSBhbmltYXRpbmcgY2FuIHNpZ25hbFxuXHRcdC8vIHRoYXQgdGhlIGFuaW1hdGlvbiBpcyBub3QgY29tcGxldGUgYnkgZmxhZ2dpbmcgYXMgZGlydHkgZHVyaW5nIHRoZVxuXHRcdC8vIGRyYXcgY2FsbC5cblx0XHRwbG90LmNsZWFyRGlydHkoKTtcblxuXHRcdC8vIGFwcGx5IHRoZSB6b29tIGFuaW1hdGlvblxuXHRcdGlmIChwbG90LmlzWm9vbWluZygpKSB7XG5cdFx0XHRpZiAocGxvdC56b29tQW5pbWF0aW9uLnVwZGF0ZSh0aW1lc3RhbXApKSB7XG5cdFx0XHRcdHBsb3Quem9vbUFuaW1hdGlvbiA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gYXBwbHkgdGhlIHBhbiBhbmltYXRpb25cblx0XHRpZiAocGxvdC5pc1Bhbm5pbmcoKSkge1xuXHRcdFx0aWYgKHBsb3QucGFuQW5pbWF0aW9uLnVwZGF0ZSh0aW1lc3RhbXApKSB7XG5cdFx0XHRcdHBsb3QucGFuQW5pbWF0aW9uID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBsb3QucGFuUmVxdWVzdCgpO1xuXHRcdH1cblxuXHRcdC8vIHJlc2V0IHZpZXdwb3J0IC8gcGxvdFxuXHRcdHJlc2V0KHBsb3QpO1xuXG5cdFx0Ly8gdXBkYXRlIGNlbGxcblx0XHR1cGRhdGVDZWxsKHBsb3QpO1xuXG5cdFx0Ly8gZ2V0IGNvbnRleHRcblx0XHRjb25zdCBnbCA9IHBsb3QuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xuXG5cdFx0Ly8gY2xlYXIgdGhlIGJhY2tidWZmZXJcblx0XHRnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuXHRcdGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuXG5cdFx0Ly8gc2V0IHRoZSB2aWV3cG9ydFxuXHRcdGNvbnN0IHNpemUgPSBwbG90LmdldFZpZXdwb3J0UGl4ZWxTaXplKCk7XG5cdFx0Z2wudmlld3BvcnQoXG5cdFx0XHQwLCAwLFxuXHRcdFx0c2l6ZS53aWR0aCAqIHBsb3QucGl4ZWxSYXRpbyxcblx0XHRcdHNpemUuaGVpZ2h0ICogcGxvdC5waXhlbFJhdGlvKTtcblxuXHRcdC8vIHNvcnQgbGF5ZXJzIGJ5IHotaW5kZXhcblx0XHRjb25zdCBsYXllcnMgPSBwbG90LmdldFNvcnRlZExheWVycygpO1xuXG5cdFx0Ly8gcmVuZGVyIGVhY2ggbGF5ZXJcblx0XHRsYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG5cdFx0XHRpZiAoIWxheWVyLmlzSGlkZGVuKCkpIHtcblx0XHRcdFx0bGF5ZXIuZHJhdyh0aW1lc3RhbXApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0Ly8gcmVxdWVzdCBuZXh0IGZyYW1lXG5cdHBsb3QuZnJhbWVSZXF1ZXN0ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcblx0XHRmcmFtZShwbG90KTtcblx0fSk7XG59O1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHBsb3QuXG4gKi9cbmNsYXNzIFBsb3QgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgUGxvdCBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciAtIFRoZSBzZWxlY3RvciBmb3IgdGhlIGNvbnRhaW5lciBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBwbG90IG9wdGlvbnMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRpbGVTaXplIC0gVGhlIGRpbWVuc2lvbiBpbiBwaXhlbHMgb2YgYSB0aWxlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy56b29tIC0gVGhlIHpvb20gb2YgdGhlIHBsb3QuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1pblpvb20gLSBUaGUgbWluaW11bSB6b29tIG9mIHRoZSBwbG90LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5tYXhab29tIC0gVGhlIG1heGltdW0gem9vbSBvZiB0aGUgcGxvdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuY2VudGVyIC0gVGhlIGNlbnRlciBvZiB0aGUgcGxvdCwgaW4gcGxvdCBwaXhlbHMuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy53cmFwYXJvdW5kIC0gV2hldGhlciBvciBub3QgdGhlIHBsb3Qgd3JhcHMgYXJvdW5kLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY29udGV4dCAtIFRoZSByZW5kZXJpbmcgY29udGV4dCB0eXBlLCBkZWZhdWx0cyB0byBgd2ViZ2xgLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY29udGV4dEF0dHJpYnV0ZXMgLSBUaGUgcmVuZGVyaW5nIGNvbnRleHQgYXR0cmlidHVlcyBhcmd1bWVudC4gT3B0aW9uYWwuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5kaXJ0eUNoZWNraW5nIC0gV2hldGhlciBvciBub3QgdGhlIHBsb3QgdXNlcyBkaXJ0eSBjaGVja2luZyBvciByZW5kZXJzIGV2ZXJ5IGZyYW1lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5wYW5UaHJvdHRsZSAtIFBhbiByZXF1ZXN0IHRocm90dGxlIHRpbWVvdXQgaW4gbXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnJlc2l6ZVRocm90dGxlIC0gUmVzaXplIHJlcXVlc3QgdGhyb3R0bGUgdGltZW91dCBpbiBtcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuem9vbVRocm90dGxlIC0gWm9vbSByZXF1ZXN0IHRocm90dGxlIHRpbWVvdXQgaW4gbXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmluZXJ0aWEgLSBXaGV0aGVyIG9yIG5vdCBwYW4gaW5lcnRpYSBpcyBlbmFibGVkLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5pbmVydGlhRWFzaW5nIC0gVGhlIGluZXJ0aWEgZWFzaW5nIGZhY3Rvci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuaW5lcnRpYURlY2VsZXJhdGlvbiAtIFRoZSBpbmVydGlhIGRlY2VsZXJhdGlvbiBmYWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNvbnRpbnVvdXNab29tIC0gV2hldGhlciBvciBub3QgY29udGludW91cyB6b29tIGlzIGVuYWJsZWQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnpvb21EdXJhdGlvbiAtIFRoZSBkdXJhdGlvbiBvZiB0aGUgem9vbSBhbmltYXRpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1heENvbmN1cnJlbnRab29tcyAtIFRoZSBtYXhpbXVtIGNvbmN1cnJlbnQgem9vbXMgaW4gYSBzaW5nbGUgYmF0Y2guXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmRlbHRhUGVyWm9vbSAtIFRoZSBzY3JvbGwgZGVsdGEgcmVxdWlyZWQgcGVyIHpvb20gbGV2ZWwuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnpvb21EZWJvdW5jZSAtIFRoZSBkZWJvdW5jZSBkdXJhdGlvbiBvZiB0aGUgem9vbSBpbiBtcy5cblx0ICovXG5cdGNvbnN0cnVjdG9yKHNlbGVjdG9yLCBvcHRpb25zID0ge30pIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuY29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG5cdFx0aWYgKCF0aGlzLmNvbnRhaW5lcikge1xuXHRcdFx0dGhyb3cgYEVsZW1lbnQgY291bGQgbm90IGJlIGZvdW5kIGZvciBzZWxlY3RvciAke3NlbGVjdG9yfWA7XG5cdFx0fVxuXG5cdFx0Ly8gc2V0IHBpeGVsIHJhdGlvXG5cdFx0dGhpcy5waXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG5cblx0XHQvLyBjcmVhdGUgY2FudmFzIGVsZW1lbnRcblx0XHR0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHRcdHRoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gYCR7dGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGh9cHhgO1xuXHRcdHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke3RoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodH1weGA7XG5cdFx0dGhpcy5jYW52YXMud2lkdGggPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCAqIHRoaXMucGl4ZWxSYXRpbztcblx0XHR0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW87XG5cdFx0dGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuXG5cdFx0Ly8gZ2V0IHJlbmRlcmluZyBjb250ZXh0XG5cdFx0dGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIG9wdGlvbnMuY29udGV4dEF0dHJpYnV0ZXMpO1xuXHRcdGlmICghdGhpcy5jdHgpIHtcblx0XHRcdHRocm93ICdVbmFibGUgdG8gY3JlYXRlIGEgV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBwbGVhc2UgZW5zdXJlIHlvdXIgYnJvd3NlciBzdXBwb3J0cyBXZWJHTCc7XG5cdFx0fVxuXG5cdFx0Ly8gY3JlYXRlIHJlbmRlcmJ1ZmZlclxuXHRcdHRoaXMucmVuZGVyQnVmZmVyID0gbmV3IFJlbmRlckJ1ZmZlcihcblx0XHRcdHRoaXMuY3R4LFxuXHRcdFx0dGhpcy5jYW52YXMud2lkdGgsXG5cdFx0XHR0aGlzLmNhbnZhcy5oZWlnaHQpO1xuXG5cdFx0Ly8gdGlsZSBzaXplIGluIHBpeGVsc1xuXHRcdHRoaXMudGlsZVNpemUgPSBkZWZhdWx0VG8ob3B0aW9ucy50aWxlU2l6ZSwgMjU2KTtcblxuXHRcdC8vIG1pbiBhbmQgbWF4IHpvb20gb2YgdGhlIHBsb3Rcblx0XHR0aGlzLm1pblpvb20gPSBkZWZhdWx0VG8ob3B0aW9ucy5taW5ab29tLCAwKTtcblx0XHR0aGlzLm1heFpvb20gPSBkZWZhdWx0VG8ob3B0aW9ucy5tYXhab29tLCBNQVhfWk9PTSk7XG5cblx0XHQvLyBjdXJyZW50IHpvb20gb2YgdGhlIHBsb3Rcblx0XHR0aGlzLnpvb20gPSBkZWZhdWx0VG8ob3B0aW9ucy56b29tLCAwKTtcblx0XHR0aGlzLnpvb20gPSBjbGFtcCh0aGlzLnpvb20sIHRoaXMubWluWm9vbSwgdGhpcy5tYXhab29tKTtcblxuXHRcdC8vIHNldCB2aWV3cG9ydFxuXHRcdGNvbnN0IHNwYW4gPSBNYXRoLnBvdygyLCB0aGlzLnpvb20pO1xuXHRcdGNvbnN0IHdpZHRoID0gdGhpcy5jYW52YXMub2Zmc2V0V2lkdGggLyBzcGFuO1xuXHRcdGNvbnN0IGhlaWdodCA9IHRoaXMuY2FudmFzLm9mZnNldEhlaWdodCAvIHNwYW47XG5cdFx0dGhpcy52aWV3cG9ydCA9IG5ldyBWaWV3cG9ydCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuXHRcdC8vIGNlbnRlciB0aGUgcGxvdFxuXHRcdGNvbnN0IGNlbnRlciA9IGRlZmF1bHRUbyhvcHRpb25zLmNlbnRlciwgeyB4OiAwLjUsIHk6IDAuNSB9KTtcblx0XHR0aGlzLnZpZXdwb3J0LmNlbnRlck9uKGNlbnRlcik7XG5cblx0XHQvLyBnZW5lcmF0ZSBjZWxsXG5cdFx0dGhpcy5jZWxsID0gbnVsbDtcblx0XHR1cGRhdGVDZWxsKHRoaXMpO1xuXG5cdFx0Ly8gd3JhcGFyb3VuZFxuXHRcdHRoaXMud3JhcGFyb3VuZCA9IGRlZmF1bHRUbyhvcHRpb25zLndyYXBhcm91bmQsIGZhbHNlKTtcblxuXHRcdC8vIHRocm90dGxlZCByZXF1ZXN0IG1ldGhvZHNcblx0XHRjb25zdCBwYW5UaHJvdHRsZSA9IGRlZmF1bHRUbyhvcHRpb25zLnBhblRocm90dGxlLCBQQU5fVEhST1RUTEVfTVMpO1xuXHRcdGNvbnN0IHJlc2l6ZVRocm90dGxlID0gZGVmYXVsdFRvKG9wdGlvbnMucmVzaXplVGhyb3R0bGUsIFJFU0laRV9USFJPVFRMRV9NUyk7XG5cdFx0Y29uc3Qgem9vbVRocm90dGxlID0gZGVmYXVsdFRvKG9wdGlvbnMuem9vbVRocm90dGxlLCBaT09NX1RIUk9UVExFX01TKTtcblx0XHR0aGlzLnBhblJlcXVlc3QgPSB0aHJvdHRsZShyZXF1ZXN0VGlsZXMsIHBhblRocm90dGxlLCB7XG5cdFx0XHRsZWFkaW5nOiBmYWxzZSAvLyBpbnZva2Ugb25seSBvbiB0cmFpbGluZyBlZGdlXG5cdFx0fSk7XG5cdFx0dGhpcy5yZXNpemVSZXF1ZXN0ID0gdGhyb3R0bGUocmVxdWVzdFRpbGVzLCByZXNpemVUaHJvdHRsZSwge1xuXHRcdFx0bGVhZGluZzogZmFsc2UgLy8gaW52b2tlIG9ubHkgb24gdHJhaWxpbmcgZWRnZVxuXHRcdH0pO1xuXHRcdHRoaXMuem9vbVJlcXVlc3QgPSB0aHJvdHRsZShyZXF1ZXN0VGlsZXMsIHpvb21UaHJvdHRsZSwge1xuXHRcdFx0bGVhZGluZzogZmFsc2UgLy8gaW52b2tlIG9ubHkgb24gdHJhaWxpbmcgZWRnZVxuXHRcdH0pO1xuXG5cdFx0Ly8gbGF5ZXJzXG5cdFx0dGhpcy5sYXllcnMgPSBbXTtcblxuXHRcdC8vIGZyYW1lIHJlcXVlc3Rcblx0XHR0aGlzLmZyYW1lUmVxdWVzdCA9IG51bGw7XG5cblx0XHQvLyBjcmVhdGUgYW5kIGVuYWJsZSBoYW5kbGVyc1xuXHRcdHRoaXNbSEFORExFUlNdID0gbmV3IE1hcCgpO1xuXHRcdHRoaXNbSEFORExFUlNdLnNldChDTElDSywgbmV3IENsaWNrSGFuZGxlcih0aGlzLCBvcHRpb25zKSk7XG5cdFx0dGhpc1tIQU5ETEVSU10uc2V0KE1PVVNFLCBuZXcgTW91c2VIYW5kbGVyKHRoaXMsIG9wdGlvbnMpKTtcblx0XHR0aGlzW0hBTkRMRVJTXS5zZXQoUEFOLCBuZXcgUGFuSGFuZGxlcih0aGlzLCBvcHRpb25zKSk7XG5cdFx0dGhpc1tIQU5ETEVSU10uc2V0KFpPT00sIG5ldyBab29tSGFuZGxlcih0aGlzLCBvcHRpb25zKSk7XG5cdFx0dGhpc1tIQU5ETEVSU10uZm9yRWFjaChoYW5kbGVyID0+IHtcblx0XHRcdGhhbmRsZXIuZW5hYmxlKCk7XG5cdFx0fSk7XG5cblx0XHQvLyBkZWxlZ2F0b3Jcblx0XHR0aGlzW0RFTEVHQVRPUl0gPSBuZXcgRXZlbnREZWxlZ2F0b3IodGhpcyk7XG5cdFx0Ly8gZGVsZWdhdGUgbW91c2UgLyBjbGljayBldmVudHMgdG8gbGF5ZXJzXG5cdFx0dGhpc1tERUxFR0FUT1JdLmRlbGVnYXRlKEV2ZW50VHlwZS5DTElDSyk7XG5cdFx0dGhpc1tERUxFR0FUT1JdLmRlbGVnYXRlKEV2ZW50VHlwZS5EQkxfQ0xJQ0spO1xuXHRcdHRoaXNbREVMRUdBVE9SXS5kZWxlZ2F0ZShFdmVudFR5cGUuTU9VU0VfTU9WRSk7XG5cdFx0dGhpc1tERUxFR0FUT1JdLmRlbGVnYXRlKEV2ZW50VHlwZS5NT1VTRV9VUCk7XG5cdFx0dGhpc1tERUxFR0FUT1JdLmRlbGVnYXRlKEV2ZW50VHlwZS5NT1VTRV9ET1dOKTtcblxuXHRcdC8vIGJyb2FkY2FzdGVyXG5cdFx0dGhpc1tCUk9BRENBU1RFUl0gPSBuZXcgRXZlbnRCcm9hZGNhc3Rlcih0aGlzKTtcblx0XHQvLyBicm9hZGNhc3Qgem9vbSAvIHBhbiBldmVudHMgdG8gbGF5ZXJzXG5cdFx0dGhpc1tCUk9BRENBU1RFUl0uYnJvYWRjYXN0KEV2ZW50VHlwZS5aT09NX1NUQVJUKTtcblx0XHR0aGlzW0JST0FEQ0FTVEVSXS5icm9hZGNhc3QoRXZlbnRUeXBlLlpPT00pO1xuXHRcdHRoaXNbQlJPQURDQVNURVJdLmJyb2FkY2FzdChFdmVudFR5cGUuWk9PTV9FTkQpO1xuXHRcdHRoaXNbQlJPQURDQVNURVJdLmJyb2FkY2FzdChFdmVudFR5cGUuUEFOX1NUQVJUKTtcblx0XHR0aGlzW0JST0FEQ0FTVEVSXS5icm9hZGNhc3QoRXZlbnRUeXBlLlBBTik7XG5cdFx0dGhpc1tCUk9BRENBU1RFUl0uYnJvYWRjYXN0KEV2ZW50VHlwZS5QQU5fRU5EKTtcblxuXHRcdC8vIHdoZXRoZXIgb3Igbm90IHRvIHVzZSBkaXJ0eSBjaGVja2luZ1xuXHRcdHRoaXMuZGlydHlDaGVja2luZyA9IGRlZmF1bHRUbyhvcHRpb25zLmRpcnR5Q2hlY2tpbmcsIHRydWUpO1xuXG5cdFx0Ly8gZmxhZyBhcyBkaXJ0eVxuXHRcdHRoaXNbRElSVFldID0gdHJ1ZTtcblxuXHRcdC8vIGJlZ2luIGZyYW1lIGxvb3Bcblx0XHRmcmFtZSh0aGlzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXN0cm95cyB0aGUgcGxvdHMgYXNzb2NpYXRpb24gd2l0aCB0aGUgdW5kZXJseWluZyBjYW52YXMgZWxlbWVudCBhbmRcblx0ICogZGlzYWJsZXMgYWxsIGV2ZW50IGhhbmRsZXJzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UGxvdH0gVGhlIHBsb3Qgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRkZXN0cm95KCkge1xuXHRcdC8vIHN0b3AgYW5pbWF0aW9uIGxvb3Bcblx0XHRjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZyYW1lUmVxdWVzdCk7XG5cdFx0dGhpcy5mcmFtZVJlcXVlc3QgPSBudWxsO1xuXHRcdC8vIGRpc2FibGUgaGFuZGxlcnNcblx0XHR0aGlzW0hBTkRMRVJTXS5mb3JFYWNoKGhhbmRsZXIgPT4ge1xuXHRcdFx0aGFuZGxlci5kaXNhYmxlKCk7XG5cdFx0fSk7XG5cdFx0Ly8gcmVtb3ZlIGxheWVyc1xuXHRcdHRoaXMubGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuXHRcdFx0dGhpcy5yZW1vdmUobGF5ZXIpO1xuXHRcdH0pO1xuXHRcdC8vIGRlc3Ryb3kgY29udGV4dFxuXHRcdHRoaXMuY3R4ID0gbnVsbDtcblx0XHQvLyByZW1vdmUgY2FudmFzXG5cdFx0dGhpcy5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5jYW52YXMpO1xuXHRcdHRoaXMuY2FudmFzID0gbnVsbDtcblx0XHR0aGlzLmNvbnRhaW5lciA9IG51bGw7XG5cdFx0dGhpcy5yZW5kZXJCdWZmZXIgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZsYWdzIHRoZSBwbG90IGFzIGRpcnR5IHNpbmdhbGxpbmcgdGhhdCBpdCBzaG91bGQgYmUgcmVkcmF3biBpbiB0aGUgbmV4dFxuXHQgKiBmcmFtZS5cblx0ICovXG5cdHNldERpcnR5KCkge1xuXHRcdHRoaXNbRElSVFldID0gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGUgcGxvdCBpcyBkaXJ0eSBhbmQgcmVxdWlyZXMgYSByZWRyYXcuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgcGxvdCBzaG91bGQgYmUgcmVkcmF3bi5cbiBcdCovXG5cdGlzRGlydHkoKSB7XG5cdFx0cmV0dXJuIHRoaXNbRElSVFldIHx8IHRoaXMuaXNQYW5uaW5nKCkgfHwgdGhpcy5pc1pvb21pbmcoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhcnMgdGhlIGRpcnR5IGZsYWcgZm9yIHRoZSBuZXh0IGZyYW1lLlxuXHQgKi9cblx0Y2xlYXJEaXJ0eSgpIHtcblx0XHR0aGlzW0RJUlRZXSA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBsYXllciB0byB0aGUgcGxvdC5cblx0ICpcblx0ICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSBUaGUgbGF5ZXIgdG8gYWRkIHRvIHRoZSBwbG90LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UGxvdH0gVGhlIHBsb3Qgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRhZGQobGF5ZXIpIHtcblx0XHRpZiAoIWxheWVyKSB7XG5cdFx0XHR0aHJvdyAnTm8gYXJndW1lbnQgcHJvdmlkZWQnO1xuXHRcdH1cblx0XHRpZiAodGhpcy5sYXllcnMuaW5kZXhPZihsYXllcikgIT09IC0xKSB7XG5cdFx0XHR0aHJvdyAnUHJvdmlkZWQgbGF5ZXIgaXMgYWxyZWFkeSBhdHRhY2hlZCB0byB0aGUgcGxvdCc7XG5cdFx0fVxuXHRcdHRoaXMubGF5ZXJzLnB1c2gobGF5ZXIpO1xuXHRcdGxheWVyLm9uQWRkKHRoaXMpO1xuXHRcdHRoaXMuc2V0RGlydHkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGEgbGF5ZXIgZnJvbSB0aGUgcGxvdC5cblx0ICpcblx0ICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSBUaGUgbGF5ZXIgdG8gcmVtb3ZlIGZyb20gdGhlIHBsb3QuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtQbG90fSBUaGUgcGxvdCBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHJlbW92ZShsYXllcikge1xuXHRcdGlmICghbGF5ZXIpIHtcblx0XHRcdHRocm93ICdObyBhcmd1bWVudCBwcm92aWRlZCc7XG5cdFx0fVxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5sYXllcnMuaW5kZXhPZihsYXllcik7XG5cdFx0aWYgKGluZGV4ID09PSAtMSkge1xuXHRcdFx0dGhyb3cgJ1Byb3ZpZGVkIGxheWVyIGlzIG5vdCBhdHRhY2hlZCB0byB0aGUgcGxvdCc7XG5cdFx0fVxuXHRcdHRoaXMubGF5ZXJzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0bGF5ZXIub25SZW1vdmUodGhpcyk7XG5cdFx0dGhpcy5zZXREaXJ0eSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHJlbmRlcmluZyBjb250ZXh0IG9mIHRoZSBwbG90LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gVGhlIGNvbnRleHQgb2JqZWN0LlxuXHQgKi9cblx0Z2V0UmVuZGVyaW5nQ29udGV4dCgpIHtcblx0XHRyZXR1cm4gdGhpcy5jdHg7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbGwgdGhlIGxheWVyIG9iamVjdHMgYXR0YWNoZWQgdG8gdGhlIHBsb3QsIGluIGRlc2NlbmRpbmdcblx0ICogb3JkZXIgb2Ygei1pbmRleC5cblx0ICovXG5cdGdldFNvcnRlZExheWVycygpIHtcblx0XHQvLyBzb3J0IGJ5IHotaW5kZXhcblx0XHRyZXR1cm4gdGhpcy5sYXllcnMuc29ydCgoYSwgYikgPT4ge1xuXHRcdFx0cmV0dXJuIGEuZ2V0WkluZGV4KCkgLSBiLmdldFpJbmRleCgpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gb2YgdGhlIHBsb3QuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBjdXJyZW50IHpvb20gb2YgdGhlIHBsb3QuXG5cdCAqL1xuXHRnZXRab29tKCkge1xuXHRcdHJldHVybiB0aGlzLnpvb207XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdGFyZ2V0IHpvb20gb2YgdGhlIHBsb3QuIElmIHRoZSBwbG90IGlzIGFjdGl2ZWx5IHpvb21pbmcsIGl0XG5cdCAqIHdpbGwgcmV0dXJuIHRoZSBkZXN0aW5hdGlvbiB6b29tLiBJZiB0aGUgcGxvdCBpcyBub3QgYWN0aXZlbHkgem9vbWluZywgaXRcblx0ICogd2lsbCByZXR1cm4gdGhlIGN1cnJlbnQgem9vbS5cblx0ICpcblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHRhcmdldCB6b29tIG9mIHRoZSBwbG90LlxuXHQgKi9cblx0Z2V0VGFyZ2V0Wm9vbSgpIHtcblx0XHRpZiAodGhpcy5pc1pvb21pbmcoKSkge1xuXHRcdFx0Ly8gaWYgem9vbWluZywgdXNlIHRoZSB0YXJnZXQgbGV2ZWxcblx0XHRcdHJldHVybiB0aGlzLnpvb21BbmltYXRpb24udGFyZ2V0Wm9vbTtcblx0XHR9XG5cdFx0Ly8gaWYgbm90IHpvb21pbmcsIHVzZSB0aGUgY3VycmVudCBsZXZlbFxuXHRcdHJldHVybiB0aGlzLnpvb207XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY3VycmVudCB2aWV3cG9ydCBvZiB0aGUgcGxvdC5cblx0ICpcblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIGN1cnJlbnQgdmlld3BvcnQgb2YgdGhlIHBsb3QuXG5cdCAqL1xuXHRnZXRWaWV3cG9ydCgpIHtcblx0XHRyZXR1cm4gdGhpcy52aWV3cG9ydDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0YXJnZXQgdmlld3BvcnQgb2YgdGhlIHBsb3QuIElmIHRoZSBwbG90IGlzIGFjdGl2ZWx5IHpvb21pbmcsXG5cdCAqIGl0IHdpbGwgcmV0dXJuIHRoZSB0YXJnZXQgdmlld3BvcnQuIElmIHRoZSBwbG90IGlzIG5vdCBhY3RpdmVseSB6b29taW5nLFxuXHQgKiBpdCB3aWxsIHJldHVybiB0aGUgY3VycmVudCB2aWV3cG9ydC5cblx0ICpcblx0ICogQHJldHVybnMge1ZpZXdwb3J0fSBUaGUgdGFyZ2V0IHZpZXdwb3J0IG9mIHRoZSBwbG90LlxuXHQgKi9cblx0Z2V0VGFyZ2V0Vmlld3BvcnQoKSB7XG5cdFx0aWYgKHRoaXMuaXNab29taW5nKCkpIHtcblx0XHRcdC8vIGlmIHpvb21pbmcsIHVzZSB0aGUgdGFyZ2V0IHZpZXdwb3J0XG5cdFx0XHRyZXR1cm4gdGhpcy56b29tQW5pbWF0aW9uLnRhcmdldFZpZXdwb3J0O1xuXHRcdH1cblx0XHQvLyBpZiBub3Qgem9vbWluZywgdXNlIHRoZSBjdXJyZW50IHZpZXdwb3J0XG5cdFx0cmV0dXJuIHRoaXMudmlld3BvcnQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY3VycmVudCBib3R0b20tbGVmdCBjb3JuZXIgb2YgdGhlIHZpZXdwb3J0LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY3VycmVudCBjZW50ZXIgaW4gcGxvdCBjb29yZGluYXRlcy5cblx0ICovXG5cdGdldFZpZXdwb3J0UG9zaXRpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudmlld3BvcnQuZ2V0UG9zaXRpb24oKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0YXJnZXQgYm90dG9tLWxlZnQgY29ybmVyIG9mIHRoZSB2aWV3cG9ydC4gSWYgdGhlIHBsb3QgaXMgYWN0aXZlbHkgem9vbWluZ1xuXHQgKiBvciBwYW5uaW5nLCBpdCB3aWxsIHJldHVybiB0aGUgZGVzdGluYXRpb24gY2VudGVyLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgdGFyZ2V0IGNlbnRlciBpbiBwbG90IGNvb3JkaW5hdGVzLlxuXHQgKi9cblx0Z2V0VGFyZ2V0Vmlld3BvcnRQb3NpdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRUYXJnZXRWaWV3cG9ydCgpLmdldFBvc2l0aW9uKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY3VycmVudCBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY3VycmVudCBjZW50ZXIgaW4gcGxvdCBjb29yZGluYXRlcy5cblx0ICovXG5cdGdldFZpZXdwb3J0Q2VudGVyKCkge1xuXHRcdHJldHVybiB0aGlzLnZpZXdwb3J0LmdldENlbnRlcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHRhcmdldCBjZW50ZXIgb2YgdGhlIHBsb3QgaW4gcGxvdCBjb29yZGluYXRlcy4gSWYgdGhlIHBsb3QgaXNcblx0ICogYWN0aXZlbHkgem9vbWluZyBvciBwYW5uaW5nLCBpdCB3aWxsIHJldHVybiB0aGUgZGVzdGluYXRpb24gY2VudGVyLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgdGFyZ2V0IGNlbnRlciBpbiBwbG90IGNvb3JkaW5hdGVzLlxuXHQgKi9cblx0Z2V0VGFyZ2V0Vmlld3BvcnRDZW50ZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0VGFyZ2V0Vmlld3BvcnQoKS5nZXRDZW50ZXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjZW50ZXIgb2YgdGhlIHBsb3QgaW4gcGxvdCBjb29yZGluYXRlcy5cblx0ICpcblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIHRhcmdldCBjZW50ZXIgaW4gcGxvdCBjb29yZGluYXRlcy5cblx0ICovXG5cdGdldFZpZXdwb3J0Q2VudGVyKCkge1xuXHRcdHJldHVybiB0aGlzLnZpZXdwb3J0LmdldENlbnRlcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHRpbGUgY29vcmRpbmF0ZXMgdmlzaWJsZSBpbiB0aGUgdGFyZ2V0IHZpZXdwb3J0LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBvZiB2aXNpYmxlIHRpbGUgY29vcmRzLlxuXHQgKi9cblx0Z2V0VGFyZ2V0VmlzaWJsZUNvb3JkcygpIHtcblx0XHRjb25zdCB0aWxlWm9vbSA9IE1hdGgucm91bmQodGhpcy5nZXRUYXJnZXRab29tKCkpOyAvLyB1c2UgdGFyZ2V0IHpvb21cblx0XHRjb25zdCB2aWV3cG9ydCA9IHRoaXMuZ2V0VGFyZ2V0Vmlld3BvcnQoKTsgLy8gdXNlIHRhcmdldCB2aWV3cG9ydFxuXHRcdHJldHVybiB2aWV3cG9ydC5nZXRWaXNpYmxlQ29vcmRzKHRpbGVab29tLCB0aGlzLndyYXBhcm91bmQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHRpbGUgY29vcmRpbmF0ZXMgY3VycmVudGx5IHZpc2libGUgaW4gdGhlIGN1cnJlbnQgdmlld3BvcnQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFycmF5IG9mIHZpc2libGUgdGlsZSBjb29yZHMuXG5cdCAqL1xuXHRnZXRWaXNpYmxlQ29vcmRzKCkge1xuXHRcdGNvbnN0IHRpbGVab29tID0gTWF0aC5yb3VuZCh0aGlzLnpvb20pOyAvLyB1c2UgY3VycmVudCB6b29tXG5cdFx0Y29uc3Qgdmlld3BvcnQgPSB0aGlzLnZpZXdwb3J0OyAvLyB1c2UgY3VycmVudCB2aWV3cG9ydFxuXHRcdHJldHVybiB2aWV3cG9ydC5nZXRWaXNpYmxlQ29vcmRzKHRpbGVab29tLCB0aGlzLndyYXBhcm91bmQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHBsb3Qgc2l6ZSBpbiBwaXhlbHMuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwbG90IHNpemUgaW4gcGl4ZWxzLlxuXHQgKi9cblx0Z2V0UGl4ZWxFeHRlbnQoKSB7XG5cdFx0cmV0dXJuIE1hdGgucG93KDIsIHRoaXMuem9vbSkgKiB0aGlzLnRpbGVTaXplO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHRhcmdldCBwbG90IHNpemUgaW4gcGl4ZWxzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgdGFyZ2V0IHBsb3Qgc2l6ZSBpbiBwaXhlbHMuXG5cdCAqL1xuXHRnZXRUYXJnZXRQaXhlbEV4dGVudCgpIHtcblx0XHRyZXR1cm4gTWF0aC5wb3coMiwgdGhpcy5nZXRUYXJnZXRab29tKCkpICogdGhpcy50aWxlU2l6ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB2aWV3cG9ydCBzaXplIGluIHBpeGVscy5cblx0ICpcblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIHZpZXdwb3J0IHNpemUgaW4gcGl4ZWxzLlxuXHQgKi9cblx0Z2V0Vmlld3BvcnRQaXhlbFNpemUoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmlld3BvcnQuZ2V0UGl4ZWxTaXplKHRoaXMuem9vbSwgdGhpcy50aWxlU2l6ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdGFyZ2V0IHZpZXdwb3J0IHNpemUgaW4gcGl4ZWxzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgdGFyZ2V0IHZpZXdwb3J0IHNpemUgaW4gcGl4ZWxzLlxuXHQgKi9cblx0Z2V0VGFyZ2V0Vmlld3BvcnRQaXhlbFNpemUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0VGFyZ2V0Vmlld3BvcnQoKS5nZXRQaXhlbFNpemUodGhpcy56b29tLCB0aGlzLnRpbGVTaXplKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB2aWV3cG9ydCBvZmZzZXQgaW4gcGl4ZWxzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgdmlld3BvcnQgb2Zmc2V0IGluIHBpeGVscy5cblx0ICovXG5cdGdldFZpZXdwb3J0UGl4ZWxPZmZzZXQoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmlld3BvcnQuZ2V0UGl4ZWxPZmZzZXQodGhpcy56b29tLCB0aGlzLnRpbGVTaXplKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0YXJnZXQgdmlld3BvcnQgb2Zmc2V0IGluIHBpeGVscy5cblx0ICpcblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIHRhcmdldCB2aWV3cG9ydCBvZmZzZXQgaW4gcGl4ZWxzLlxuXHQgKi9cblx0Z2V0VGFyZ2V0Vmlld3BvcnRQaXhlbE9mZnNldCgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRUYXJnZXRWaWV3cG9ydCgpLmdldFBpeGVsT2Zmc2V0KHRoaXMuem9vbSwgdGhpcy50aWxlU2l6ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgb3J0aG9ncmFwaGljIHByb2plY3Rpb24gbWF0cml4IGZvciB0aGUgdmlld3BvcnQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtGbG9hdDMyQXJyYXl9IFRoZSBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXguXG5cdCAqL1xuXHRnZXRPcnRob01hdHJpeCgpIHtcblx0XHRjb25zdCBzaXplID0gdGhpcy5nZXRWaWV3cG9ydFBpeGVsU2l6ZSgpO1xuXHRcdGNvbnN0IGxlZnQgPSAwO1xuXHRcdGNvbnN0IHJpZ2h0ID0gc2l6ZS53aWR0aDtcblx0XHRjb25zdCBib3R0b20gPSAwO1xuXHRcdGNvbnN0IHRvcCA9IHNpemUuaGVpZ2h0O1xuXHRcdGNvbnN0IG5lYXIgPSAtMTtcblx0XHRjb25zdCBmYXIgPSAxO1xuXHRcdGNvbnN0IGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpO1xuXHRcdGNvbnN0IGJ0ID0gMSAvIChib3R0b20gLSB0b3ApO1xuXHRcdGNvbnN0IG5mID0gMSAvIChuZWFyIC0gZmFyKTtcblx0XHRjb25zdCBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcblx0XHRvdXRbMF0gPSAtMiAqIGxyO1xuXHRcdG91dFsxXSA9IDA7XG5cdFx0b3V0WzJdID0gMDtcblx0XHRvdXRbM10gPSAwO1xuXHRcdG91dFs0XSA9IDA7XG5cdFx0b3V0WzVdID0gLTIgKiBidDtcblx0XHRvdXRbNl0gPSAwO1xuXHRcdG91dFs3XSA9IDA7XG5cdFx0b3V0WzhdID0gMDtcblx0XHRvdXRbOV0gPSAwO1xuXHRcdG91dFsxMF0gPSAyICogbmY7XG5cdFx0b3V0WzExXSA9IDA7XG5cdFx0b3V0WzEyXSA9IChsZWZ0ICsgcmlnaHQpICogbHI7XG5cdFx0b3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG5cdFx0b3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuXHRcdG91dFsxNV0gPSAxO1xuXHRcdHJldHVybiBvdXQ7XG5cdH1cblxuXHQvKipcblx0ICogUGFucyB0byB0aGUgdGFyZ2V0IHBsb3QgY29vcmRpbmF0ZS4gQ2FuY2VscyBhbnkgY3VycmVudCB6b29tIG9yIHBhblxuXHQgKiBhbmltYXRpb25zLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcG9zIC0gVGhlIHRhcmdldCBwbG90IHBvc2l0aW9uLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGFuaW1hdGUgLSBXaGV0aGVyIG9yIG5vdCB0byBhbmltYXRlIHRoZSBwYW4uIERlZmF1bHRzIHRvIGB0cnVlYC5cblx0ICpcblx0ICogQHJldHVybnMge1Bsb3R9IFRoZSBwbG90IG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0cGFuVG8ocG9zLCBhbmltYXRlID0gdHJ1ZSkge1xuXHRcdC8vIGNhbmNlbCBleGlzdGluZyBhbmltYXRpb25zXG5cdFx0dGhpcy5jYW5jZWxQYW4oKTtcblx0XHR0aGlzLmNhbmNlbFpvb20oKTtcblx0XHR0aGlzW0hBTkRMRVJTXS5nZXQoUEFOKS5wYW5Ubyhwb3MsIGFuaW1hdGUpO1xuXHRcdHRoaXMuc2V0RGlydHkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBab29tcyBpbiB0byB0aGUgdGFyZ2V0IHpvb20gbGV2ZWwuIFRoaXMgaXMgYm91bmRlZCBieSB0aGUgcGxvdCBvYmplY3RzXG5cdCAqIG1pblpvb20gYW5kIG1heFpvb20gYXR0cmlidXRlcy4gQ2FuY2VscyBhbnkgY3VycmVudCB6b29tIG9yIHBhblxuXHQgKiBhbmltYXRpb25zLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWwgLSBUaGUgdGFyZ2V0IHpvb20gbGV2ZWwuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gYW5pbWF0ZSAtIFdoZXRoZXIgb3Igbm90IHRvIGFuaW1hdGUgdGhlIHpvb20uIERlZmF1bHRzIHRvIGB0cnVlYC5cblx0ICpcblx0ICogQHJldHVybnMge1Bsb3R9IFRoZSBwbG90IG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0em9vbVRvKGxldmVsLCBhbmltYXRlID0gdHJ1ZSkge1xuXHRcdC8vIGNhbmNlbCBleGlzdGluZyBhbmltYXRpb25zXG5cdFx0dGhpcy5jYW5jZWxQYW4oKTtcblx0XHR0aGlzLmNhbmNlbFpvb20oKTtcblx0XHR0aGlzW0hBTkRMRVJTXS5nZXQoWk9PTSkuem9vbVRvKGxldmVsLCBhbmltYXRlKTtcblx0XHR0aGlzLnNldERpcnR5KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogRml0IHRoZSBwbG90IHRvIGEgcHJvdmlkZWQgYm91bmRzIGluIHBsb3QgY29vcmRpbmF0ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm91bmRzfSBib3VuZHMgLSBUaGUgYm91bmRzIG9iamVjdCwgaW4gcGxvdCBjb29yZGluYXRlcy5cblx0ICpcblx0ICogQHJldHVybnMge1Bsb3R9IFRoZSBwbG90IG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0Zml0VG9Cb3VuZHMoYm91bmRzKSB7XG5cdFx0Y29uc3QgdGFyZ2V0Wm9vbSA9IHRoaXMuZ2V0VGFyZ2V0Wm9vbSgpO1xuXHRcdGNvbnN0IHRhcmdldFZpZXdwb3J0ID0gdGhpcy5nZXRUYXJnZXRWaWV3cG9ydCgpO1xuXHRcdGNvbnN0IHNjYWxlWCA9IHRhcmdldFZpZXdwb3J0LndpZHRoIC8gYm91bmRzLmdldFdpZHRoKCk7XG5cdFx0Y29uc3Qgc2NhbGVZID0gdGFyZ2V0Vmlld3BvcnQuaGVpZ2h0IC8gYm91bmRzLmdldEhlaWdodCgpO1xuXHRcdGNvbnN0IHNjYWxlID0gTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpO1xuXHRcdGxldCB6b29tID0gTWF0aC5sb2cyKHNjYWxlKSArIHRhcmdldFpvb207XG5cdFx0em9vbSA9IGNsYW1wKHpvb20sIHRoaXMubWluWm9vbSwgdGhpcy5tYXhab29tKTtcblx0XHRpZiAoIXRoaXMuY29udGludW91c1pvb20pIHtcblx0XHRcdHpvb20gPSBNYXRoLmZsb29yKHpvb20pO1xuXHRcdH1cblx0XHRjb25zdCBjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCk7XG5cdFx0dGhpcy56b29tVG8oem9vbSwgZmFsc2UpO1xuXHRcdHRoaXMucGFuVG8oY2VudGVyLCBmYWxzZSk7XG5cdFx0dGhpcy5zZXREaXJ0eSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHBsb3QgaXMgYWN0aXZlbHkgcGFubmluZy5cblx0ICpcblx0ICogQHJldHVybnMge2Jvb2x9IFdoZXRoZXIgb3Igbm90IHRoZSBwbG90IGlzIHBhbm5pbmcuXG5cdCAqL1xuXHRpc1Bhbm5pbmcoKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5wYW5BbmltYXRpb247XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcGxvdCBpcyBhY3RpdmVseSB6b29taW5nLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Ym9vbH0gV2hldGhlciBvciBub3QgdGhlIHBsb3QgaXMgem9vbWluZy5cblx0ICovXG5cdGlzWm9vbWluZygpIHtcblx0XHRyZXR1cm4gISF0aGlzLnpvb21BbmltYXRpb247XG5cdH1cblxuXHQvKipcblx0ICogQ2FuY2VscyBhbnkgY3VycmVudCBwYW4gYW5pbWF0aW9uLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIHBsb3Qgd2FzIHBhbm5pbmcuXG5cdCAqL1xuXHRjYW5jZWxQYW4oKSB7XG5cdFx0aWYgKHRoaXMuaXNQYW5uaW5nKCkpIHtcblx0XHRcdHRoaXMucGFuQW5pbWF0aW9uLmNhbmNlbCgpO1xuXHRcdFx0dGhpcy5wYW5BbmltYXRpb24gPSBudWxsO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYW5jZWxzIGFueSBjdXJyZW50IHpvb20gYW5pbWF0aW9uLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIHBsb3Qgd2FzIHpvb21pbmcuXG5cdCAqL1xuXHRjYW5jZWxab29tKCkge1xuXHRcdGlmICh0aGlzLmlzWm9vbWluZygpKSB7XG5cdFx0XHR0aGlzLnpvb21BbmltYXRpb24uY2FuY2VsKCk7XG5cdFx0XHR0aGlzLnpvb21BbmltYXRpb24gPSBudWxsO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFueSBoaWdobGlnaHRlZCBkYXRhLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgaGlnaGxpZ2h0ZWQgZGF0YS5cblx0ICovXG5cdGdldEhpZ2hsaWdodGVkKCkge1xuXHRcdGNvbnN0IGxheWVycyA9IHRoaXMubGF5ZXJzO1xuXHRcdGZvciAobGV0IGk9MDsgaTxsYXllcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGhpZ2hsaWdodCA9IGxheWVyc1tpXS5nZXRIaWdobGlnaHRlZCgpO1xuXHRcdFx0aWYgKGhpZ2hsaWdodCkge1xuXHRcdFx0XHRyZXR1cm4gaGlnaGxpZ2h0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIGFyZ3VtZW50IGlzIGhpZ2hsaWdodGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIHRvIHRlc3QuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGVyZSBpcyBoaWdobGlnaHRlZCBkYXRhLlxuXHQgKi9cblx0aXNIaWdobGlnaHRlZChkYXRhKSB7XG5cdFx0Y29uc3QgbGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0Zm9yIChsZXQgaT0wOyBpPGxheWVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGxheWVyc1tpXS5pc0hpZ2hsaWdodGVkKGRhdGEpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbnkgc2VsZWN0ZWQgZGF0YS5cblx0ICpcblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgc2VsZWN0ZWQgZGF0YS5cblx0ICovXG5cdGdldFNlbGVjdGVkKCkge1xuXHRcdGNvbnN0IHNlbGVjdGlvbiA9IFtdO1xuXHRcdGNvbnN0IGxheWVycyA9IHRoaXMubGF5ZXJzO1xuXHRcdGZvciAobGV0IGk9MDsgaTxsYXllcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IHNlbGVjdGVkID0gbGF5ZXJzW2ldLmdldFNlbGVjdGVkKCk7XG5cdFx0XHRmb3IgKGxldCBqPTA7IGo8c2VsZWN0ZWQubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0c2VsZWN0aW9uLnB1c2goc2VsZWN0ZWRbal0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gc2VsZWN0aW9uO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgYXJndW1lbnQgaXMgc2VsZWN0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgdG8gdGVzdC5cblx0ICpcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBkYXRhIGlzIHNlbGVjdGVkLlxuXHQgKi9cblx0aXNTZWxlY3RlZChkYXRhKSB7XG5cdFx0Y29uc3QgbGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0Zm9yIChsZXQgaT0wOyBpPGxheWVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGxheWVyc1tpXS5pc1NlbGVjdGVkKGRhdGEpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBjb250YWluaW5nIGVsZW1lbnQgb2YgdGhlIHBsb3QuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gVGhlIGNvbnRhaW5lciBvZiB0aGUgcGxvdC5cblx0ICovXG5cdGdldENvbnRhaW5lcigpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXI7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQbG90O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCb3VuZHMgPSByZXF1aXJlKCcuLi9nZW9tZXRyeS9Cb3VuZHMnKTtcbmNvbnN0IFRpbGVDb29yZCA9IHJlcXVpcmUoJy4uL2xheWVyL3RpbGUvVGlsZUNvb3JkJyk7XG5cbi8vIFByaXZhdGUgTWV0aG9kc1xuXG5jb25zdCBnZXRWaXNpYmxlVGlsZUJvdW5kcyA9IGZ1bmN0aW9uKHZpZXdwb3J0LCB0aWxlWm9vbSwgd3JhcGFyb3VuZCkge1xuXHRjb25zdCBib3VuZHMgPSB2aWV3cG9ydC5nZXRUaWxlQm91bmRzKHRpbGVab29tKTtcblx0Ly8gbWluIC8gbWF4IHRpbGUgY29vcmRzXG5cdGNvbnN0IGRpbSA9IE1hdGgucG93KDIsIHRpbGVab29tKTtcblx0Y29uc3QgbWluID0gMDtcblx0Y29uc3QgbWF4ID0gZGltIC0gMTtcblx0Ly8gZ2V0IHRoZSBib3VuZHMgb2YgdGhlIHpvb20gbGV2ZWxcblx0Y29uc3QgbGF5ZXJCb3VuZHMgPSBuZXcgQm91bmRzKFxuXHRcdHdyYXBhcm91bmQgPyAtSW5maW5pdHkgOiBtaW4sXG5cdFx0d3JhcGFyb3VuZCA/IEluZmluaXR5IDogbWF4LFxuXHRcdG1pbixcblx0XHRtYXgpO1xuXHQvLyBjaGVjayBpZiB0aGUgbGF5ZXIgaXMgd2l0aGluIHRoZSB2aWV3cG9ydFxuXHRpZiAoIWJvdW5kcy5vdmVybGFwcyhsYXllckJvdW5kcykpIHtcblx0XHQvLyB0aGVyZSBpcyBubyBvdmVybGFwXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXHQvLyBjbGFtcCBob3Jpem9udGFsIGJvdW5kcyBpZiB0aGVyZSBpcyBubyB3cmFwYXJvdW5kXG5cdGNvbnN0IGxlZnQgPSB3cmFwYXJvdW5kID8gYm91bmRzLmxlZnQgOiBNYXRoLm1heChtaW4sIGJvdW5kcy5sZWZ0KTtcblx0Y29uc3QgcmlnaHQgPSB3cmFwYXJvdW5kID8gYm91bmRzLnJpZ2h0IDogTWF0aC5taW4obWF4LCBib3VuZHMucmlnaHQpO1xuXHQvLyBjbGFtcCB2ZXJ0aWNhbCBib3VuZHNcblx0Y29uc3QgYm90dG9tID0gTWF0aC5tYXgobWluLCBib3VuZHMuYm90dG9tKTtcblx0Y29uc3QgdG9wID0gTWF0aC5taW4obWF4LCBib3VuZHMudG9wKTtcblx0cmV0dXJuIG5ldyBCb3VuZHMobGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wKTtcbn07XG5cbmNvbnN0IGlzV2l0aGluUmFuZ2UgPSBmdW5jdGlvbihtaW4sIG1heCwgbSwgbikge1xuXHQvLyBHaXZlbjpcblx0Ly8gICAgMSkgQW4gaW50ZWdlciByYW5nZSByID0gW21pbiA6IG1heF0uXG5cdC8vICAgIDIpIEFuIHBvd2VyLW9mLXR3byBpbnRlZ2VyIG0uXG5cdC8vICAgIDMpIEFuIGludGVnZXIgbiB3aXRoaW4gdGhlIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgWzAgOiBtKS5cblx0Ly8gICAgNCkgQW4gaW50ZWdlciBjb25zdGFudCBrLlxuXHQvLyBDaGVjayBpZiBuLCBvciBhbnkgdmFsdWVzIG9mIG0gKy8tIGtuLCBpcyB3aXRoaW4gdGhlIHJhbmdlIFIuXG5cdC8vXG5cdC8vIEV4OlxuXHQvLyAgICAgbWluOiAtM1xuXHQvLyAgICAgbWF4OiA2XG5cdC8vICAgICBtOiA4XG5cdC8vICAgICBuOiA3XG5cdC8vXG5cdC8vIFJldHVybiB0cnVlIGJlY2F1c2UgNyAtIDggPSAtMSwgd2hpY2ggaXMgd2l0aGluIHRoZSByYW5nZSAtMyB0byA2LlxuXG5cdC8vIHdpdGhpbiByYW5nZVxuXHRpZiAobWluIDw9IG4gJiYgbiA8PSBtYXgpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIGlmIHRoZSByYW5nZSBpcyBhYm92ZSBuLCBmaW5kIGhvdyBtYW55IG0ncyBmaXRcblx0Ly8gaW4gdGhlIGRpc3RhbmNlIGJldHdlZW4gbiBhbmQgbWluXG5cdGlmIChtaW4gPiBuKSB7XG5cdFx0Y29uc3QgayA9IE1hdGguY2VpbCgobWluIC0gbikgLyBtKTtcblx0XHRyZXR1cm4gbiArIGsgKiBtIDw9IG1heDtcblx0fVxuXG5cdC8vIGlmIHRoZSByYW5nZSBpcyBiZWxvdyBuLCBmaW5kIGhvdyBtYW55IG0ncyBmaXRcblx0Ly8gaW4gdGhlIGRpc3RhbmNlIGJldHdlZW4gbWF4IGFuZCBuXG5cdGNvbnN0IGsgPSBNYXRoLmNlaWwoKG4gLSBtYXgpIC8gbSk7XG5cdHJldHVybiBuIC0gayAqIG0gPj0gbWluO1xufTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSB2aWV3cG9ydC5cbiAqL1xuY2xhc3MgVmlld3BvcnQge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgVmlld3BvcnQgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHZpZXdwb3J0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHZpZXdwb3J0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHZpZXdwb3J0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgdmlld3BvcnQuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0aWxlIGJvdW5kcyBvZiB0aGUgdmlld3BvcnQuIEJvdW5kcyBlZGdlcyBhcmUgaW5jbHVzaXZlLlxuXHQgKiBOT1RFOiB0aGlzIGluY2x1ZGVzIHdyYXBhcm91bmQgY29vcmRpbmF0ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aWxlWm9vbSAtIFRoZSB6b29tIG9mIHRoZSB0aWxlcyB3aXRoaW4gdGhlIHZpZXdwb3J0LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Qm91bmRzfSBUaGUgdGlsZSBib3VuZHMgb2YgdGhlIHZpZXdwb3J0LlxuXHQgKi9cblx0Z2V0VGlsZUJvdW5kcyh0aWxlWm9vbSkge1xuXHRcdC8vIGNhbGMgaG93IG1hbnkgZml0IGFyZSBpbiB0aGUgcGxvdFxuXHRcdGNvbnN0IHRpbGVTcGFuID0gMSAvIE1hdGgucG93KDIsIHRpbGVab29tKTtcblx0XHQvLyBkZXRlcm1pbmUgYm91bmRzXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMoXG5cdFx0XHRNYXRoLmZsb29yKHRoaXMueCAvIHRpbGVTcGFuKSxcblx0XHRcdE1hdGguY2VpbCgodGhpcy54ICsgdGhpcy53aWR0aCkgLyB0aWxlU3BhbikgLSAxLFxuXHRcdFx0TWF0aC5mbG9vcih0aGlzLnkgLyB0aWxlU3BhbiksXG5cdFx0XHRNYXRoLmNlaWwoKHRoaXMueSArIHRoaXMuaGVpZ2h0KSAvIHRpbGVTcGFuKSAtIDEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIHRoYXQgYXJlIHZpc2libGUgaW4gdGhlIHZpZXdwb3J0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGlsZVpvb20gLSBUaGUgem9vbSBvZiB0aGUgdGlsZXMgd2l0aGluIHRoZSB2aWV3cG9ydC4gT3B0aW9uYWwuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gd3JhcGFyb3VuZCAtIFRoZSBpZiB0aGUgaG9yaXpvbnRhbCBheGlzIHNob3VsZCB3cmFwYXJvdW5kLiBPcHRpb25hbC5cblx0ICpcblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2YgdmlzaWJsZSB0aWxlIGNvb3Jkcy5cblx0ICovXG5cdGdldFZpc2libGVDb29yZHModGlsZVpvb20sIHdyYXBhcm91bmQgPSBmYWxzZSkge1xuXHRcdC8vIGdldCB0aGUgYm91bmRzIGZvciB3aGF0IHRpbGVzIGFyZSBpbiB2aWV3XG5cdFx0Y29uc3QgYm91bmRzID0gZ2V0VmlzaWJsZVRpbGVCb3VuZHModGhpcywgdGlsZVpvb20sIHdyYXBhcm91bmQpO1xuXHRcdC8vIGNoZWNrIGlmIG5vIGNvb3JkcyBhcmUgaW4gdmlld1xuXHRcdGlmICghYm91bmRzKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXHRcdC8vIHJldHVybiBhbiBhcnJheSBvZiB0aGUgY29vcmRzXG5cdFx0Y29uc3QgY29vcmRzID0gW107XG5cdFx0Zm9yIChsZXQgeD1ib3VuZHMubGVmdDsgeDw9Ym91bmRzLnJpZ2h0OyB4KyspIHtcblx0XHRcdGZvciAobGV0IHk9Ym91bmRzLmJvdHRvbTsgeTw9Ym91bmRzLnRvcDsgeSsrKSB7XG5cdFx0XHRcdGNvb3Jkcy5wdXNoKG5ldyBUaWxlQ29vcmQodGlsZVpvb20sIHgsIHkpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNvb3Jkcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwcm92aWRlZCBjb29yZCBpcyB3aXRoaW4gdGhlIHZpZXdwb3J0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1RpbGVDb29yZH0gY29vcmQgLSBUaGUgY29vcmQuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gd3JhcGFyb3VuZCAtIFRoZSBpZiB0aGUgaG9yaXpvbnRhbCBheGlzIHNob3VsZCB3cmFwYXJvdW5kLiBPcHRpb25hbC5cblx0ICpcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBjb29yZCBpcyBpbiB2aWV3LlxuXHQgKi9cblx0aXNJblZpZXcoY29vcmQsIHdyYXBhcm91bmQgPSBmYWxzZSkge1xuXHRcdC8vIGdldCB0aGUgYm91bmRzIGZvciB3aGF0IHRpbGVzIGFyZSBpbiB2aWV3XG5cdFx0Y29uc3QgYm91bmRzID0gZ2V0VmlzaWJsZVRpbGVCb3VuZHModGhpcywgY29vcmQueiwgd3JhcGFyb3VuZCk7XG5cdFx0Ly8gY2hlY2sgaWYgbm8gY29vcmRzIGFyZSBpbiB2aWV3XG5cdFx0aWYgKCFib3VuZHMpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0Y29uc3QgZGltID0gTWF0aC5wb3coMiwgY29vcmQueik7XG5cdFx0cmV0dXJuIGlzV2l0aGluUmFuZ2UoYm91bmRzLmxlZnQsIGJvdW5kcy5yaWdodCwgZGltLCBjb29yZC54KSAmJlxuXHRcdFx0aXNXaXRoaW5SYW5nZShib3VuZHMuYm90dG9tLCBib3VuZHMudG9wLCBkaW0sIGNvb3JkLnkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB2aWV3cG9ydCB0aGF0IGhhcyBiZWVuIHpvb21lZCBhcm91bmQgYSBwcm92aWRlZCBwb3NpdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHpvb20gLSBUaGUgY3VycmVudCB6b29tIG9mIHRoZSB2aWV3cG9ydC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFpvb20gLSBUaGUgdGFyZ2V0IHpvb20gb2YgdGhlIHZpZXdwb3J0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0UG9zIC0gVGhlIHRhcmdldCBwb3NpdGlvbiB0byB6b29tIGFyb3VuZC5cblx0ICpcblx0ICogQHJldHVybnMge1ZpZXdwb3J0fSBUaGUgbmV3IHZpZXdwb3J0IG9iamVjdC5cblx0ICovXG5cdHpvb21Ub1Bvcyh6b29tLCB0YXJnZXRab29tLCB0YXJnZXRQb3MpIHtcblx0XHRjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIHRhcmdldFpvb20gLSB6b29tKTtcblx0XHRjb25zdCBzY2FsZWRXaWR0aCA9IHRoaXMud2lkdGggLyBzY2FsZTtcblx0XHRjb25zdCBzY2FsZWRIZWlnaHQgPSB0aGlzLmhlaWdodCAvIHNjYWxlO1xuXHRcdGNvbnN0IGRpZmYgPSB7XG5cdFx0XHR4OiAodGFyZ2V0UG9zLnggLSB0aGlzLngpIC8gc2NhbGUsXG5cdFx0XHR5OiAodGFyZ2V0UG9zLnkgLSB0aGlzLnkpIC8gc2NhbGVcblx0XHR9O1xuXHRcdHJldHVybiBuZXcgVmlld3BvcnQoXG5cdFx0XHR0YXJnZXRQb3MueCAtIGRpZmYueCxcblx0XHRcdHRhcmdldFBvcy55IC0gZGlmZi55LFxuXHRcdFx0c2NhbGVkV2lkdGgsXG5cdFx0XHRzY2FsZWRIZWlnaHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxvd2VyLWxlZnQgY29ybmVyIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydCBpbiBwbG90XG5cdCAqIGNvb3JkaW5hdGVzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcGxvdCBwb3NpdGlvbi5cblx0ICovXG5cdGdldFBvc2l0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB0aGlzLngsXG5cdFx0XHR5OiB0aGlzLnlcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnQgaW4gcGxvdCBjb29yZGluYXRlcy5cblx0ICpcblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIHBsb3QgY2VudGVyLlxuXHQgKi9cblx0Z2V0Q2VudGVyKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB0aGlzLnggKyB0aGlzLndpZHRoIC8gMixcblx0XHRcdHk6IHRoaXMueSArIHRoaXMuaGVpZ2h0IC8gMlxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdmlld3BvcnRzIHNpemUgaW4gcGl4ZWxzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gem9vbSAtIFRoZSB6b29tIG9mIHRoZSBwbG90LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGlsZVNpemUgLSBUaGUgc2l6ZSBvZiBhIHRpbGUgaW4gcGl4ZWxzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgdmlldyBzaXplIGluIHBpeGVscy5cblx0ICovXG5cdGdldFBpeGVsU2l6ZSh6b29tLCB0aWxlU2l6ZSkge1xuXHRcdGNvbnN0IGV4dGVudCA9IE1hdGgucG93KDIsIHpvb20pICogdGlsZVNpemU7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpZHRoOiBNYXRoLnJvdW5kKHRoaXMud2lkdGggKiBleHRlbnQpLFxuXHRcdFx0aGVpZ2h0OiBNYXRoLnJvdW5kKHRoaXMuaGVpZ2h0ICogZXh0ZW50KVxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdmlld3BvcnRzIG9mZnNldCBpbiBwaXhlbHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIC0gVGhlIHpvb20gb2YgdGhlIHBsb3QuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aWxlU2l6ZSAtIFRoZSBzaXplIG9mIGEgdGlsZSBpbiBwaXhlbHMuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSB2aWV3IG9mZnNldCBpbiBwaXhlbHMuXG5cdCAqL1xuXHRnZXRQaXhlbE9mZnNldCh6b29tLCB0aWxlU2l6ZSkge1xuXHRcdGNvbnN0IGV4dGVudCA9IE1hdGgucG93KDIsIHpvb20pICogdGlsZVNpemU7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHRoaXMueCAqIGV4dGVudCxcblx0XHRcdHk6IHRoaXMueSAqIGV4dGVudFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQ2VudGVycyB0aGUgdmlld3BvcnQgb24gYSBnaXZlbiBwbG90IGNvb3JkaW5hdGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwb3MgLSBUaGUgcG9zaXRpb24gdG8gY2VudGVyIHRoZSB2aWV3cG9ydCBvbi5cblx0ICpcblx0ICogQHJldHVybnMge1ZpZXdwb3J0fSBUaGUgdmlld3BvcnQgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRjZW50ZXJPbihwb3MpIHtcblx0XHR0aGlzLnggPSBwb3MueCAtIHRoaXMud2lkdGggLyAyO1xuXHRcdHRoaXMueSA9IHBvcy55IC0gdGhpcy5oZWlnaHQgLyAyO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVmlld3BvcnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGFuaW1hdGlvbi5cbiAqL1xuY2xhc3MgQW5pbWF0aW9uIHtcblxuXHQvKipcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IEFuaW1hdGlvbiBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBvZiB0aGUgYW5pbWF0aW9uLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnBsb3QgLSBUaGUgcGxvdCB0YXJnZXQgb2YgdGhlIGFuaW1hdGlvbi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5kdXJhdGlvbiAtIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlxuXHQgKi9cblx0Y29uc3RydWN0b3IocGFyYW1zKSB7XG5cdFx0dGhpcy50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuXHRcdHRoaXMuZHVyYXRpb24gPSBwYXJhbXMuZHVyYXRpb247XG5cdFx0dGhpcy5wbG90ID0gcGFyYW1zLnBsb3Q7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdC12YWx1ZSBvZiB0aGUgYW5pbWF0aW9uIGJhc2VkIG9uIHRoZSBwcm92aWRlZCB0aW1lc3RhbXAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXAgLSBUaGUgZnJhbWUgdGltZXN0YW1wLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgdC12YWx1ZSBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgdGltZXN0YW1wLlxuXHQgKi9cblx0Z2V0VCh0aW1lc3RhbXApIHtcblx0XHRpZiAodGhpcy5kdXJhdGlvbiA+IDApIHtcblx0XHRcdHJldHVybiBNYXRoLm1pbigxLjAsICh0aW1lc3RhbXAgLSB0aGlzLnRpbWVzdGFtcCkgLyB0aGlzLmR1cmF0aW9uKTtcblx0XHR9XG5cdFx0cmV0dXJuIDEuMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSB0aGUgcGxvdCBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGVcblx0ICogYW5pbWF0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gVGhlIGZyYW1lIHRpbWVzdGFtcC5cblx0ICpcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlxuXHQgKi9cblx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblx0dXBkYXRlKHRpbWVzdGFtcCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbmNlbCB0aGUgYW5pbWF0aW9uIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcGxvdC5cblx0ICovXG5cdGNhbmNlbCgpIHtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wbGV0ZSB0aGUgYW5pbWF0aW9uIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcGxvdC5cblx0ICovXG5cdGZpbmlzaCgpIHtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFuaW1hdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRUeXBlID0gcmVxdWlyZSgnLi4vLi4vZXZlbnQvRXZlbnRUeXBlJyk7XG5jb25zdCBFdmVudCA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50L0V2ZW50Jyk7XG5jb25zdCBBbmltYXRpb24gPSByZXF1aXJlKCcuL0FuaW1hdGlvbicpO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHBhbiBhbmltYXRpb24uXG4gKi9cbmNsYXNzIFBhbkFuaW1hdGlvbiBleHRlbmRzIEFuaW1hdGlvbiB7XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBQYW5BbmltYXRpb24gb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgb2YgdGhlIGFuaW1hdGlvbi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5wbG90IC0gVGhlIHBsb3QgdGFyZ2V0IG9mIHRoZSBhbmltYXRpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZHVyYXRpb24gLSBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdGFydCAtIFRoZSBzdGFydCB0aW1lc3RhbXAgb2YgdGhlIGFuaW1hdGlvbi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5kZWx0YSAtIFRoZSBwb3NpdGlvbmFsIGRlbHRhIG9mIHRoZSBhbmltYXRpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZWFzaW5nIC0gVGhlIGVhc2luZyBmYWN0b3Igb2YgdGhlIGFuaW1hdGlvbi5cblx0ICovXG5cdGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG5cdFx0c3VwZXIocGFyYW1zKTtcblx0XHR0aGlzLnN0YXJ0ID0gcGFyYW1zLnN0YXJ0O1xuXHRcdHRoaXMuZGVsdGEgPSBwYXJhbXMuZGVsdGE7XG5cdFx0dGhpcy5lbmQgPSB7XG5cdFx0XHR4OiB0aGlzLnN0YXJ0LnggKyB0aGlzLmRlbHRhLngsXG5cdFx0XHR5OiB0aGlzLnN0YXJ0LnkgKyB0aGlzLmRlbHRhLnksXG5cdFx0fTtcblx0XHR0aGlzLmVhc2luZyA9IHBhcmFtcy5lYXNpbmc7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHBsb3QgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlXG5cdCAqIGFuaW1hdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcCAtIFRoZSBmcmFtZSB0aW1lc3RhbXAuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgYW5pbWF0aW9uIGhhcyBmaW5pc2hlZC5cblx0ICovXG5cdHVwZGF0ZSh0aW1lc3RhbXApIHtcblx0XHRjb25zdCB0ID0gdGhpcy5nZXRUKHRpbWVzdGFtcCk7XG5cdFx0Ly8gY2FsY3VsYXRlIHRoZSBwcm9ncmVzcyBvZiB0aGUgYW5pbWF0aW9uXG5cdFx0Y29uc3QgcHJvZ3Jlc3MgPSAxIC0gTWF0aC5wb3coMSAtIHQsIDEgLyB0aGlzLmVhc2luZyk7XG5cdFx0Ly8gY2FjbHVsYXRlIHRoZSBjdXJyZW50IHBvc2l0aW9uIGFsb25nIHRoZSBwYW5cblx0XHRjb25zdCBwbG90ID0gdGhpcy5wbG90O1xuXHRcdC8vIHNldCB0aGUgdmlld3BvcnQgcG9zaXRpb25zXG5cdFx0cGxvdC52aWV3cG9ydC54ID0gdGhpcy5zdGFydC54ICsgdGhpcy5kZWx0YS54ICogcHJvZ3Jlc3M7XG5cdFx0cGxvdC52aWV3cG9ydC55ID0gdGhpcy5zdGFydC55ICsgdGhpcy5kZWx0YS55ICogcHJvZ3Jlc3M7XG5cdFx0Ly8gY3JlYXRlIHBhbiBldmVudFxuXHRcdGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KHBsb3QpO1xuXHRcdC8vIGNoZWNrIGlmIGFuaW1hdGlvbiBpcyBmaW5pc2hlZFxuXHRcdGlmICh0IDwgMSkge1xuXHRcdFx0cGxvdC5lbWl0KEV2ZW50VHlwZS5QQU4sIGV2ZW50KTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cGxvdC5lbWl0KEV2ZW50VHlwZS5QQU5fRU5ELCBldmVudCk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogQ2FuY2VscyB0aGUgY3VycmVudCBhbmltYXRpb24gYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgcGxvdC5cblx0ICovXG5cdGNhbmNlbCgpIHtcblx0XHRjb25zdCBwbG90ID0gdGhpcy5wbG90O1xuXHRcdC8vIGVtaXQgcGFuIGVuZFxuXHRcdHBsb3QuZW1pdChFdmVudFR5cGUuUEFOX0VORCwgbmV3IEV2ZW50KHBsb3QpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wbGV0ZSB0aGUgY3VycmVudCBhbmltYXRpb24gYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBwbG90LlxuXHQgKi9cblx0ZmluaXNoKCkge1xuXHRcdGNvbnN0IHBsb3QgPSB0aGlzLnBsb3Q7XG5cdFx0Ly8gc2V0IHRoZSB2aWV3cG9ydCBwb3NpdGlvbnNcblx0XHRwbG90LnZpZXdwb3J0LnggPSB0aGlzLmVuZC54O1xuXHRcdHBsb3Qudmlld3BvcnQueSA9IHRoaXMuZW5kLnk7XG5cdFx0Ly8gZW1pdCBwYW4gZW5kXG5cdFx0cGxvdC5lbWl0KEV2ZW50VHlwZS5QQU5fRU5ELCBuZXcgRXZlbnQocGxvdCkpO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGFuQW5pbWF0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudFR5cGUgPSByZXF1aXJlKCcuLi8uLi9ldmVudC9FdmVudFR5cGUnKTtcbmNvbnN0IEV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vZXZlbnQvRXZlbnQnKTtcbmNvbnN0IEFuaW1hdGlvbiA9IHJlcXVpcmUoJy4vQW5pbWF0aW9uJyk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgem9vbSBhbmltYXRpb24uXG4gKi9cbmNsYXNzIFpvb21BbmltYXRpb24gZXh0ZW5kcyBBbmltYXRpb24ge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgWm9vbUFuaW1hdGlvbiBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBvZiB0aGUgYW5pbWF0aW9uLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnBsb3QgLSBUaGUgcGxvdCB0YXJnZXQgb2YgdGhlIGFuaW1hdGlvbi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5kdXJhdGlvbiAtIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnByZXZab29tIC0gVGhlIHN0YXJ0aW5nIHpvb20gb2YgdGhlIGFuaW1hdGlvbi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy50YXJnZXRab29tIC0gVGhlIHRhcmdldCB6b29tIG9mIHRoZSBhbmltYXRpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMucHJldlZpZXdwb3J0IC0gVGhlIHN0YXJ0aW5nIHZpZXdwb3J0IG9mIHRoZSBhbmltYXRpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudGFyZ2V0Vmlld3BvcnQgLSBUaGUgdGFyZ2V0IHZpZXdwb3J0IG9mIHRoZSBhbmltYXRpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudGFyZ2V0UG9zIC0gVGhlIHRhcmdldCBwb3NpdGlvbiBvZiB0aGUgYW5pbWF0aW9uLCBpbiBwbG90IGNvb3JkaW5hdGVzLlxuXHQgKi9cblx0Y29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcblx0XHRzdXBlcihwYXJhbXMpO1xuXHRcdHRoaXMucHJldlpvb20gPSBwYXJhbXMucHJldlpvb207XG5cdFx0dGhpcy50YXJnZXRab29tID0gcGFyYW1zLnRhcmdldFpvb207XG5cdFx0dGhpcy5wcmV2Vmlld3BvcnQgPSBwYXJhbXMucHJldlZpZXdwb3J0O1xuXHRcdHRoaXMudGFyZ2V0Vmlld3BvcnQgPSBwYXJhbXMudGFyZ2V0Vmlld3BvcnQ7XG5cdFx0dGhpcy50YXJnZXRQb3MgPSBwYXJhbXMudGFyZ2V0UG9zO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIHpvb20gb2YgdGhlIHBsb3QgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlXG5cdCAqIGFuaW1hdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcCAtIFRoZSBmcmFtZSB0aW1lc3RhbXAuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgYW5pbWF0aW9uIGhhcyBmaW5pc2hlZC5cblx0ICovXG5cdHVwZGF0ZSh0aW1lc3RhbXApIHtcblx0XHRjb25zdCB0ID0gdGhpcy5nZXRUKHRpbWVzdGFtcCk7XG5cdFx0Ly8gY2FsYyBuZXcgem9vbVxuXHRcdGNvbnN0IHJhbmdlID0gdGhpcy50YXJnZXRab29tIC0gdGhpcy5wcmV2Wm9vbTtcblx0XHRjb25zdCB6b29tID0gdGhpcy5wcmV2Wm9vbSArIChyYW5nZSAqIHQpO1xuXHRcdGNvbnN0IHBsb3QgPSB0aGlzLnBsb3Q7XG5cdFx0Ly8gc2V0IG5ldyB6b29tXG5cdFx0cGxvdC56b29tID0gem9vbTtcblx0XHQvLyBjYWxjIG5ldyB2aWV3cG9ydCBwb3NpdGlvbiBmcm9tIHByZXZcblx0XHRwbG90LnZpZXdwb3J0ID0gdGhpcy5wcmV2Vmlld3BvcnQuem9vbVRvUG9zKFxuXHRcdFx0dGhpcy5wcmV2Wm9vbSxcblx0XHRcdHBsb3Quem9vbSxcblx0XHRcdHRoaXMudGFyZ2V0UG9zKTtcblx0XHQvLyBjcmVhdGUgem9vbSBldmVudFxuXHRcdGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KHBsb3QpO1xuXHRcdC8vIGNoZWNrIGlmIGFuaW1hdGlvbiBpcyBmaW5pc2hlZFxuXHRcdGlmICh0IDwgMSkge1xuXHRcdFx0cGxvdC5lbWl0KEV2ZW50VHlwZS5aT09NLCBldmVudCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHBsb3QuZW1pdChFdmVudFR5cGUuWk9PTV9FTkQsIGV2ZW50KTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYW5jZWxzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBwbG90LlxuXHQgKi9cblx0Y2FuY2VsKCkge1xuXHRcdGNvbnN0IHBsb3QgPSB0aGlzLnBsb3Q7XG5cdFx0aWYgKCFwbG90LmNvbnRpbnVvdXNab29tKSB7XG5cdFx0XHQvLyByb3VuZCB0byB0aGUgY2xvc2VzdCB6b29tXG5cdFx0XHRwbG90Lnpvb20gPSBNYXRoLnJvdW5kKHBsb3Quem9vbSk7XG5cdFx0XHQvLyBjYWxjIHZpZXdwb3J0IHBvc2l0aW9uIGZyb20gcHJldlxuXHRcdFx0cGxvdC52aWV3cG9ydCA9IHRoaXMucHJldlZpZXdwb3J0Lnpvb21Ub1Bvcyhcblx0XHRcdFx0dGhpcy5wcmV2Wm9vbSxcblx0XHRcdFx0cGxvdC56b29tLFxuXHRcdFx0XHR0aGlzLnRhcmdldFBvcyk7XG5cdFx0fVxuXHRcdC8vIGVtaXQgem9vbSBlbmRcblx0XHRjb25zdCBldmVudCA9IG5ldyBFdmVudChwbG90KTtcblx0XHRwbG90LmVtaXQoRXZlbnRUeXBlLlpPT01fRU5ELCBldmVudCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29tcGxldGUgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcGxvdC5cblx0ICovXG5cdGZpbmlzaCgpIHtcblx0XHRjb25zdCBwbG90ID0gdGhpcy5wbG90O1xuXHRcdHBsb3Quem9vbSA9IHRoaXMudGFyZ2V0Wm9vbTtcblx0XHRwbG90LnZpZXdwb3J0ID0gdGhpcy50YXJnZXRWaWV3cG9ydDtcblx0XHQvLyBlbWl0IHpvb20gZW5kXG5cdFx0Y29uc3QgZXZlbnQgPSBuZXcgRXZlbnQocGxvdCk7XG5cdFx0cGxvdC5lbWl0KEV2ZW50VHlwZS5aT09NX0VORCwgZXZlbnQpO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWm9vbUFuaW1hdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRUeXBlID0gcmVxdWlyZSgnLi4vLi4vZXZlbnQvRXZlbnRUeXBlJyk7XG5jb25zdCBNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vZXZlbnQvTW91c2VFdmVudCcpO1xuY29uc3QgRE9NSGFuZGxlciA9IHJlcXVpcmUoJy4vRE9NSGFuZGxlcicpO1xuXG4vLyBDb25zdGFudHNcblxuLyoqXG4gKiBEaXN0YW5jZSBpbiBwaXhlbHMgdGhlIG1vdXNlIGNhbiBiZSBtb3ZlZCBiZWZvcmUgdGhlIGNsaWNrIGV2ZW50IGlzXG4gKiBjYW5jZWxsZWQuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50IHtudW1iZXJ9XG4gKi9cbmNvbnN0IE1PVkVfVE9MRVJBTkNFID0gMTU7XG5cbi8vIFByaXZhdGUgTWV0aG9kc1xuXG5jb25zdCBjcmVhdGVFdmVudCA9IGZ1bmN0aW9uKGhhbmRsZXIsIHBsb3QsIGV2ZW50KSB7XG5cdHJldHVybiBuZXcgTW91c2VFdmVudChcblx0XHRwbG90LCAvLyB0YXJnZXRcblx0XHRldmVudCwgLy8gb3JpZ2luYWxFdmVudFxuXHRcdGhhbmRsZXIubW91c2VUb1Bsb3QoZXZlbnQpLCAvLyBwb3Ncblx0XHRoYW5kbGVyLm1vdXNlVG9WaWV3UHgoZXZlbnQpKTsgLy8gcHhcbn07XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgY2xpY2sgaGFuZGxlci5cbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENsaWNrSGFuZGxlciBleHRlbmRzIERPTUhhbmRsZXIge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgQ2xpY2tIYW5kbGVyIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtQbG90fSBwbG90IC0gVGhlIHBsb3QgdG8gYXR0YWNoIHRoZSBoYW5kbGVyIHRvLlxuXHQgKi9cblx0Y29uc3RydWN0b3IocGxvdCkge1xuXHRcdHN1cGVyKHBsb3QpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgdGhlIGhhbmRsZXIuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtDbGlja0hhbmRsZXJ9IFRoZSBoYW5kbGVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0ZW5hYmxlKCkge1xuXHRcdHN1cGVyLmVuYWJsZSgpO1xuXG5cdFx0Y29uc3QgcGxvdCA9IHRoaXMucGxvdDtcblxuXHRcdGxldCBsYXN0ID0gbnVsbDtcblx0XHR0aGlzLm1vdXNlZG93biA9IChldmVudCkgPT4ge1xuXHRcdFx0bGFzdCA9IHRoaXMubW91c2VUb1ZpZXdQeChldmVudCk7XG5cdFx0fTtcblxuXHRcdHRoaXMubW91c2V1cCA9IChldmVudCkgPT4ge1xuXHRcdFx0aWYgKCFsYXN0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHBvcyA9IHRoaXMubW91c2VUb1ZpZXdQeChldmVudCk7XG5cdFx0XHRjb25zdCBkaWZmID0ge1xuXHRcdFx0XHR4OiBsYXN0LnggLSBwb3MueCAsXG5cdFx0XHRcdHk6IGxhc3QueSAtIHBvcy55XG5cdFx0XHR9O1xuXHRcdFx0Y29uc3QgZGlzdFNxcmQgPSBkaWZmLnggKiBkaWZmLnggKyBkaWZmLnkgKiBkaWZmLnk7XG5cdFx0XHRpZiAoZGlzdFNxcmQgPCBNT1ZFX1RPTEVSQU5DRSAqIE1PVkVfVE9MRVJBTkNFKSB7XG5cdFx0XHRcdC8vIG1vdmVtZW50IHdhcyB3aXRoaW4gdG9sZXJhbmNlLCBlbWl0IGNsaWNrXG5cdFx0XHRcdHBsb3Quc2V0RGlydHkoKTtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0dGhpcy5wbG90LmVtaXQoRXZlbnRUeXBlLkNMSUNLLCBjcmVhdGVFdmVudCh0aGlzLCBwbG90LCBldmVudCkpO1xuXHRcdFx0fVxuXHRcdFx0bGFzdCA9IG51bGw7XG5cdFx0fTtcblxuXHRcdHRoaXMuZGJsY2xpY2sgPSAoZXZlbnQpID0+IHtcblx0XHRcdHBsb3Quc2V0RGlydHkoKTtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR0aGlzLnBsb3QuZW1pdChFdmVudFR5cGUuREJMX0NMSUNLLCBjcmVhdGVFdmVudCh0aGlzLCBwbG90LCBldmVudCkpO1xuXHRcdH07XG5cblx0XHRjb25zdCBjb250YWluZXIgPSBwbG90LmdldENvbnRhaW5lcigpO1xuXHRcdGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bik7XG5cdFx0Y29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm1vdXNldXApO1xuXHRcdGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHRoaXMuZGJsY2xpY2spO1xuXHR9XG5cblx0LyoqXG5cdCAqIERpc2FibGVzIHRoZSBoYW5kbGVyLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Q2xpY2tIYW5kbGVyfSBUaGUgaGFuZGxlciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdGRpc2FibGUoKSB7XG5cdFx0c3VwZXIuZGlzYWJsZSgpO1xuXHRcdGNvbnN0IGNvbnRhaW5lciA9IHRoaXMucGxvdC5nZXRDb250YWluZXIoKTtcblx0XHRjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZWRvd24pO1xuXHRcdGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5tb3VzZXVwKTtcblx0XHRjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCB0aGlzLmRibGNsaWNrKTtcblx0XHR0aGlzLm1vdXNlZG93biA9IG51bGw7XG5cdFx0dGhpcy5tb3VzZXVwID0gbnVsbDtcblx0XHR0aGlzLmRibGNsaWNrID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENsaWNrSGFuZGxlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBET00gaGFuZGxlci5cbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIERPTUhhbmRsZXIge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgRE9NIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtQbG90fSBwbG90IC0gVGhlIHBsb3QgdG8gYXR0YWNoIHRoZSBoYW5kbGVyIHRvLlxuXHQgKi9cblx0Y29uc3RydWN0b3IocGxvdCkge1xuXHRcdHRoaXMucGxvdCA9IHBsb3Q7XG5cdFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogRW5hYmxlcyB0aGUgaGFuZGxlci5cblx0ICpcblx0ICogQHJldHVybnMge1pvb21IYW5kbGVyfSBUaGUgaGFuZGxlciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdGVuYWJsZSgpIHtcblx0XHRpZiAodGhpcy5lbmFibGVkKSB7XG5cdFx0XHR0aHJvdyAnSGFuZGxlciBpcyBhbHJlYWR5IGVuYWJsZWQnO1xuXHRcdH1cblx0XHR0aGlzLmVuYWJsZSA9IHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogRGlzYWJsZXMgdGhlIGhhbmRsZXIuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtab29tSGFuZGxlcn0gVGhlIGhhbmRsZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRkaXNhYmxlKCkge1xuXHRcdGlmICh0aGlzLmVuYWJsZWQpIHtcblx0XHRcdHRocm93ICdIYW5kbGVyIGlzIGFscmVhZHkgZGlzYWJsZWQnO1xuXHRcdH1cblx0XHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUYWtlcyBhIERPTSBldmVudCBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwbG90IHBvc2l0aW9uLlxuXHQgKiBDb29yZGluYXRlIFswLCAwXSBpcyBib3R0b20tbGVmdCBvZiB0aGUgcGxvdC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgbW91c2UgZXZlbnQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwbG90IHBvc2l0aW9uLlxuXHQgKi9cblx0bW91c2VUb1Bsb3QoZXZlbnQpIHtcblx0XHRjb25zdCBwbG90ID0gdGhpcy5wbG90O1xuXHRcdGNvbnN0IGV4dGVudCA9IHBsb3QuZ2V0UGl4ZWxFeHRlbnQoKTtcblx0XHRjb25zdCBzaXplID0gcGxvdC5nZXRWaWV3cG9ydFBpeGVsU2l6ZSgpO1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiBwbG90LnZpZXdwb3J0LnggKyAoZXZlbnQuY2xpZW50WCAvIGV4dGVudCksXG5cdFx0XHR5OiBwbG90LnZpZXdwb3J0LnkgKyAoKHNpemUuaGVpZ2h0IC0gZXZlbnQuY2xpZW50WSkgLyBleHRlbnQpXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUYWtlcyBhIERPTSBldmVudCBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyB2aWV3cG9ydCBwaXhlbCBwb3NpdGlvbi5cblx0ICogQ29vcmRpbmF0ZSBbMCwgMF0gaXMgYm90dG9tLWxlZnQgb2YgdGhlIHZpZXdwb3J0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBtb3VzZSBldmVudC5cblx0ICpcblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIHZpZXdwb3J0IHBpeGVsIGNvb3JkaW5hdGUuXG5cdCAqL1xuXHRtb3VzZVRvVmlld1B4KGV2ZW50KSB7XG5cdFx0Y29uc3Qgc2l6ZSA9IHRoaXMucGxvdC5nZXRWaWV3cG9ydFBpeGVsU2l6ZSgpO1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiBldmVudC5jbGllbnRYLFxuXHRcdFx0eTogc2l6ZS5oZWlnaHQgLSBldmVudC5jbGllbnRZXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUYWtlcyBhIHZpZXdwb3J0IHBpeGVsIGNvb3JkaW5hdGUgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGxvdFxuXHQgKiBwb3NpdGlvbi5cblx0ICogQ29vcmRpbmF0ZSBbMCwgMF0gaXMgYm90dG9tLWxlZnQgb2YgdGhlIHBsb3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBweCAtIFRoZSB2aWV3cG9ydCBwaXhlbCBjb29yZGluYXRlLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcGxvdCBwb3NpdGlvbi5cblx0ICovXG5cdHZpZXdQeFRvUGxvdChweCkge1xuXHRcdGNvbnN0IGV4dGVudCA9IHRoaXMucGxvdC5nZXRQaXhlbEV4dGVudCgpO1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiBweC54IC8gZXh0ZW50LFxuXHRcdFx0eTogcHgueSAvIGV4dGVudFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogVGFrZXMgYSBwbG90IHBvc2l0aW9uIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHZpZXdwb3J0IHBpeGVsXG5cdCAqIGNvb3JkaW5hdGUuXG5cdCAqIENvb3JkaW5hdGUgWzAsIDBdIGlzIGJvdHRvbS1sZWZ0IG9mIHRoZSBwbG90LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcG9zIC0gVGhlIHBsb3QgcG9zaXRpb24uXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSB2aWV3cG9ydCBwaXhlbCBjb29yZGluYXRlLlxuXHQgKi9cblx0cGxvdFRvVmlld1B4KHBvcykge1xuXHRcdGNvbnN0IGV4dGVudCA9IHRoaXMucGxvdC5nZXRQaXhlbEV4dGVudCgpO1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiBwb3MueCAqIGV4dGVudCxcblx0XHRcdHk6IHBvcy55ICogZXh0ZW50XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUYWtlcyBhIERPTSBldmVudCBhbmQgcmV0dXJucyB0cnVlIGlmIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBpcyBkb3duLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBtb3VzZSBldmVudC5cblx0ICpcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGlzIGRvd24uXG5cdCAqL1xuXHRpc0xlZnRCdXR0b24oZXZlbnQpIHtcblx0XHRyZXR1cm4gKGV2ZW50LndoaWNoKSA/IGV2ZW50LndoaWNoID09PSAxIDogZXZlbnQuYnV0dG9uID09PSAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRha2VzIGEgRE9NIGV2ZW50IGFuZCByZXR1cm5zIHRydWUgaWYgdGhlIG1pZGRsZSBtb3VzZSBidXR0b24gaXMgZG93bi5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgbW91c2UgZXZlbnQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBtaWRkbGUgbW91c2UgYnV0dG9uIGlzIGRvd24uXG5cdCAqL1xuXHRpc01pZGRsZUJ1dHRvbihldmVudCkge1xuXHRcdHJldHVybiAoZXZlbnQud2hpY2gpID8gZXZlbnQud2hpY2ggPT09IDIgOiBldmVudC5idXR0b24gPT09IDE7XG5cdH1cblxuXHQvKipcblx0ICogVGFrZXMgYSBET00gZXZlbnQgYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGUgcmlnaHQgbW91c2UgYnV0dG9uIGlzIGRvd24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIG1vdXNlIGV2ZW50LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcmlnaHQgbW91c2UgYnV0dG9uIGlzIGRvd24uXG5cdCAqL1xuXHRpc1JpZ2h0QnV0dG9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIChldmVudC53aGljaCkgPyBldmVudC53aGljaCA9PT0gMyA6IGV2ZW50LmJ1dHRvbiA9PT0gMjtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERPTUhhbmRsZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50VHlwZSA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50L0V2ZW50VHlwZScpO1xuY29uc3QgTW91c2VFdmVudCA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50L01vdXNlRXZlbnQnKTtcbmNvbnN0IERPTUhhbmRsZXIgPSByZXF1aXJlKCcuL0RPTUhhbmRsZXInKTtcblxuLy8gUHJpdmF0ZSBNZXRob2RzXG5cbmNvbnN0IGNyZWF0ZUV2ZW50ID0gZnVuY3Rpb24oaGFuZGxlciwgcGxvdCwgZXZlbnQpIHtcblx0cmV0dXJuIG5ldyBNb3VzZUV2ZW50KFxuXHRcdHBsb3QsIC8vIHRhcmdldFxuXHRcdGV2ZW50LCAvLyBvcmlnaW5hbEV2ZW50XG5cdFx0aGFuZGxlci5tb3VzZVRvUGxvdChldmVudCksIC8vIHBvc1xuXHRcdGhhbmRsZXIubW91c2VUb1ZpZXdQeChldmVudCkpOyAvLyBweFxufTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBtb3VzZSBoYW5kbGVyLlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgTW91c2VIYW5kbGVyIGV4dGVuZHMgRE9NSGFuZGxlciB7XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBNb3VzZUhhbmRsZXIgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1Bsb3R9IHBsb3QgLSBUaGUgcGxvdCB0byBhdHRhY2ggdGhlIGhhbmRsZXIgdG8uXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihwbG90KSB7XG5cdFx0c3VwZXIocGxvdCk7XG5cdH1cblxuXHQvKipcblx0ICogRW5hYmxlcyB0aGUgaGFuZGxlci5cblx0ICpcblx0ICogQHJldHVybnMge01vdXNlSGFuZGxlcn0gVGhlIGhhbmRsZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRlbmFibGUoKSB7XG5cdFx0c3VwZXIuZW5hYmxlKCk7XG5cblx0XHRjb25zdCBwbG90ID0gdGhpcy5wbG90O1xuXG5cdFx0dGhpcy5tb3VzZWRvd24gPSAoZXZlbnQpID0+IHtcblx0XHRcdHBsb3Quc2V0RGlydHkoKTtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRwbG90LmVtaXQoRXZlbnRUeXBlLk1PVVNFX0RPV04sIGNyZWF0ZUV2ZW50KHRoaXMsIHBsb3QsIGV2ZW50KSk7XG5cdFx0fTtcblxuXHRcdHRoaXMubW91c2V1cCA9IChldmVudCkgPT4ge1xuXHRcdFx0cGxvdC5zZXREaXJ0eSgpO1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHBsb3QuZW1pdChFdmVudFR5cGUuTU9VU0VfVVAsIGNyZWF0ZUV2ZW50KHRoaXMsIHBsb3QsIGV2ZW50KSk7XG5cdFx0fTtcblxuXHRcdHRoaXMubW91c2Vtb3ZlID0gKGV2ZW50KSA9PiB7XG5cdFx0XHRwbG90LnNldERpcnR5KCk7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0cGxvdC5lbWl0KEV2ZW50VHlwZS5NT1VTRV9NT1ZFLCBjcmVhdGVFdmVudCh0aGlzLCBwbG90LCBldmVudCkpO1xuXHRcdH07XG5cblx0XHR0aGlzLm1vdXNlb3ZlciA9IChldmVudCkgPT4ge1xuXHRcdFx0cGxvdC5zZXREaXJ0eSgpO1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHBsb3QuZW1pdChFdmVudFR5cGUuTU9VU0VfT1ZFUiwgY3JlYXRlRXZlbnQodGhpcywgcGxvdCwgZXZlbnQpKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5tb3VzZW91dCA9IChldmVudCkgPT4ge1xuXHRcdFx0cGxvdC5zZXREaXJ0eSgpO1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHBsb3QuZW1pdChFdmVudFR5cGUuTU9VU0VfT1VULCBjcmVhdGVFdmVudCh0aGlzLCBwbG90LCBldmVudCkpO1xuXHRcdH07XG5cblx0XHR0aGlzLndoZWVsID0gKGV2ZW50KSA9PiB7XG5cdFx0XHRwbG90LnNldERpcnR5KCk7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH07XG5cblx0XHRjb25zdCBjb250YWluZXIgPSBwbG90LmdldENvbnRhaW5lcigpO1xuXHRcdGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bik7XG5cdFx0Y29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm1vdXNldXApO1xuXHRcdGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm1vdXNlbW92ZSk7XG5cdFx0Y29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMubW91c2VvdmVyKTtcblx0XHRjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLm1vdXNlb3V0KTtcblx0XHRjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLndoZWVsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNhYmxlcyB0aGUgaGFuZGxlci5cblx0ICpcblx0ICogQHJldHVybnMge01vdXNlSGFuZGxlcn0gVGhlIGhhbmRsZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRkaXNhYmxlKCkge1xuXHRcdHN1cGVyLmRpc2FibGUoKTtcblxuXHRcdGNvbnN0IGNvbnRhaW5lciA9IHRoaXMucGxvdC5nZXRDb250YWluZXIoKTtcblx0XHRjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZWRvd24pO1xuXHRcdGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5tb3VzZXVwKTtcblx0XHRjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5tb3VzZW1vdmUpO1xuXHRcdGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm1vdXNlb3Zlcik7XG5cdFx0Y29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5tb3VzZW91dCk7XG5cdFx0Y29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy53aGVlbCk7XG5cdFx0dGhpcy5tb3VzZWRvd24gPSBudWxsO1xuXHRcdHRoaXMubW91c2V1cCA9IG51bGw7XG5cdFx0dGhpcy5tb3VzZW1vdmUgPSBudWxsO1xuXHRcdHRoaXMubW91c2VvdmVyID0gbnVsbDtcblx0XHR0aGlzLm1vdXNlb3V0ID0gbnVsbDtcblx0XHR0aGlzLndoZWVsID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vdXNlSGFuZGxlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZGVmYXVsdFRvID0gcmVxdWlyZSgnbG9kYXNoL2RlZmF1bHRUbycpO1xuY29uc3QgUGFuQW5pbWF0aW9uID0gcmVxdWlyZSgnLi4vYW5pbWF0aW9uL1BhbkFuaW1hdGlvbicpO1xuY29uc3QgRXZlbnRUeXBlID0gcmVxdWlyZSgnLi4vLi4vZXZlbnQvRXZlbnRUeXBlJyk7XG5jb25zdCBFdmVudCA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50L0V2ZW50Jyk7XG5jb25zdCBET01IYW5kbGVyID0gcmVxdWlyZSgnLi9ET01IYW5kbGVyJyk7XG5cbi8vIENvbnN0YW50c1xuXG4vKipcbiAqIFRpbWUgaW4gbWlsbGlzZWNvbmRzIGJlZm9yZSBhIHBhbiBwb2ludCBleHBpcmVzLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7bnVtYmVyfVxuICovXG5jb25zdCBQQU5fRVhQSVJZX01TID0gNTA7XG5cbi8qKlxuICogUGFuIGluZXJ0aWEgZW5hYmxlZC5cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnQge2Jvb2xlYW59XG4gKi9cbmNvbnN0IFBBTl9JTlRFUlRJQSA9IHRydWU7XG5cbi8qKlxuICogUGFuIGluZXJ0aWEgZWFzaW5nLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7bnVtYmVyfVxuICovXG5jb25zdCBQQU5fSU5URVJUSUFfRUFTSU5HID0gMC4yO1xuXG4vKipcbiAqIFBhbiBpbmVydGlhIGRlY2VsZXJhdGlvbi5cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnQge251bWJlcn1cbiAqL1xuY29uc3QgUEFOX0lOVEVSVElBX0RFQ0VMRVJBVElPTiA9IDM0MDA7XG5cbi8qKlxuICogUGFuIHRvIGFuaW1hdGlvbiBkdXJhdGlvblxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7bnVtYmVyfVxuICovXG5jb25zdCBQQU5fVE9fRFVSQVRJT04gPSA4MDA7XG5cbi8vIFByaXZhdGUgTWV0aG9kc1xuXG5jb25zdCBwYW4gPSBmdW5jdGlvbihwbG90LCBkZWx0YSkge1xuXHRpZiAocGxvdC5pc1pvb21pbmcoKSkge1xuXHRcdC8vIG5vIHBhbm5pbmcgd2hpbGUgem9vbWluZ1xuXHRcdHJldHVybjtcblx0fVxuXHQvLyB1cGRhdGUgY3VycmVudCB2aWV3cG9ydFxuXHRwbG90LnZpZXdwb3J0LnggKz0gZGVsdGEueDtcblx0cGxvdC52aWV3cG9ydC55ICs9IGRlbHRhLnk7XG5cdC8vIHJlcXVlc3QgdGlsZXNcblx0cGxvdC5wYW5SZXF1ZXN0KCk7XG5cdC8vIGVtaXQgcGFuXG5cdHBsb3QuZW1pdChFdmVudFR5cGUuUEFOLCBuZXcgRXZlbnQocGxvdCkpO1xufTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBwYW4gaGFuZGxlci5cbiAqL1xuY2xhc3MgUGFuSGFuZGxlciBleHRlbmRzIERPTUhhbmRsZXIge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgUGFuSGFuZGxlciBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UGxvdH0gcGxvdCAtIFRoZSBwbG90IHRvIGF0dGFjaCB0aGUgaGFuZGxlciB0by5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcGFyYW1ldGVycyBvZiB0aGUgYW5pbWF0aW9uLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5pbmVydGlhIC0gV2hldGhlciBvciBub3QgcGFuIGluZXJ0aWEgaXMgZW5hYmxlZC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuaW5lcnRpYUVhc2luZyAtIFRoZSBpbmVydGlhIGVhc2luZyBmYWN0b3IuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmluZXJ0aWFEZWNlbGVyYXRpb24gLSBUaGUgaW5lcnRpYSBkZWNlbGVyYXRpb24gZmFjdG9yLlxuXHQgKi9cblx0Y29uc3RydWN0b3IocGxvdCwgb3B0aW9ucyA9IHt9KSB7XG5cdFx0c3VwZXIocGxvdCk7XG5cdFx0dGhpcy5pbmVydGlhID0gZGVmYXVsdFRvKG9wdGlvbnMuaW5lcnRpYSwgUEFOX0lOVEVSVElBKTtcblx0XHR0aGlzLmluZXJ0aWFFYXNpbmcgPSBkZWZhdWx0VG8ob3B0aW9ucy5pbmVydGlhRWFzaW5nLCBQQU5fSU5URVJUSUFfRUFTSU5HKTtcblx0XHR0aGlzLmluZXJ0aWFEZWNlbGVyYXRpb24gPSBkZWZhdWx0VG8ob3B0aW9ucy5pbmVydGlhRGVjZWxlcmF0aW9uLCBQQU5fSU5URVJUSUFfREVDRUxFUkFUSU9OKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmFibGVzIHRoZSBoYW5kbGVyLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UGFuSGFuZGxlcn0gVGhlIGhhbmRsZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRlbmFibGUoKSB7XG5cdFx0c3VwZXIuZW5hYmxlKCk7XG5cblx0XHRjb25zdCBwbG90ID0gdGhpcy5wbG90O1xuXG5cdFx0bGV0IGRvd24gPSBmYWxzZTtcblx0XHRsZXQgbGFzdFBvcyA9IG51bGw7XG5cdFx0bGV0IGxhc3RUaW1lID0gbnVsbDtcblx0XHRsZXQgcG9zaXRpb25zID0gW107XG5cdFx0bGV0IHRpbWVzID0gW107XG5cblx0XHR0aGlzLm1vdXNlZG93biA9IChldmVudCkgPT4ge1xuXHRcdFx0Ly8gaWdub3JlIGlmIHJpZ2h0LWJ1dHRvblxuXHRcdFx0aWYgKCF0aGlzLmlzTGVmdEJ1dHRvbihldmVudCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gZmxhZyBhcyBkb3duXG5cdFx0XHRkb3duID0gdHJ1ZTtcblx0XHRcdC8vIHNldCBwb3NpdGlvbiBhbmQgdGltZXN0YW1wXG5cdFx0XHRsYXN0UG9zID0gdGhpcy5tb3VzZVRvVmlld1B4KGV2ZW50KTtcblx0XHRcdGxhc3RUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRcdGlmICh0aGlzLmluZXJ0aWEpIHtcblx0XHRcdFx0Ly8gY2xlYXIgZXhpc3RpbmcgcGFuIGFuaW1hdGlvblxuXHRcdFx0XHRwbG90LnBhbkFuaW1hdGlvbiA9IG51bGw7XG5cdFx0XHRcdC8vIHJlc2V0IHBvc2l0aW9uIGFuZCB0aW1lIGFycmF5c1xuXHRcdFx0XHRwb3NpdGlvbnMgPSBbXTtcblx0XHRcdFx0dGltZXMgPSBbXTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhpcy5tb3VzZW1vdmUgPSAoZXZlbnQpID0+IHtcblx0XHRcdGlmIChkb3duKSB7XG5cdFx0XHRcdC8vIGdldCBsYXRlc3QgcG9zaXRpb24gYW5kIHRpbWVzdGFtcFxuXHRcdFx0XHRsZXQgcG9zID0gdGhpcy5tb3VzZVRvVmlld1B4KGV2ZW50KTtcblx0XHRcdFx0bGV0IHRpbWUgPSBEYXRlLm5vdygpO1xuXG5cdFx0XHRcdGlmIChwb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0Ly8gZW1pdCBwYW4gc3RhcnRcblx0XHRcdFx0XHRwbG90LmVtaXQoRXZlbnRUeXBlLlBBTl9TVEFSVCwgbmV3IEV2ZW50KHBsb3QpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLmluZXJ0aWEpIHtcblx0XHRcdFx0XHQvLyBhZGQgdG8gcG9zaXRpb24gYW5kIHRpbWUgYXJyYXlzXG5cdFx0XHRcdFx0cG9zaXRpb25zLnB1c2gocG9zKTtcblx0XHRcdFx0XHR0aW1lcy5wdXNoKHRpbWUpO1xuXHRcdFx0XHRcdC8vIHByZXZlbnQgYXJyYXkgZnJvbSBnZXR0aW5nIHRvbyBiaWdcblx0XHRcdFx0XHRpZiAodGltZSAtIHRpbWVzWzBdID4gUEFOX0VYUElSWV9NUykge1xuXHRcdFx0XHRcdFx0cG9zaXRpb25zLnNoaWZ0KCk7XG5cdFx0XHRcdFx0XHR0aW1lcy5zaGlmdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb25hbCBkZWx0YVxuXHRcdFx0XHRjb25zdCBkZWx0YSA9IHtcblx0XHRcdFx0XHR4OiBsYXN0UG9zLnggLSBwb3MueCxcblx0XHRcdFx0XHR5OiBsYXN0UG9zLnkgLSBwb3MueVxuXHRcdFx0XHR9O1xuXHRcdFx0XHQvLyBwYW4gdGhlIHBsb3Rcblx0XHRcdFx0cGFuKHBsb3QsIHRoaXMudmlld1B4VG9QbG90KGRlbHRhKSk7XG5cdFx0XHRcdC8vIHVwZGF0ZSBsYXN0IHBvc2l0aW9uIGFuZCB0aW1lXG5cdFx0XHRcdGxhc3RUaW1lID0gdGltZTtcblx0XHRcdFx0bGFzdFBvcyA9IHBvcztcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhpcy5tb3VzZXVwID0gKGV2ZW50KSA9PiB7XG5cblx0XHRcdC8vIGZsYWcgYXMgdXBcblx0XHRcdGRvd24gPSBmYWxzZTtcblxuXHRcdFx0aWYgKHBsb3QuaXNab29taW5nKCkpIHtcblx0XHRcdFx0Ly8gbm8gcGFubmluZyB3aGlsZSB6b29taW5nXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaWdub3JlIGlmIHJpZ2h0LWJ1dHRvblxuXHRcdFx0aWYgKCF0aGlzLmlzTGVmdEJ1dHRvbihldmVudCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBpZ25vcmUgaWYgbm8gZHJhZyBvY2N1cnJlZFxuXHRcdFx0aWYgKHBvc2l0aW9ucy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMuaW5lcnRpYSkge1xuXHRcdFx0XHQvLyBleGl0IGVhcmx5IGlmIG5vIGluZXJ0aWEgb3Igbm8gbW92ZW1lbnRcblx0XHRcdFx0cGxvdC5lbWl0KEV2ZW50VHlwZS5QQU5fRU5ELCBuZXcgRXZlbnQocGxvdCkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIGdldCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IHRpbWUgPSBEYXRlLm5vdygpO1xuXG5cdFx0XHQvLyBzdHJpcCBhbnkgcG9zaXRpb25zIHRoYXQgYXJlIHRvbyBvbGRcblx0XHRcdHdoaWxlICh0aW1lIC0gdGltZXNbMF0gPiBQQU5fRVhQSVJZX01TKSB7XG5cdFx0XHRcdHBvc2l0aW9ucy5zaGlmdCgpO1xuXHRcdFx0XHR0aW1lcy5zaGlmdCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGltZXMubGVuZ3RoIDwgMikge1xuXHRcdFx0XHQvLyBleGl0IGVhcmx5IGlmIG5vIHJlbWFpbmluZyB2YWxpZCBwb3NpdGlvbnNcblx0XHRcdFx0cGxvdC5lbWl0KEV2ZW50VHlwZS5QQU5fRU5ELCBuZXcgRXZlbnQocGxvdCkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNob3J0aGFuZFxuXHRcdFx0Y29uc3QgZGVjZWxlcmF0aW9uID0gdGhpcy5pbmVydGlhRGVjZWxlcmF0aW9uO1xuXHRcdFx0Y29uc3QgZWFzaW5nID0gdGhpcy5pbmVydGlhRWFzaW5nO1xuXG5cdFx0XHQvLyBjYWxjdWxhdGUgZGlyZWN0aW9uIGZyb20gZWFybGllc3QgdG8gbGF0ZXN0XG5cdFx0XHRjb25zdCBkaXJlY3Rpb24gPSB7XG5cdFx0XHRcdHg6IGxhc3RQb3MueCAtIHBvc2l0aW9uc1swXS54LFxuXHRcdFx0XHR5OiBsYXN0UG9zLnkgLSBwb3NpdGlvbnNbMF0ueVxuXHRcdFx0fTtcblx0XHRcdC8vIGNhbGN1bGF0ZSB0aGUgdGltZSBkaWZmZXJlbmNlXG5cdFx0XHRjb25zdCBkaWZmID0gKChsYXN0VGltZSAtIHRpbWVzWzBdKSB8fCAxKSAvIDEwMDA7IC8vIG1zIHRvIHNcblx0XHRcdC8vIGNhbGN1bGF0ZSB2ZWxvY2l0eVxuXHRcdFx0Y29uc3QgdmVsb2NpdHkgPSB7XG5cdFx0XHRcdHg6IGRpcmVjdGlvbi54ICogKGVhc2luZyAvIGRpZmYpLFxuXHRcdFx0XHR5OiBkaXJlY3Rpb24ueSAqIChlYXNpbmcgLyBkaWZmKVxuXHRcdFx0fTtcblx0XHRcdC8vIGNhbGN1bGF0ZSBzcGVlZFxuXHRcdFx0Y29uc3Qgc3BlZWQgPSBNYXRoLnNxcnQoXG5cdFx0XHRcdCh2ZWxvY2l0eS54ICogdmVsb2NpdHkueCkgK1xuXHRcdFx0XHQodmVsb2NpdHkueSAqIHZlbG9jaXR5LnkpKTtcblx0XHRcdC8vIGNhbGN1bGF0ZSBwYW5uaW5nIGR1cmF0aW9uXG5cdFx0XHRjb25zdCBkdXJhdGlvbiA9IHNwZWVkIC8gKGRlY2VsZXJhdGlvbiAqIGVhc2luZyk7XG5cdFx0XHQvLyBjYWxjdWxhdGUgaW5lcnRpYSBkZWx0YVxuXHRcdFx0Y29uc3QgZGVsdGEgPSB7XG5cdFx0XHRcdHg6IE1hdGgucm91bmQodmVsb2NpdHkueCAqICgtZHVyYXRpb24gLyAyKSksXG5cdFx0XHRcdHk6IE1hdGgucm91bmQodmVsb2NpdHkueSAqICgtZHVyYXRpb24gLyAyKSlcblx0XHRcdH07XG5cdFx0XHQvLyBzZXQgcGFuIGFuaW1hdGlvblxuXHRcdFx0cGxvdC5wYW5BbmltYXRpb24gPSBuZXcgUGFuQW5pbWF0aW9uKHtcblx0XHRcdFx0cGxvdDogcGxvdCxcblx0XHRcdFx0c3RhcnQ6IHBsb3QuZ2V0Vmlld3BvcnRQb3NpdGlvbigpLFxuXHRcdFx0XHRkZWx0YTogdGhpcy52aWV3UHhUb1Bsb3QoZGVsdGEpLFxuXHRcdFx0XHRlYXNpbmc6IGVhc2luZyxcblx0XHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uICogMTAwMCAvLyBzIHRvIG1zXG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0Y29uc3QgY29udGFpbmVyID0gcGxvdC5nZXRDb250YWluZXIoKTtcblx0XHRjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZWRvd24pO1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2Vtb3ZlKTtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5tb3VzZXVwKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNhYmxlcyB0aGUgaGFuZGxlci5cblx0ICpcblx0ICogQHJldHVybnMge1BhbkhhbmRsZXJ9IFRoZSBoYW5kbGVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0ZGlzYWJsZSgpIHtcblx0XHRzdXBlci5kaXNhYmxlKCk7XG5cblx0XHRjb25zdCBjb250YWluZXIgPSB0aGlzLnBsb3QuZ2V0Q29udGFpbmVyKCk7XG5cdFx0Y29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2Vkb3duKTtcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm1vdXNlbW92ZSk7XG5cdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMubW91c2V1cCk7XG5cdFx0dGhpcy5tb3VzZWRvd24gPSBudWxsO1xuXHRcdHRoaXMubW91c2Vtb3ZlID0gbnVsbDtcblx0XHR0aGlzLm1vdXNldXAgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhbnMgdG8gdGhlIHRhcmdldCBwbG90IGNvb3JkaW5hdGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgLSBUaGUgdGFyZ2V0IHBsb3QgcG9zaXRpb24uXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gYW5pbWF0ZSAtIFdoZXRoZXIgb3Igbm90IHRvIGFuaW1hdGUgdGhlIHBhbi4gRGVmYXVsdHMgdG8gYHRydWVgLlxuXHQgKi9cblx0cGFuVG8ocG9zLCBhbmltYXRlID0gdHJ1ZSkge1xuXHRcdGNvbnN0IHBsb3QgPSB0aGlzLnBsb3Q7XG5cdFx0Y29uc3QgY2VudGVyID0gcGxvdC5nZXRWaWV3cG9ydENlbnRlcigpO1xuXHRcdGNvbnN0IGRlbHRhID0ge1xuXHRcdFx0eDogcG9zLnggLSBjZW50ZXIueCxcblx0XHRcdHk6IHBvcy55IC0gY2VudGVyLnlcblx0XHR9O1xuXHRcdGlmICghYW5pbWF0ZSkge1xuXHRcdFx0Ly8gZG8gbm90IGFuaW1hdGVcblx0XHRcdHBsb3QuZW1pdChFdmVudFR5cGUuUEFOX1NUQVJULCBuZXcgRXZlbnQocGxvdCkpO1xuXHRcdFx0cGFuKHBsb3QsIGRlbHRhKTtcblx0XHRcdHBsb3QuZW1pdChFdmVudFR5cGUuUEFOX0VORCwgbmV3IEV2ZW50KHBsb3QpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gYW5pbWF0ZSBwYW5cblx0XHRcdHBsb3QuZW1pdChFdmVudFR5cGUuUEFOX1NUQVJULCBuZXcgRXZlbnQocGxvdCkpO1xuXHRcdFx0cGxvdC5wYW5BbmltYXRpb24gPSBuZXcgUGFuQW5pbWF0aW9uKHtcblx0XHRcdFx0cGxvdDogcGxvdCxcblx0XHRcdFx0c3RhcnQ6IHBsb3QuZ2V0Vmlld3BvcnRQb3NpdGlvbigpLFxuXHRcdFx0XHRkZWx0YTogZGVsdGEsXG5cdFx0XHRcdGVhc2luZzogdGhpcy5pbmVydGlhRWFzaW5nLFxuXHRcdFx0XHRkdXJhdGlvbjogUEFOX1RPX0RVUkFUSU9OXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYW5IYW5kbGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjbGFtcCA9IHJlcXVpcmUoJ2xvZGFzaC9jbGFtcCcpO1xuY29uc3QgZGVmYXVsdFRvID0gcmVxdWlyZSgnbG9kYXNoL2RlZmF1bHRUbycpO1xuY29uc3QgQnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvQnJvd3NlcicpO1xuY29uc3QgRXZlbnRUeXBlID0gcmVxdWlyZSgnLi4vLi4vZXZlbnQvRXZlbnRUeXBlJyk7XG5jb25zdCBFdmVudCA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50L0V2ZW50Jyk7XG5jb25zdCBab29tQW5pbWF0aW9uID0gcmVxdWlyZSgnLi4vYW5pbWF0aW9uL1pvb21BbmltYXRpb24nKTtcbmNvbnN0IFZpZXdwb3J0ID0gcmVxdWlyZSgnLi4vVmlld3BvcnQnKTtcbmNvbnN0IERPTUhhbmRsZXIgPSByZXF1aXJlKCcuL0RPTUhhbmRsZXInKTtcblxuLy8gQ29uc3RhbnRzXG5cbi8qKlxuICogQW1vdW50IG9mIHNjcm9sbCBwaXhlbHMgcGVyIHpvb20gbGV2ZWwuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50IHtudW1iZXJ9XG4gKi9cbmNvbnN0IFpPT01fV0hFRUxfREVMVEEgPSAzMDA7XG5cbi8qKlxuICogTGVuZ3RoIG9mIHpvb20gYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnQge251bWJlcn1cbiAqL1xuY29uc3QgWk9PTV9BTklNQVRJT05fTVMgPSAyNTA7XG5cbi8qKlxuICogTWF4aW11bSBjb25jdXJyZW50IGRpc2NyZXRlIHpvb21zIGluIGEgc2luZ2xlIGJhdGNoLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7bnVtYmVyfVxuICovXG5jb25zdCBNQVhfQ09OQ1VSUkVOVF9aT09NUyA9IDQ7XG5cbi8qKlxuICogWm9vbSBkZWJvdW5jZSBkZWxheSBpbiBtaWxpc2Vjb25kcy5cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnQge251bWJlcn1cbiAqL1xuY29uc3QgWk9PTV9ERUJPVU5DRV9NUyA9IDEwMDtcblxuLyoqXG4gKiBDb250aW51b3VzIHpvb20gZW5hYmxlZC5cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnQge2Jvb2xlYW59XG4gKi9cbmNvbnN0IENPTlRJTlVPVVNfWk9PTSA9IGZhbHNlO1xuXG4vLyBQcml2YXRlIE1ldGhvZHNcblxubGV0IGxhc3QgPSBEYXRlLm5vdygpO1xuY29uc3Qgc2tpcEludGVycG9sYXRpb24gPSBmdW5jdGlvbihhbmltYXRpb24sIGRlbHRhKSB7XG5cdC8vIE5PVEU6IGF0dGVtcHQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBzY3JvbGwgZGV2aWNlIGlzIGEgbW91c2Ugb3IgYVxuXHQvLyB0cmFja3BhZC4gTW91c2Ugc2Nyb2xsaW5nIGNyZWF0ZXMgbGFyZ2UgaW5mcmVxdWVudCBkZWx0YXMgd2hpbGVcblx0Ly8gdHJhY2twYWRzIGNyZWF0ZSB0b25zIG9mIHZlcnkgc21hbGwgZGVsdGFzLiBXZSB3YW50IHRvIGludGVycG9sYXRlXG5cdC8vIGJldHdlZW4gd2hlZWwgZXZlbnRzLCBidXQgbm90IGJldHdlZW4gdHJhY2twYWQgZXZlbnRzLlxuXHRjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXHRjb25zdCB0ZGVsdGEgPSBub3cgLSBsYXN0O1xuXHRsYXN0ID0gbm93O1xuXHRpZiAoZGVsdGEgJSA0LjAwMDI0NDE0MDYyNSA9PT0gMCkge1xuXHRcdC8vIGRlZmluaXRlbHkgYSB3aGVlbCwgaW50ZXJwb2xhdGVcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKE1hdGguYWJzKGRlbHRhKSA8IDQpIHtcblx0XHQvLyBkZWZpbml0ZWx5IHRyYWNrIHBhZCwgZG8gbm90IGludGVycG9sYXRlXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKGFuaW1hdGlvbiAmJiBhbmltYXRpb24uZHVyYXRpb24gIT09IDApIHtcblx0XHQvLyBjdXJyZW50IGFuaW1hdGlvbiBoYXMgaW50ZXJwb2xhdGlvbiwgc2hvdWxkIHByb2JhYmx5IGludGVycG9sYXRlXG5cdFx0Ly8gdGhlIG5leHQgYW5pbWF0aW9uIHRvby5cblx0XHQvLyBOT1RFOiB3aXRob3V0IHRoaXMsIHJhcGlkIHdoZWVsIHNjcm9sbGluZyB3aWxsIHRyaWdnZXIgdGhlIHNraXBcblx0XHQvLyBiZWxvd1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRpZiAodGRlbHRhIDwgNDApIHtcblx0XHQvLyBldmVudHMgYXJlIGNsb3NlIGVub3VnaCB0b2dldGhlciB0aGF0IHdlIHNob3VsZCBwcm9iYWJseVxuXHRcdC8vIG5vdCBpbnRlcnBvbGF0ZVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IGNvbXB1dGVab29tRGVsdGEgPSBmdW5jdGlvbih3aGVlbERlbHRhLCBjb250aW51b3VzWm9vbSwgZGVsdGFQZXJab29tLCBtYXhab29tcykge1xuXHRsZXQgem9vbURlbHRhID0gd2hlZWxEZWx0YSAvIGRlbHRhUGVyWm9vbTtcblx0aWYgKCFjb250aW51b3VzWm9vbSkge1xuXHRcdC8vIHNuYXAgdmFsdWUgaWYgbm90IGNvbnRpbnVvdXMgem9vbVxuXHRcdGlmICh3aGVlbERlbHRhID4gMCkge1xuXHRcdFx0em9vbURlbHRhID0gTWF0aC5jZWlsKHpvb21EZWx0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHpvb21EZWx0YSA9IE1hdGguZmxvb3Ioem9vbURlbHRhKTtcblx0XHR9XG5cdH1cblx0Ly8gY2xhbXAgem9vbSBkZWx0YSB0byBtYXggY29uY3VycmVudCB6b29tc1xuXHRyZXR1cm4gY2xhbXAoem9vbURlbHRhLCAtbWF4Wm9vbXMsIG1heFpvb21zKTtcbn07XG5cbmNvbnN0IGNvbXB1dGVUYXJnZXRab29tID0gZnVuY3Rpb24oem9vbURlbHRhLCBjdXJyZW50Wm9vbSwgY3VycmVudEFuaW1hdGlvbiwgbWluWm9vbSwgbWF4Wm9vbSkge1xuXHRsZXQgdGFyZ2V0Wm9vbTtcblx0aWYgKGN1cnJlbnRBbmltYXRpb24pIHtcblx0XHQvLyBhcHBlbmQgdG8gZXhpc3RpbmcgYW5pbWF0aW9uIHRhcmdldFxuXHRcdHRhcmdldFpvb20gPSBjdXJyZW50QW5pbWF0aW9uLnRhcmdldFpvb20gKyB6b29tRGVsdGE7XG5cdH0gZWxzZSB7XG5cdFx0dGFyZ2V0Wm9vbSA9IGN1cnJlbnRab29tICsgem9vbURlbHRhO1xuXHR9XG5cdC8vIGNsYW1wIHRoZSB0YXJnZXQgem9vbSB0byBtaW4gYW5kIG1heCB6b29tIGxldmVsIG9mIHBsb3Rcblx0cmV0dXJuIGNsYW1wKHRhcmdldFpvb20sIG1pblpvb20sIG1heFpvb20pO1xufTtcblxuY29uc3Qgem9vbSA9IGZ1bmN0aW9uKHBsb3QsIHRhcmdldFBvcywgem9vbURlbHRhLCBkdXJhdGlvbikge1xuXHQvLyBjYWxjdWxhdGUgdGFyZ2V0IHpvb20gbGV2ZWxcblx0Y29uc3QgdGFyZ2V0Wm9vbSA9IGNvbXB1dGVUYXJnZXRab29tKFxuXHRcdHpvb21EZWx0YSxcblx0XHRwbG90Lnpvb20sXG5cdFx0cGxvdC56b29tQW5pbWF0aW9uLFxuXHRcdHBsb3QubWluWm9vbSxcblx0XHRwbG90Lm1heFpvb20pO1xuXHQvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHpvb21cblx0aWYgKHRhcmdldFpvb20gIT09IHBsb3QuZ2V0VGFyZ2V0Wm9vbSgpKSB7XG5cdFx0Ly8gc2V0IHRhcmdldCB2aWV3cG9ydFxuXHRcdGNvbnN0IHRhcmdldFZpZXdwb3J0ID0gcGxvdC52aWV3cG9ydC56b29tVG9Qb3MoXG5cdFx0XHRwbG90Lnpvb20sXG5cdFx0XHR0YXJnZXRab29tLFxuXHRcdFx0dGFyZ2V0UG9zKTtcblx0XHQvLyBjbGVhciBwYW4gYW5pbWF0aW9uXG5cdFx0cGxvdC5wYW5BbmltYXRpb24gPSBudWxsO1xuXHRcdC8vIGlmIHRoZXJlIGlzIGEgZHVyYXRpb25cblx0XHRpZiAoZHVyYXRpb24gPiAwKSB7XG5cdFx0XHQvLyBzZXQgem9vbSBhbmltYXRpb25cblx0XHRcdHBsb3Quem9vbUFuaW1hdGlvbiA9IG5ldyBab29tQW5pbWF0aW9uKHtcblx0XHRcdFx0cGxvdDogcGxvdCxcblx0XHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uLFxuXHRcdFx0XHRwcmV2Wm9vbTogcGxvdC56b29tLFxuXHRcdFx0XHR0YXJnZXRab29tOiB0YXJnZXRab29tLFxuXHRcdFx0XHRwcmV2Vmlld3BvcnQ6IG5ldyBWaWV3cG9ydChcblx0XHRcdFx0XHRwbG90LnZpZXdwb3J0LngsXG5cdFx0XHRcdFx0cGxvdC52aWV3cG9ydC55LFxuXHRcdFx0XHRcdHBsb3Qudmlld3BvcnQud2lkdGgsXG5cdFx0XHRcdFx0cGxvdC52aWV3cG9ydC5oZWlnaHQpLFxuXHRcdFx0XHR0YXJnZXRWaWV3cG9ydDogdGFyZ2V0Vmlld3BvcnQsXG5cdFx0XHRcdHRhcmdldFBvczogdGFyZ2V0UG9zXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0Ly8gZW1pdCB6b29tIHN0YXJ0XG5cdFx0cGxvdC5lbWl0KEV2ZW50VHlwZS5aT09NX1NUQVJULCBuZXcgRXZlbnQocGxvdCkpO1xuXHRcdC8vIGlmIHRoZXJlIGlzbid0IGEgZHVyYXRpb25cblx0XHRpZiAoZHVyYXRpb24gPT09IDApIHtcblx0XHRcdC8vIGltbWVkaWF0ZWx5IHVwZGF0ZSBwbG90XG5cdFx0XHRwbG90Lnpvb20gPSB0YXJnZXRab29tO1xuXHRcdFx0cGxvdC52aWV3cG9ydCA9IHRhcmdldFZpZXdwb3J0O1xuXHRcdFx0Ly8gZW1pdCB6b29tIGVuZFxuXHRcdFx0cGxvdC5lbWl0KEV2ZW50VHlwZS5aT09NX0VORCwgIG5ldyBFdmVudChwbG90KSk7XG5cdFx0fVxuXHRcdC8vIHJlcXVlc3QgdGlsZXNcblx0XHRwbG90Lnpvb21SZXF1ZXN0KCk7XG5cdH1cbn07XG5cbmNvbnN0IHpvb21Gcm9tV2hlZWwgPSBmdW5jdGlvbihoYW5kbGVyLCBwbG90LCB0YXJnZXRQb3MsIHdoZWVsRGVsdGEsIGNvbnRpbnVvdXNab29tKSB7XG5cdC8vIG5vIHdoZWVsIGRlbHRhLCBleGl0IGVhcmx5XG5cdGlmICh3aGVlbERlbHRhID09PSAwKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdC8vIGNhbGN1bGF0ZSB6b29tIGRlbHRhIGZyb20gd2hlZWwgZGVsdGFcblx0Y29uc3Qgem9vbURlbHRhID0gY29tcHV0ZVpvb21EZWx0YShcblx0XHR3aGVlbERlbHRhLFxuXHRcdGNvbnRpbnVvdXNab29tLFxuXHRcdGhhbmRsZXIuZGVsdGFQZXJab29tLFxuXHRcdGhhbmRsZXIubWF4Q29uY3VycmVudFpvb21zKTtcblx0Ly8gZ2V0IGR1cmF0aW9uXG5cdGxldCBkdXJhdGlvbiA9IGhhbmRsZXIuem9vbUR1cmF0aW9uO1xuXHRpZiAoY29udGludW91c1pvb20gJiYgc2tpcEludGVycG9sYXRpb24ocGxvdC56b29tQW5pbWF0aW9uLCB3aGVlbERlbHRhKSkge1xuXHRcdC8vIHNraXAgYW5pbWF0aW9uIGludGVycG9sYXRpb25cblx0XHRkdXJhdGlvbiA9IDA7XG5cdH1cblx0Ly8gcHJvY2VzcyB0aGUgem9vbVxuXHR6b29tKHBsb3QsIHRhcmdldFBvcywgem9vbURlbHRhLCBkdXJhdGlvbik7XG59O1xuXG5jb25zdCBnZXRXaGVlbERlbHRhID0gZnVuY3Rpb24ocGxvdCwgZXZlbnQpIHtcblx0aWYgKGV2ZW50LmRlbHRhTW9kZSA9PT0gMCkge1xuXHRcdC8vIHBpeGVsc1xuXHRcdGlmIChCcm93c2VyLmZpcmVmb3gpIHtcblx0XHRcdHJldHVybiAtZXZlbnQuZGVsdGFZIC8gcGxvdC5waXhlbFJhdGlvO1xuXHRcdH1cblx0XHRyZXR1cm4gLWV2ZW50LmRlbHRhWTtcblx0fSBlbHNlIGlmIChldmVudC5kZWx0YU1vZGUgPT09IDEpIHtcblx0XHQvLyBsaW5lc1xuXHRcdHJldHVybiAtZXZlbnQuZGVsdGFZICogMjA7XG5cdH1cblx0Ly8gcGFnZXNcblx0cmV0dXJuIC1ldmVudC5kZWx0YVkgKiA2MDtcbn07XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgem9vbSBoYW5kbGVyLlxuICovXG5jbGFzcyBab29tSGFuZGxlciBleHRlbmRzIERPTUhhbmRsZXIge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgWm9vbUhhbmRsZXIgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1Bsb3R9IHBsb3QgLSBUaGUgcGxvdCB0byBhdHRhY2ggdGhlIGhhbmRsZXIgdG8uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHBhcmFtZXRlcnMgb2YgdGhlIGFuaW1hdGlvbi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY29udGludW91c1pvb20gLSBXaGV0aGVyIG9yIG5vdCBjb250aW51b3VzIHpvb20gaXMgZW5hYmxlZC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuem9vbUR1cmF0aW9uIC0gVGhlIGR1cmF0aW9uIG9mIHRoZSB6b29tIGFuaW1hdGlvbi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubWF4Q29uY3VycmVudFpvb21zIC0gVGhlIG1heGltdW0gY29uY3VycmVudCB6b29tcyBpbiBhIHNpbmdsZSBiYXRjaC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuZGVsdGFQZXJab29tIC0gVGhlIHNjcm9sbCBkZWx0YSByZXF1aXJlZCBwZXIgem9vbSBsZXZlbC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuem9vbURlYm91bmNlIC0gVGhlIGRlYm91bmNlIGR1cmF0aW9uIG9mIHRoZSB6b29tIGluIG1zLlxuXHQgKi9cblx0Y29uc3RydWN0b3IocGxvdCwgb3B0aW9ucyA9IHt9KSB7XG5cdFx0c3VwZXIocGxvdCk7XG5cdFx0dGhpcy5jb250aW51b3VzWm9vbSA9IGRlZmF1bHRUbyhvcHRpb25zLmNvbnRpbnVvdXNab29tLCBDT05USU5VT1VTX1pPT00pO1xuXHRcdHRoaXMuem9vbUR1cmF0aW9uID0gZGVmYXVsdFRvKG9wdGlvbnMuem9vbUR1cmF0aW9uLCBaT09NX0FOSU1BVElPTl9NUyk7XG5cdFx0dGhpcy5tYXhDb25jdXJyZW50Wm9vbXMgPSBkZWZhdWx0VG8ob3B0aW9ucy5tYXhDb25jdXJyZW50Wm9vbXMsIE1BWF9DT05DVVJSRU5UX1pPT01TKTtcblx0XHR0aGlzLmRlbHRhUGVyWm9vbSA9IGRlZmF1bHRUbyhvcHRpb25zLmRlbHRhUGVyWm9vbSwgWk9PTV9XSEVFTF9ERUxUQSk7XG5cdFx0dGhpcy56b29tRGVib3VuY2UgPSBkZWZhdWx0VG8ob3B0aW9ucy56b29tRGVib3VuY2UsIFpPT01fREVCT1VOQ0VfTVMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgdGhlIGhhbmRsZXIuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtab29tSGFuZGxlcn0gVGhlIGhhbmRsZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRlbmFibGUoKSB7XG5cdFx0c3VwZXIuZW5hYmxlKCk7XG5cblx0XHRjb25zdCBwbG90ID0gdGhpcy5wbG90O1xuXG5cdFx0bGV0IHdoZWVsRGVsdGEgPSAwO1xuXHRcdGxldCB0aW1lb3V0ID0gbnVsbDtcblx0XHRsZXQgZXZ0ID0gbnVsbDtcblxuXHRcdHRoaXMuZGJsY2xpY2sgPSAoZXZlbnQpID0+IHtcblx0XHRcdC8vIGdldCBtb3VzZSBwb3NpdGlvblxuXHRcdFx0Y29uc3QgdGFyZ2V0UG9zID0gdGhpcy5tb3VzZVRvUGxvdChldmVudCk7XG5cdFx0XHQvLyB6b29tIHRoZSBwbG90IGJ5IG9uZSBsZXZlbFxuXHRcdFx0em9vbShwbG90LCB0YXJnZXRQb3MsIDEsIHRoaXMuem9vbUR1cmF0aW9uKTtcblx0XHR9O1xuXG5cdFx0dGhpcy53aGVlbCA9IChldmVudCkgPT4ge1xuXHRcdFx0Ly8gZ2V0IG5vcm1hbGl6ZWQgZGVsdGFcblx0XHRcdGNvbnN0IGRlbHRhID0gZ2V0V2hlZWxEZWx0YShwbG90LCBldmVudCk7XG5cdFx0XHRpZiAoIXRoaXMuY29udGludW91c1pvb20gJiYgTWF0aC5hYnMoZGVsdGEpIDwgNCkge1xuXHRcdFx0XHQvLyBtaXRpZ2F0ZSB0aGUgaHlwZXIgc2Vuc2l0aXZ0eSBvZiBhIHRyYWNrcGFkXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIGluY3JlbWVudCB3aGVlbCBkZWx0YVxuXHRcdFx0d2hlZWxEZWx0YSArPSBkZWx0YTtcblx0XHRcdC8vIGNoZWNrIHpvb20gdHlwZVxuXHRcdFx0aWYgKHRoaXMuY29udGludW91c1pvb20pIHtcblx0XHRcdFx0Ly8gZ2V0IHRhcmdldCBmcm9tIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdGNvbnN0IHRhcmdldFBvcyA9IHRoaXMubW91c2VUb1Bsb3QoZXZlbnQpO1xuXHRcdFx0XHQvLyBwcm9jZXNzIGNvbnRpbnVvdXMgem9vbSBpbW1lZGlhdGVseVxuXHRcdFx0XHR6b29tRnJvbVdoZWVsKHRoaXMsIHBsb3QsIHRhcmdldFBvcywgd2hlZWxEZWx0YSwgdHJ1ZSk7XG5cdFx0XHRcdC8vIHJlc2V0IHdoZWVsIGRlbHRhXG5cdFx0XHRcdHdoZWVsRGVsdGEgPSAwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gc2V0IGV2ZW50XG5cdFx0XHRcdGV2dCA9IGV2ZW50O1xuXHRcdFx0XHQvLyBkZWJvdW5jZSBkaXNjcmV0ZSB6b29tXG5cdFx0XHRcdGlmICghdGltZW91dCkge1xuXHRcdFx0XHRcdHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0XHRcdC8vIGdldCB0YXJnZXQgcG9zaXRpb24gZnJvbSBtb3VzZSBwb3NpdGlvblxuXHRcdFx0XHRcdFx0Ly8gTk9URTogdGhpcyBpcyBjYWxsZWQgaW5zaWRlIHRoZSBjbG9zdXJlIHRvIGVuc3VyZVxuXHRcdFx0XHRcdFx0Ly8gdGhhdCB3ZSB1c2UgdGhlIGN1cnJlbnQgdmlld3BvcnQgb2YgdGhlIHBsb3QgdG9cblx0XHRcdFx0XHRcdC8vIGNvbnZlcnQgZnJvbSBtb3VzZSB0byBwbG90IHBpeGVsc1xuXHRcdFx0XHRcdFx0Y29uc3QgdGFyZ2V0UG9zID0gdGhpcy5tb3VzZVRvUGxvdChldnQpO1xuXHRcdFx0XHRcdFx0Ly8gcHJvY2VzcyB6b29tIGV2ZW50XG5cdFx0XHRcdFx0XHR6b29tRnJvbVdoZWVsKHRoaXMsIHBsb3QsIHRhcmdldFBvcywgd2hlZWxEZWx0YSwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0Ly8gcmVzZXQgd2hlZWwgZGVsdGFcblx0XHRcdFx0XHRcdHdoZWVsRGVsdGEgPSAwO1xuXHRcdFx0XHRcdFx0Ly8gY2xlYXIgdGltZW91dFxuXHRcdFx0XHRcdFx0dGltZW91dCA9IG51bGw7XG5cdFx0XHRcdFx0XHQvLyBjbGVhciBldmVudFxuXHRcdFx0XHRcdFx0ZXZ0ID0gbnVsbDtcblx0XHRcdFx0XHR9LCB0aGlzLnpvb21EZWJvdW5jZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIHByZXZlbnQgZGVmYXVsdCBiZWhhdmlvciBhbmQgc3RvcCBwcm9wYWdhdGlvbmFcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9O1xuXG5cdFx0Y29uc3QgY29udGFpbmVyID0gcGxvdC5nZXRDb250YWluZXIoKTtcblx0XHRjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCB0aGlzLmRibGNsaWNrKTtcblx0XHRjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLndoZWVsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNhYmxlcyB0aGUgaGFuZGxlci5cblx0ICpcblx0ICogQHJldHVybnMge1pvb21IYW5kbGVyfSBUaGUgaGFuZGxlciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdGRpc2FibGUoKSB7XG5cdFx0c3VwZXIuZGlzYWJsZSgpO1xuXG5cdFx0Y29uc3QgY29udGFpbmVyID0gdGhpcy5wbG90LmdldENvbnRhaW5lcigpO1xuXHRcdGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIHRoaXMuZGJsY2xpY2spO1xuXHRcdGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMud2hlZWwpO1xuXHRcdHRoaXMuZGJsY2xpY2sgPSBudWxsO1xuXHRcdHRoaXMud2hlZWwgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFpvb21zIGluIHRvIHRoZSB0YXJnZXQgem9vbSBsZXZlbC4gVGhpcyBpcyBib3VuZGVkIGJ5IHRoZSBwbG90IG9iamVjdHNcblx0ICogbWluWm9vbSBhbmQgbWF4Wm9vbSBhdHRyaWJ1dGVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWwgLSBUaGUgdGFyZ2V0IHpvb20gbGV2ZWwuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gYW5pbWF0ZSAtIFdoZXRoZXIgb3Igbm90IHRvIGFuaW1hdGUgdGhlIHpvb20uIERlZmF1bHRzIHRvIGB0cnVlYC5cblx0ICovXG5cdHpvb21UbyhsZXZlbCwgYW5pbWF0ZSA9IHRydWUpIHtcblx0XHRjb25zdCBwbG90ID0gdGhpcy5wbG90O1xuXHRcdGNvbnN0IHRhcmdldFBvcyA9IHRoaXMucGxvdC5nZXRWaWV3cG9ydENlbnRlcigpO1xuXHRcdGNvbnN0IHpvb21EZWx0YSA9IGxldmVsIC0gcGxvdC56b29tO1xuXHRcdGlmICghYW5pbWF0ZSkge1xuXHRcdFx0Ly8gZG8gbm90IGFuaW1hdGVcblx0XHRcdHpvb20ocGxvdCwgdGFyZ2V0UG9zLCB6b29tRGVsdGEsIDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBhbmltYXRlXG5cdFx0XHR6b29tKHBsb3QsIHRhcmdldFBvcywgem9vbURlbHRhLCB0aGlzLnpvb21EdXJhdGlvbik7XG5cdFx0fVxuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWm9vbUhhbmRsZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHJlbmRlcmVyLlxuICovXG5jbGFzcyBSZW5kZXJlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBSZW5kZXJlciBvYmplY3QuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4ZWN1dGVkIHdoZW4gdGhlIHRhcmdldCBpcyBhdHRhY2hlZCB0byBhIHBsb3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7dGFyZ2V0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHRvIGF0dGFjaCB0aGUgcmVuZGVyZXIgdG8uXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblx0b25BZGQodGFyZ2V0KSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgdGFyZ2V0IGlzIHJlbW92ZWQgZnJvbSBhIHBsb3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T3ZlcmxheX0gdGFyZ2V0IC0gVGhlIHRhcmdldCB0byByZW1vdmUgdGhlIHJlbmRlcmVyIGZyb20uXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblx0b25SZW1vdmUodGFyZ2V0KSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUGljayBhIHBvc2l0aW9uIG9mIHRoZSBsYXllciBmb3IgYSBjb2xsaXNpb24gd2l0aCBhbnkgcmVuZGVyZWQgb2JqZWN0cy5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHBvcyAtIFRoZSBwbG90IHBvc2l0aW9uIHRvIHBpY2sgYXQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjb2xsaXNpb24sIG9yIG51bGwuXG5cdCAqL1xuXHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXHRwaWNrKHBvcykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFycyBhbnkgcGVyc2lzdGVkIHN0YXRlIGluIHRoZSByZW5kZXJlci5cblx0ICpcblx0ICogQHJldHVybnMge1JlbmRlcmVyfSBUaGUgcmVuZGVyZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRjbGVhcigpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgZHJhdyBmdW5jdGlvbiB0aGF0IGlzIGV4ZWN1dGVkIHBlciBmcmFtZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcCAtIFRoZSBmcmFtZSB0aW1lc3RhbXAuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblx0ZHJhdyh0aW1lc3RhbXApIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlcmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBSZW5kZXJlciA9IHJlcXVpcmUoJy4uL1JlbmRlcmVyJyk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIG92ZXJsYXkgcmVuZGVyZXIuXG4gKi9cbmNsYXNzIE92ZXJsYXlSZW5kZXJlciBleHRlbmRzIFJlbmRlcmVyIHtcblxuXHQvKipcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IE92ZXJsYXlSZW5kZXJlciBvYmplY3QuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMub3ZlcmxheSA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgb3ZlcmxheSBpcyBhdHRhY2hlZCB0byBhIHBsb3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T3ZlcmxheX0gb3ZlcmxheSAtIFRoZSBvdmVybGF5IHRvIGF0dGFjaCB0aGUgcmVuZGVyZXIgdG8uXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtPdmVybGF5UmVuZGVyZXJ9IFRoZSByZW5kZXJlciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdG9uQWRkKG92ZXJsYXkpIHtcblx0XHRpZiAoIW92ZXJsYXkpIHtcblx0XHRcdHRocm93ICdObyBvdmVybGF5IHByb3ZpZGVkIGFzIGFyZ3VtZW50Jztcblx0XHR9XG5cdFx0dGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBFeGVjdXRlZCB3aGVuIHRoZSBvdmVybGF5IGlzIHJlbW92ZWQgZnJvbSBhIHBsb3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T3ZlcmxheX0gb3ZlcmxheSAtIFRoZSBvdmVybGF5IHRvIHJlbW92ZSB0aGUgcmVuZGVyZXIgZnJvbS5cblx0ICpcblx0ICogQHJldHVybnMge092ZXJsYXlSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0b25SZW1vdmUob3ZlcmxheSkge1xuXHRcdGlmICghb3ZlcmxheSkge1xuXHRcdFx0dGhyb3cgJ05vIG92ZXJsYXkgcHJvdmlkZWQgYXMgYXJndW1lbnQnO1xuXHRcdH1cblx0XHR0aGlzLm92ZXJsYXkgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gT3ZlcmxheVJlbmRlcmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTaGFkZXIgPSByZXF1aXJlKCcuLi8uLi93ZWJnbC9zaGFkZXIvU2hhZGVyJyk7XG5jb25zdCBFdmVudFR5cGUgPSByZXF1aXJlKCcuLi8uLi9ldmVudC9FdmVudFR5cGUnKTtcbmNvbnN0IE92ZXJsYXlSZW5kZXJlciA9IHJlcXVpcmUoJy4vT3ZlcmxheVJlbmRlcmVyJyk7XG5cbi8vIENvbnN0YW50c1xuXG4vKipcbiAqIFJlZnJlc2ggZXZlbnQgaGFuZGxlciBzeW1ib2wuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50IHtTeW1ib2x9XG4gKi9cbmNvbnN0IFJFRlJFU0ggPSBTeW1ib2woKTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSB3ZWJnbCBvdmVybGF5IHJlbmRlcmVyLlxuICovXG5jbGFzcyBXZWJHTE92ZXJsYXlSZW5kZXJlciBleHRlbmRzIE92ZXJsYXlSZW5kZXJlciB7XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBXZWJHTE92ZXJsYXlSZW5kZXJlciBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG92ZXJsYXkgb3B0aW9ucy5cblx0ICovXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuXHRcdHN1cGVyKG9wdGlvbnMpO1xuXHRcdHRoaXMuZ2wgPSBudWxsO1xuXHRcdHRoaXNbUkVGUkVTSF0gPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4ZWN1dGVkIHdoZW4gdGhlIG92ZXJsYXkgaXMgYXR0YWNoZWQgdG8gYSBwbG90LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0xheWVyfSBvdmVybGF5IC0gVGhlIG92ZXJsYXkgdG8gYXR0YWNoIHRoZSByZW5kZXJlciB0by5cblx0ICpcblx0ICogQHJldHVybnMge1dlYkdMT3ZlcmxheVJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRvbkFkZChvdmVybGF5KSB7XG5cdFx0c3VwZXIub25BZGQob3ZlcmxheSk7XG5cdFx0dGhpcy5nbCA9IHRoaXMub3ZlcmxheS5wbG90LmdldFJlbmRlcmluZ0NvbnRleHQoKTtcblx0XHQvLyBjcmVhdGUgYnVmZmVyc1xuXHRcdHRoaXMucmVmcmVzaEJ1ZmZlcnMoKTtcblx0XHQvLyBjcmVhdGUgcmVmcmVzaCBoYW5kbGVyXG5cdFx0dGhpc1tSRUZSRVNIXSA9ICgpID0+IHtcblx0XHRcdHRoaXMucmVmcmVzaEJ1ZmZlcnMoKTtcblx0XHR9O1xuXHRcdC8vIGF0dGFjaCByZWZyZXNoIGhhbmRsZXJcblx0XHR0aGlzLm92ZXJsYXkub24oRXZlbnRUeXBlLlJFRlJFU0gsIHRoaXNbUkVGUkVTSF0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4ZWN1dGVkIHdoZW4gdGhlIG92ZXJsYXkgaXMgcmVtb3ZlZCBmcm9tIGEgcGxvdC5cblx0ICpcblx0ICogQHBhcmFtIHtMYXllcn0gb3ZlcmxheSAtIFRoZSBvdmVybGF5IHRvIHJlbW92ZSB0aGUgcmVuZGVyZXIgZnJvbS5cblx0ICpcblx0ICogQHJldHVybnMge1dlYkdMT3ZlcmxheVJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRvblJlbW92ZShvdmVybGF5KSB7XG5cdFx0Ly8gcmVtb3ZlIHJlZnJlc2ggaGFuZGxlclxuXHRcdHRoaXMub3ZlcmxheS5yZW1vdmVMaXN0ZW5lcihFdmVudFR5cGUuUkVGUkVTSCwgdGhpc1tSRUZSRVNIXSk7XG5cdFx0Ly8gZGVzdHJveSByZWZyZXNoIGhhbmRsZXJcblx0XHR0aGlzW1JFRlJFU0hdID0gbnVsbDtcblx0XHR0aGlzLmdsID0gbnVsbDtcblx0XHRzdXBlci5vblJlbW92ZShvdmVybGF5KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBhbnkgdW5kZXJseWluZyBidWZmZXJzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7V2ViR0xPdmVybGF5UmVuZGVyZXJ9IFRoZSBvdmVybGF5IG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0cmVmcmVzaEJ1ZmZlcnMoKSB7XG5cdFx0dGhyb3cgJ2ByZWZyZXNoQnVmZmVyc2AgbXVzdCBiZSBvdmVycmlkZGVuJztcblx0fVxuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFNoYWRlciBvYmplY3QgdXNpbmcgdGhlIHJlbmRlcmVycyBpbnRlcm5hbFxuXHQgKiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgLSBUaGUgc2hhZGVyIHBhcmFtIG9iamVjdC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZS5jb21tb24gLSBDb21tb24gZ2xzbCB0byBiZSBzaGFyZWQgYnkgYm90aCB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlcnMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UudmVydCAtIFRoZSB2ZXJ0ZXggc2hhZGVyIGdsc2wuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UuZnJhZyAtIFRoZSBmcmFnbWVudCBzaGFkZXIgZ2xzbC5cblx0ICpcblx0ICogQHJldHVybnMge1NoYWRlcn0gVGhlIHNoYWRlciBvYmplY3QuXG5cdCAqL1xuXHRjcmVhdGVTaGFkZXIoc291cmNlKSB7XG5cdFx0cmV0dXJuIG5ldyBTaGFkZXIodGhpcy5nbCwgc291cmNlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXggZm9yIHRoZSB2aWV3cG9ydC5cblx0ICpcblx0ICogQHJldHVybnMge0Zsb2F0MzJBcnJheX0gVGhlIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uIG1hdHJpeC5cblx0ICovXG5cdGdldE9ydGhvTWF0cml4KCkge1xuXHRcdHJldHVybiB0aGlzLm92ZXJsYXkucGxvdC5nZXRPcnRob01hdHJpeCgpO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViR0xPdmVybGF5UmVuZGVyZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGRlZmF1bHRUbyA9IHJlcXVpcmUoJ2xvZGFzaC9kZWZhdWx0VG8nKTtcbmNvbnN0IFZlcnRleEJ1ZmZlciA9IHJlcXVpcmUoJy4uLy4uLy4uL3dlYmdsL3ZlcnRleC9WZXJ0ZXhCdWZmZXInKTtcbmNvbnN0IFdlYkdMT3ZlcmxheVJlbmRlcmVyID0gcmVxdWlyZSgnLi4vV2ViR0xPdmVybGF5UmVuZGVyZXInKTtcblxuLy8gQ29uc3RhbnRzXG5cbi8qKlxuICogU2hhZGVyIEdMU0wgc291cmNlLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7T2JqZWN0fVxuICovXG5jb25zdCBTSEFERVJfR0xTTCA9IHtcblx0dmVydDpcblx0XHRgXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXHRcdGF0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbjtcblx0XHRhdHRyaWJ1dGUgdmVjMiBhTm9ybWFsO1xuXHRcdHVuaWZvcm0gdmVjMiB1Vmlld09mZnNldDtcblx0XHR1bmlmb3JtIGZsb2F0IHVTY2FsZTtcblx0XHR1bmlmb3JtIGZsb2F0IHVMaW5lV2lkdGg7XG5cdFx0dW5pZm9ybSBmbG9hdCB1UGl4ZWxSYXRpbztcblx0XHR1bmlmb3JtIGZsb2F0IHVQb2ludFJhZGl1cztcblx0XHR1bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XG5cdFx0dm9pZCBtYWluKCkge1xuXHRcdFx0dmVjMiB3UG9zaXRpb24gPSAoYVBvc2l0aW9uICogdVNjYWxlKSAtIHVWaWV3T2Zmc2V0O1xuXHRcdFx0Z2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQod1Bvc2l0aW9uLCAwLjAsIDEuMCk7XG5cdFx0XHRnbF9Qb2ludFNpemUgPSB1UG9pbnRSYWRpdXMgKiAyLjAgKiB1UGl4ZWxSYXRpbztcblx0XHR9XG5cdFx0YCxcblx0ZnJhZzpcblx0XHRgXG5cdFx0I2lmZGVmIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1xuXHRcdFx0I2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGVcblx0XHQjZW5kaWZcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5cdFx0dW5pZm9ybSB2ZWM0IHVQb2ludENvbG9yO1xuXHRcdHVuaWZvcm0gZmxvYXQgdU9wYWNpdHk7XG5cdFx0dm9pZCBtYWluKCkge1xuXHRcdFx0dmVjMiBjeHkgPSAyLjAgKiBnbF9Qb2ludENvb3JkIC0gMS4wO1xuXHRcdFx0ZmxvYXQgcmFkaXVzID0gZG90KGN4eSwgY3h5KTtcblx0XHRcdGZsb2F0IGFscGhhID0gMS4wO1xuXHRcdFx0I2lmZGVmIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1xuXHRcdFx0XHRmbG9hdCBkZWx0YSA9IGZ3aWR0aChyYWRpdXMpO1xuXHRcdFx0XHRhbHBoYSA9IDEuMCAtIHNtb290aHN0ZXAoMS4wIC0gZGVsdGEsIDEuMCArIGRlbHRhLCByYWRpdXMpO1xuXHRcdFx0I2Vsc2Vcblx0XHRcdFx0aWYgKHJhZGl1cyA+IDEuMCkge1xuXHRcdFx0XHRcdGRpc2NhcmQ7XG5cdFx0XHRcdH1cblx0XHRcdCNlbmRpZlxuXHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCh1UG9pbnRDb2xvci5yZ2IsIHVQb2ludENvbG9yLmEgKiBhbHBoYSAqIHVPcGFjaXR5KTtcblx0XHR9XG5cdFx0YFxufTtcblxuLy8gUHJpdmF0ZSBNZXRob2RzXG5cbmNvbnN0IGJ1ZmZlclBvaW50cyA9IGZ1bmN0aW9uKHBvaW50cykge1xuXHRjb25zdCBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiAyKTtcblx0Zm9yIChsZXQgaT0wOyBpPHBvaW50cy5sZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuXHRcdGJ1ZmZlcltpKjJdID0gcG9pbnQueDtcblx0XHRidWZmZXJbaSoyKzFdID0gcG9pbnQueTtcblx0fVxuXHRyZXR1cm4gYnVmZmVyO1xufTtcblxuY29uc3QgY3JlYXRlVmVydGV4QnVmZmVyID0gZnVuY3Rpb24oZ2wsIHBvaW50cykge1xuXHRjb25zdCBkYXRhID0gYnVmZmVyUG9pbnRzKHBvaW50cyk7XG5cdHJldHVybiBuZXcgVmVydGV4QnVmZmVyKFxuXHRcdGdsLFxuXHRcdGRhdGEsXG5cdFx0e1xuXHRcdFx0MDoge1xuXHRcdFx0XHRzaXplOiAyLFxuXHRcdFx0XHR0eXBlOiAnRkxPQVQnXG5cdFx0XHR9XG5cdFx0fSxcblx0XHR7XG5cdFx0XHRtb2RlOiAnUE9JTlRTJyxcblx0XHRcdGNvdW50OiBwb2ludHMubGVuZ3RoXG5cdFx0fSk7XG59O1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHdlYmdsIHBvaW50IG92ZXJsYXkgcmVuZGVyZXIuXG4gKi9cbmNsYXNzIFBvaW50T3ZlcmxheVJlbmRlcmVyIGV4dGVuZHMgV2ViR0xPdmVybGF5UmVuZGVyZXIge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgUG9pbnRPdmVybGF5UmVuZGVyZXIgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvdmVybGF5IG9wdGlvbnMuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IG9wdGlvbnMucG9pbnRDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgcG9pbnRzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5wb2ludFJhZGl1cyAtIFRoZSBwaXhlbCByYWRpdXMgb2YgdGhlIHBvaW50cy5cblx0ICovXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuXHRcdHN1cGVyKG9wdGlvbnMpO1xuXHRcdHRoaXMucG9pbnRDb2xvciA9IGRlZmF1bHRUbyhvcHRpb25zLnBvaW50Q29sb3IsIFsgMS4wLCAwLjAsIDEuMCwgMS4wIF0pO1xuXHRcdHRoaXMucG9pbnRSYWRpdXMgPSBkZWZhdWx0VG8ob3B0aW9ucy5wb2ludFJhZGl1cywgNCk7XG5cdFx0dGhpcy5zaGFkZXIgPSBudWxsO1xuXHRcdHRoaXMuZXh0ID0gbnVsbDtcblx0XHR0aGlzLnBvaW50cyA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgb3ZlcmxheSBpcyBhdHRhY2hlZCB0byBhIHBsb3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TGF5ZXJ9IG92ZXJsYXkgLSBUaGUgb3ZlcmxheSB0byBhdHRhY2ggdGhlIHJlbmRlcmVyIHRvLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UG9pbnRPdmVybGF5UmVuZGVyZXJ9IFRoZSByZW5kZXJlciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdG9uQWRkKG92ZXJsYXkpIHtcblx0XHRzdXBlci5vbkFkZChvdmVybGF5KTtcblx0XHR0aGlzLmV4dCA9IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnKTtcblx0XHR0aGlzLnNoYWRlciA9IHRoaXMuY3JlYXRlU2hhZGVyKFNIQURFUl9HTFNMKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBFeGVjdXRlZCB3aGVuIHRoZSBvdmVybGF5IGlzIHJlbW92ZWQgZnJvbSBhIHBsb3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TGF5ZXJ9IG92ZXJsYXkgLSBUaGUgb3ZlcmxheSB0byByZW1vdmUgdGhlIHJlbmRlcmVyIGZyb20uXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtQb2ludE92ZXJsYXlSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0b25SZW1vdmUob3ZlcmxheSkge1xuXHRcdHRoaXMuc2hhZGVyID0gbnVsbDtcblx0XHR0aGlzLmV4dCA9IG51bGw7XG5cdFx0dGhpcy5wb2ludHMgPSBudWxsO1xuXHRcdHN1cGVyLm9uUmVtb3ZlKG92ZXJsYXkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIGFueSB1bmRlcmx5aW5nIGJ1ZmZlcnMuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtQb2ludE92ZXJsYXlSZW5kZXJlcn0gVGhlIG92ZXJsYXkgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRyZWZyZXNoQnVmZmVycygpIHtcblx0XHQvLyBjbGlwIHBvaW50cyB0byBvbmx5IHRob3NlIHRoYXQgYXJlIGluc2lkZSB0aGUgY2VsbFxuXHRcdGNvbnN0IGNsaXBwZWQgPSB0aGlzLm92ZXJsYXkuZ2V0Q2xpcHBlZEdlb21ldHJ5KCk7XG5cdFx0Ly8gZ2VuZXJhdGUgdGhlIGJ1ZmZlclxuXHRcdGlmIChjbGlwcGVkICYmIGNsaXBwZWQubGVuZ3RoID4gMCkge1xuXHRcdFx0dGhpcy5wb2ludHMgPSBjcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5nbCwgY2xpcHBlZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9pbnRzID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGRyYXcgZnVuY3Rpb24gdGhhdCBpcyBleGVjdXRlZCBwZXIgZnJhbWUuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtQb2ludE92ZXJsYXlSZW5kZXJlcn0gVGhlIG92ZXJsYXkgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRkcmF3KCkge1xuXHRcdGlmICghdGhpcy5wb2ludHMpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcblx0XHRjb25zdCBzaGFkZXIgPSB0aGlzLnNoYWRlcjtcblx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRjb25zdCBwbG90ID0gdGhpcy5vdmVybGF5LnBsb3Q7XG5cdFx0Y29uc3QgY2VsbCA9IHBsb3QuY2VsbDtcblx0XHRjb25zdCBwcm9qID0gdGhpcy5nZXRPcnRob01hdHJpeCgpO1xuXHRcdGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMiwgcGxvdC56b29tIC0gY2VsbC56b29tKTtcblx0XHRjb25zdCBvcGFjaXR5ID0gdGhpcy5vdmVybGF5Lm9wYWNpdHk7XG5cblx0XHQvLyBnZXQgdmlldyBvZmZzZXQgaW4gY2VsbCBzcGFjZVxuXHRcdGNvbnN0IG9mZnNldCA9IGNlbGwucHJvamVjdChwbG90LnZpZXdwb3J0LCBwbG90Lnpvb20pO1xuXG5cdFx0Ly8gc2V0IGJsZW5kaW5nIGZ1bmNcblx0XHRnbC5lbmFibGUoZ2wuQkxFTkQpO1xuXHRcdGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuXG5cdFx0Ly8gYmluZCBzaGFkZXJcblx0XHRzaGFkZXIudXNlKCk7XG5cblx0XHQvLyBzZXQgZ2xvYmFsIHVuaWZvcm1zXG5cdFx0c2hhZGVyLnNldFVuaWZvcm0oJ3VQcm9qZWN0aW9uTWF0cml4JywgcHJvaik7XG5cdFx0c2hhZGVyLnNldFVuaWZvcm0oJ3VWaWV3T2Zmc2V0JywgWyBvZmZzZXQueCwgb2Zmc2V0LnkgXSk7XG5cdFx0c2hhZGVyLnNldFVuaWZvcm0oJ3VTY2FsZScsIHNjYWxlKTtcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVBvaW50Q29sb3InLCB0aGlzLnBvaW50Q29sb3IpO1xuXHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1UG9pbnRSYWRpdXMnLCB0aGlzLnBvaW50UmFkaXVzKTtcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVBpeGVsUmF0aW8nLCBwbG90LnBpeGVsUmF0aW8pO1xuXHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1T3BhY2l0eScsIG9wYWNpdHkpO1xuXG5cdFx0Ly8gZHJhdyB0aGUgcG9pbnRzXG5cdFx0cG9pbnRzLmJpbmQoKTtcblx0XHRwb2ludHMuZHJhdygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludE92ZXJsYXlSZW5kZXJlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZWFyY3V0ID0gcmVxdWlyZSgnZWFyY3V0Jyk7XG5jb25zdCBkZWZhdWx0VG8gPSByZXF1aXJlKCdsb2Rhc2gvZGVmYXVsdFRvJyk7XG5jb25zdCBWZXJ0ZXhCdWZmZXIgPSByZXF1aXJlKCcuLi8uLi8uLi93ZWJnbC92ZXJ0ZXgvVmVydGV4QnVmZmVyJyk7XG5jb25zdCBJbmRleEJ1ZmZlciA9IHJlcXVpcmUoJy4uLy4uLy4uL3dlYmdsL3ZlcnRleC9JbmRleEJ1ZmZlcicpO1xuY29uc3QgV2ViR0xPdmVybGF5UmVuZGVyZXIgPSByZXF1aXJlKCcuLi9XZWJHTE92ZXJsYXlSZW5kZXJlcicpO1xuXG4vLyBDb25zdGFudHNcblxuLyoqXG4gKiBTaGFkZXIgR0xTTCBzb3VyY2UuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50IHtPYmplY3R9XG4gKi9cbmNvbnN0IFNIQURFUl9HTFNMID0ge1xuXHR2ZXJ0OlxuXHRcdGBcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5cdFx0YXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xuXHRcdHVuaWZvcm0gdmVjMiB1Vmlld09mZnNldDtcblx0XHR1bmlmb3JtIGZsb2F0IHVTY2FsZTtcblx0XHR1bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XG5cdFx0dm9pZCBtYWluKCkge1xuXHRcdFx0dmVjMiB3UG9zaXRpb24gPSAoYVBvc2l0aW9uICogdVNjYWxlKSAtIHVWaWV3T2Zmc2V0O1xuXHRcdFx0Z2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQod1Bvc2l0aW9uLCAwLjAsIDEuMCk7XG5cdFx0fVxuXHRcdGAsXG5cdGZyYWc6XG5cdFx0YFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblx0XHR1bmlmb3JtIHZlYzQgdVBvbHlnb25Db2xvcjtcblx0XHR1bmlmb3JtIGZsb2F0IHVPcGFjaXR5O1xuXHRcdHZvaWQgbWFpbigpIHtcblx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQodVBvbHlnb25Db2xvci5yZ2IsIHVQb2x5Z29uQ29sb3IuYSAqIHVPcGFjaXR5KTtcblx0XHR9XG5cdFx0YFxufTtcblxuLy8gUHJpdmF0ZSBNZXRob2RzXG5cbmNvbnN0IGdldFZlcnRleEFycmF5ID0gZnVuY3Rpb24ocG9pbnRzKSB7XG5cdGNvbnN0IHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShwb2ludHMubGVuZ3RoICogMik7XG5cdGZvciAobGV0IGk9MDsgaTxwb2ludHMubGVuZ3RoOyBpKyspIHtcblx0XHR2ZXJ0aWNlc1tpKjJdID0gcG9pbnRzW2ldLng7XG5cdFx0dmVydGljZXNbaSoyICsgMV0gPSBwb2ludHNbaV0ueTtcblx0fVxuXHRyZXR1cm4gdmVydGljZXM7XG59O1xuXG5jb25zdCBjcmVhdGVCdWZmZXJzID0gZnVuY3Rpb24ob3ZlcmxheSwgcG9pbnRzKSB7XG5cdGNvbnN0IHZlcnRpY2VzID0gZ2V0VmVydGV4QXJyYXkocG9pbnRzKTtcblx0Y29uc3QgaW5kaWNlcyA9IGVhcmN1dCh2ZXJ0aWNlcyk7XG5cdGNvbnN0IHZlcnRleEJ1ZmZlciA9IG5ldyBWZXJ0ZXhCdWZmZXIoXG5cdFx0b3ZlcmxheS5nbCxcblx0XHR2ZXJ0aWNlcyxcblx0XHR7XG5cdFx0XHQwOiB7XG5cdFx0XHRcdHNpemU6IDIsXG5cdFx0XHRcdHR5cGU6ICdGTE9BVCdcblx0XHRcdH1cblx0XHR9KTtcblx0Y29uc3QgaXMxNkJpdCA9IHZlcnRpY2VzLmxlbmd0aCA8IE1hdGgucG93KDIsIDE2KTtcblx0Y29uc3QgaW5kZXhCdWZmZXIgPSBuZXcgSW5kZXhCdWZmZXIoXG5cdFx0b3ZlcmxheS5nbCxcblx0XHRpczE2Qml0ID8gbmV3IFVpbnQxNkFycmF5KGluZGljZXMpIDogbmV3IFVpbnQzMkFycmF5KGluZGljZXMpLFxuXHRcdHtcblx0XHRcdG1vZGU6ICdUUklBTkdMRVMnLFxuXHRcdFx0dHlwZTogaXMxNkJpdCA/ICdVTlNJR05FRF9TSE9SVCcgOiAnVU5TSUdORURfSU5UJyxcblx0XHRcdGNvdW50OiBpbmRpY2VzLmxlbmd0aFxuXHRcdH0pO1xuXHRyZXR1cm4ge1xuXHRcdHZlcnRleDogdmVydGV4QnVmZmVyLFxuXHRcdGluZGV4OiBpbmRleEJ1ZmZlclxuXHR9O1xufTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSB3ZWJnbCBwb2x5bGluZSBvdmVybGF5IHJlbmRlcmVyLlxuICovXG5jbGFzcyBQb2x5Z29uT3ZlcmxheVJlbmRlcmVyIGV4dGVuZHMgV2ViR0xPdmVybGF5UmVuZGVyZXIge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgUG9seWdvbk92ZXJsYXlSZW5kZXJlciBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG92ZXJsYXkgb3B0aW9ucy5cblx0ICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy5wb2x5Z29uQ29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIGxpbmUuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcblx0XHRzdXBlcihvcHRpb25zKTtcblx0XHR0aGlzLnBvbHlnb25Db2xvciA9IGRlZmF1bHRUbyhvcHRpb25zLnBvbHlnb25Db2xvciwgWyAxLjAsIDAuNCwgMC4xLCAwLjggXSk7XG5cdFx0dGhpcy5zaGFkZXIgPSBudWxsO1xuXHRcdHRoaXMucG9seWdvbnMgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4ZWN1dGVkIHdoZW4gdGhlIG92ZXJsYXkgaXMgYXR0YWNoZWQgdG8gYSBwbG90LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1Bsb3R9IHBsb3QgLSBUaGUgcGxvdCB0byBhdHRhY2ggdGhlIG92ZXJsYXkgdG8uXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtQb2x5Z29uT3ZlcmxheVJlbmRlcmVyfSBUaGUgb3ZlcmxheSBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdG9uQWRkKHBsb3QpIHtcblx0XHRzdXBlci5vbkFkZChwbG90KTtcblx0XHR0aGlzLnNoYWRlciA9IHRoaXMuY3JlYXRlU2hhZGVyKFNIQURFUl9HTFNMKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBFeGVjdXRlZCB3aGVuIHRoZSBvdmVybGF5IGlzIHJlbW92ZWQgZnJvbSBhIHBsb3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UGxvdH0gcGxvdCAtIFRoZSBwbG90IHRvIHJlbW92ZSB0aGUgb3ZlcmxheSBmcm9tLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UG9seWdvbk92ZXJsYXlSZW5kZXJlcn0gVGhlIG92ZXJsYXkgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRvblJlbW92ZShwbG90KSB7XG5cdFx0c3VwZXIub25SZW1vdmUocGxvdCk7XG5cdFx0dGhpcy5zaGFkZXIgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIGFueSB1bmRlcmx5aW5nIGJ1ZmZlcnMuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtQb2x5Z29uT3ZlcmxheVJlbmRlcmVyfSBUaGUgb3ZlcmxheSBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHJlZnJlc2hCdWZmZXJzKCkge1xuXHRcdGNvbnN0IGNsaXBwZWQgPSB0aGlzLm92ZXJsYXkuZ2V0Q2xpcHBlZEdlb21ldHJ5KCk7XG5cdFx0aWYgKGNsaXBwZWQpIHtcblx0XHRcdHRoaXMucG9seWdvbnMgPSBjbGlwcGVkLm1hcChwb2ludHMgPT4ge1xuXHRcdFx0XHQvLyBnZW5lcmF0ZSB0aGUgYnVmZmVyXG5cdFx0XHRcdHJldHVybiBjcmVhdGVCdWZmZXJzKHRoaXMsIHBvaW50cyk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb2x5Z29ucyA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBkcmF3IGZ1bmN0aW9uIHRoYXQgaXMgZXhlY3V0ZWQgcGVyIGZyYW1lLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UG9seWdvbk92ZXJsYXlSZW5kZXJlcn0gVGhlIG92ZXJsYXkgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRkcmF3KCkge1xuXHRcdGlmICghdGhpcy5wb2x5Z29ucykge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xuXHRcdGNvbnN0IHNoYWRlciA9IHRoaXMuc2hhZGVyO1xuXHRcdGNvbnN0IHBvbHlnb25zID0gdGhpcy5wb2x5Z29ucztcblx0XHRjb25zdCBwbG90ID0gdGhpcy5vdmVybGF5LnBsb3Q7XG5cdFx0Y29uc3QgY2VsbCA9IHBsb3QuY2VsbDtcblx0XHRjb25zdCBwcm9qID0gdGhpcy5nZXRPcnRob01hdHJpeCgpO1xuXHRcdGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMiwgcGxvdC56b29tIC0gY2VsbC56b29tKTtcblx0XHRjb25zdCBvcGFjaXR5ID0gdGhpcy5vdmVybGF5Lm9wYWNpdHk7XG5cblx0XHQvLyBnZXQgdmlldyBvZmZzZXQgaW4gY2VsbCBzcGFjZVxuXHRcdGNvbnN0IG9mZnNldCA9IGNlbGwucHJvamVjdChwbG90LnZpZXdwb3J0LCBwbG90Lnpvb20pO1xuXG5cdFx0Ly8gc2V0IGJsZW5kaW5nIGZ1bmNcblx0XHRnbC5lbmFibGUoZ2wuQkxFTkQpO1xuXHRcdGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuXG5cdFx0Ly8gYmluZCBzaGFkZXJcblx0XHRzaGFkZXIudXNlKCk7XG5cblx0XHQvLyBzZXQgZ2xvYmFsIHVuaWZvcm1zXG5cdFx0c2hhZGVyLnNldFVuaWZvcm0oJ3VQcm9qZWN0aW9uTWF0cml4JywgcHJvaik7XG5cdFx0c2hhZGVyLnNldFVuaWZvcm0oJ3VWaWV3T2Zmc2V0JywgWyBvZmZzZXQueCwgb2Zmc2V0LnkgXSk7XG5cdFx0c2hhZGVyLnNldFVuaWZvcm0oJ3VTY2FsZScsIHNjYWxlKTtcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVBvbHlnb25Db2xvcicsIHRoaXMucG9seWdvbkNvbG9yKTtcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndU9wYWNpdHknLCBvcGFjaXR5KTtcblxuXHRcdC8vIGZvciBlYWNoIHBvbHlsaW5lIGJ1ZmZlclxuXHRcdHBvbHlnb25zLmZvckVhY2goYnVmZmVyID0+IHtcblx0XHRcdC8vIGRyYXcgdGhlIHBvaW50c1xuXHRcdFx0YnVmZmVyLnZlcnRleC5iaW5kKCk7XG5cdFx0XHRidWZmZXIuaW5kZXguZHJhdygpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uT3ZlcmxheVJlbmRlcmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkZWZhdWx0VG8gPSByZXF1aXJlKCdsb2Rhc2gvZGVmYXVsdFRvJyk7XG5jb25zdCBWZXJ0ZXhCdWZmZXIgPSByZXF1aXJlKCcuLi8uLi8uLi93ZWJnbC92ZXJ0ZXgvVmVydGV4QnVmZmVyJyk7XG5jb25zdCBXZWJHTE92ZXJsYXlSZW5kZXJlciA9IHJlcXVpcmUoJy4uL1dlYkdMT3ZlcmxheVJlbmRlcmVyJyk7XG5cbi8vIENvbnN0YW50c1xuXG4vKipcbiAqIFNoYWRlciBHTFNMIHNvdXJjZS5cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnQge09iamVjdH1cbiAqL1xuY29uc3QgU0hBREVSX0dMU0wgPSB7XG5cdHZlcnQ6XG5cdFx0YFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblx0XHRhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XG5cdFx0YXR0cmlidXRlIHZlYzIgYU5vcm1hbDtcblx0XHR1bmlmb3JtIHZlYzIgdVZpZXdPZmZzZXQ7XG5cdFx0dW5pZm9ybSBmbG9hdCB1U2NhbGU7XG5cdFx0dW5pZm9ybSBmbG9hdCB1TGluZVdpZHRoO1xuXHRcdHVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcblx0XHR2b2lkIG1haW4oKSB7XG5cdFx0XHR2ZWMyIHdQb3NpdGlvbiA9IChhUG9zaXRpb24gKiB1U2NhbGUpIC0gdVZpZXdPZmZzZXQgKyBhTm9ybWFsICogdUxpbmVXaWR0aDtcblx0XHRcdGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB2ZWM0KHdQb3NpdGlvbiwgMC4wLCAxLjApO1xuXHRcdH1cblx0XHRgLFxuXHRmcmFnOlxuXHRcdGBcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5cdFx0dW5pZm9ybSB2ZWM0IHVMaW5lQ29sb3I7XG5cdFx0dW5pZm9ybSBmbG9hdCB1T3BhY2l0eTtcblx0XHR2b2lkIG1haW4oKSB7XG5cdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KHVMaW5lQ29sb3IucmdiLCB1TGluZUNvbG9yLmEgKiB1T3BhY2l0eSk7XG5cdFx0fVxuXHRcdGBcbn07XG5cbi8vIFByaXZhdGUgTWV0aG9kc1xuXG4vLyBOT1RFOiBzbW9vdGggLyByb3VuZCBsaW5lcyBpbXBsZW1lbnRlZCB1c2luZyBjb2RlIG1vZGlmaWVkIGZyb206XG4vLyBodHRwOi8vbGFicy5oeXBlcmFuZHJvaWQuY29tL2VmZmljaWVudC13ZWJnbC1zdHJva2luZyAuIEluc3RlYWQgb2YgYmFraW5nIGluXG4vLyB0aGUgcG9zaXRpb25zIG9mIHRoZSBsaW5lcywgdGhpcyBpbXBsZW1lbnRhdGlvbiBpbnN0ZWFkIGdlbmVyYXRlcyB0aGVcbi8vIHBvc2l0aW9ucyBhbG9uZyB0aGUgbGluZSBhbmQgc3RvcmVzIHRoZSB0YW5nZW50cywgYWxsb3dpbmcgdGhlIHRoaWNrbmVzcyB0b1xuLy8gYmUgYXJiaXRyYXJpbHkgc2NhbGVkIG91dHdhcmRzIGluZGVwZW5kYW50IG9mIHNjYWxlLiBJbiBvcmRlciB0byBwcmV2ZW50XG4vLyBkZWdlbmVyYXRpb24gb2Ygbm9ybWFscyBkdWUgdG8gc2VsZi1pbnRlcnNlY3Rpb25zLCB0aGUgdHJpYW5nbGVzIGFyZVxuLy8gZ2VuZXJhdGVkIHVwb24gem9vbS5cblxuY29uc3QgRVBTSUxPTiA9IDAuMDAwMDAxO1xuXG5jb25zdCBzY2FsYXJNdWx0ID0gZnVuY3Rpb24oYSwgcykge1xuXHRyZXR1cm4ge1xuXHRcdHg6IGEueCAqIHMsXG5cdFx0eTogYS55ICogc1xuXHR9O1xufTtcblxuY29uc3QgcGVycGVuZGljdWxhciA9IGZ1bmN0aW9uKGEpIHtcblx0cmV0dXJuIHtcblx0XHR4OiAtYS55LFxuXHRcdHk6IGEueFxuXHR9O1xufTtcblxuY29uc3QgaW52ZXJ0ID0gZnVuY3Rpb24oYSkge1xuXHRyZXR1cm4ge1xuXHRcdHg6IC1hLngsXG5cdFx0eTogLWEueVxuXHR9O1xufTtcblxuY29uc3QgbGVuZ3RoID0gZnVuY3Rpb24oYSkge1xuXHRyZXR1cm4gTWF0aC5zcXJ0KGEueCAqIGEueCArIGEueSAqIGEueSk7XG59O1xuXG5jb25zdCBub3JtYWxpemUgPSBmdW5jdGlvbihhKSB7XG5cdGNvbnN0IG1vZCA9IE1hdGguc3FydChhLnggKiBhLnggKyBhLnkgKiBhLnkpO1xuXHRyZXR1cm4ge1xuXHRcdHg6IGEueCAvIG1vZCxcblx0XHR5OiBhLnkgLyBtb2Rcblx0fTtcbn07XG5cbmNvbnN0IGFkZCA9IGZ1bmN0aW9uKHAwLCBwMSkge1xuXHRyZXR1cm4ge1xuXHRcdHg6IHAwLnggKyBwMS54LFxuXHRcdHk6IHAwLnkgKyBwMS55XG5cdH07XG59O1xuXG5jb25zdCBzdWIgPSBmdW5jdGlvbihwMCwgcDEpIHtcblx0cmV0dXJuIHtcblx0XHR4OiBwMC54IC0gcDEueCxcblx0XHR5OiBwMC55IC0gcDEueVxuXHR9O1xufTtcblxuY29uc3QgbWlkZGxlID0gZnVuY3Rpb24ocDAsIHAxKSB7XG5cdHJldHVybiBzY2FsYXJNdWx0KGFkZChwMCwgcDEpLCAwLjUpO1xufTtcblxuY29uc3QgZXF1YWwgPSBmdW5jdGlvbihwMCwgcDEpIHtcblx0cmV0dXJuIHAwLnggPT09IHAxLnggJiYgcDAueSA9PT0gcDEueTtcbn07XG5cbmNvbnN0IHNpZ25lZEFyZWEgPSBmdW5jdGlvbihwMCwgcDEsIHAyKSB7XG5cdHJldHVybiAocDEueCAtIHAwLngpICogKHAyLnkgLSBwMC55KSAtIChwMi54IC0gcDAueCkgKiAocDEueSAtIHAwLnkpO1xufTtcblxuY29uc3QgZ2V0U3Ryb2tlR2VvbWV0cnkgPSBmdW5jdGlvbihwb2ludHMsIHN0cm9rZVdpZHRoKSB7XG5cdGlmIChwb2ludHMubGVuZ3RoIDwgMikge1xuXHRcdHRocm93ICdBIHZhbGlkIHBvbHlsaW5lIG11c3QgY29uc2lzdCBvZiBhdCBsZWFzdCAyIHBvaW50cyc7XG5cdH1cblxuXHRjb25zdCBsaW5lV2lkdGggPSBzdHJva2VXaWR0aCAvIDI7XG5cdGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuXHRjb25zdCBub3JtYWxzID0gW107XG5cdGNvbnN0IG1pZGRsZVBvaW50cyA9IFtdOyAvLyBtaWRkbGUgcG9pbnRzIHBlciBlYWNoIGxpbmUgc2VnbWVudFxuXHRsZXQgY2xvc2VkID0gZmFsc2U7XG5cblx0aWYgKHBvaW50cy5sZW5ndGggPT09IDIpIHtcblxuXHRcdGNyZWF0ZVRyaWFuZ2xlcyhcblx0XHRcdHBvaW50c1swXSxcblx0XHRcdG1pZGRsZShwb2ludHNbMF0sIHBvaW50c1sxXSksXG5cdFx0XHRwb2ludHNbMV0sXG5cdFx0XHRwb3NpdGlvbnMsXG5cdFx0XHRub3JtYWxzLFxuXHRcdFx0bGluZVdpZHRoKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0aWYgKGVxdWFsKHBvaW50c1swXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSkpIHtcblx0XHRcdGNvbnN0IHAwID0gbWlkZGxlKHBvaW50cy5zaGlmdCgpLCBwb2ludHNbMF0pO1xuXHRcdFx0cG9pbnRzLnVuc2hpZnQocDApO1xuXHRcdFx0cG9pbnRzLnB1c2gocDApO1xuXHRcdFx0Y2xvc2VkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRmb3IgKGxldCBpPTA7IGk8cG9pbnRzLmxlbmd0aC0xOyBpKyspIHtcblx0XHRcdGlmIChpID09PSAwKSB7XG5cdFx0XHRcdG1pZGRsZVBvaW50cy5wdXNoKHBvaW50c1swXSk7XG5cdFx0XHR9IGVsc2UgaWYgKGkgPT09IHBvaW50cy5sZW5ndGggLSAyKSB7XG5cdFx0XHRcdG1pZGRsZVBvaW50cy5wdXNoKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWlkZGxlUG9pbnRzLnB1c2gobWlkZGxlKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAobGV0IGk9MTsgaTxtaWRkbGVQb2ludHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNyZWF0ZVRyaWFuZ2xlcyhcblx0XHRcdFx0bWlkZGxlUG9pbnRzW2kgLSAxXSxcblx0XHRcdFx0cG9pbnRzW2ldLFxuXHRcdFx0XHRtaWRkbGVQb2ludHNbaV0sXG5cdFx0XHRcdHBvc2l0aW9ucyxcblx0XHRcdFx0bm9ybWFscyxcblx0XHRcdFx0bGluZVdpZHRoKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIWNsb3NlZCkge1xuXG5cdFx0Ly8gc3RhcnQgY2FwXG5cdFx0bGV0IHAwID0gcG9pbnRzWzBdO1xuXHRcdGxldCBwMSA9IHBvaW50c1sxXTtcblx0XHRsZXQgdCA9IHBlcnBlbmRpY3VsYXIoc3ViKHAxLCBwMCkpO1xuXHRcdGNyZWF0ZVJvdW5kQ2FwKFxuXHRcdFx0cDAsXG5cdFx0XHRhZGQocDAsIHQpLFxuXHRcdFx0c3ViKHAwLCB0KSxcblx0XHRcdHAxLFxuXHRcdFx0cG9zaXRpb25zLFxuXHRcdFx0bm9ybWFscyk7XG5cblx0XHQvLyBlbmQgY2FwXG5cdFx0cDAgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuXHRcdHAxID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXTtcblx0XHR0ID0gcGVycGVuZGljdWxhcihzdWIocDEsIHAwKSk7XG5cdFx0Y3JlYXRlUm91bmRDYXAoXG5cdFx0XHRwMCxcblx0XHRcdGFkZChwMCwgdCksXG5cdFx0XHRzdWIocDAsIHQpLFxuXHRcdFx0cDEsXG5cdFx0XHRwb3NpdGlvbnMsXG5cdFx0XHRub3JtYWxzKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0cG9zaXRpb25zOiBwb3NpdGlvbnMsXG5cdFx0bm9ybWFsczogbm9ybWFsc1xuXHR9O1xufTtcblxuY29uc3QgY3JlYXRlUm91bmRDYXAgPSBmdW5jdGlvbihjZW50ZXIsIHAwLCBwMSwgbmV4dFBvaW50SW5MaW5lLCBwb3NpdGlvbnMsIG5vcm1hbHMpIHtcblxuXHRsZXQgYW5nbGUwID0gTWF0aC5hdGFuMigocDEueSAtIGNlbnRlci55KSwgKHAxLnggLSBjZW50ZXIueCkpO1xuXHRsZXQgYW5nbGUxID0gTWF0aC5hdGFuMigocDAueSAtIGNlbnRlci55KSwgKHAwLnggLSBjZW50ZXIueCkpO1xuXG5cdGNvbnN0IG9yZ0FuZ2xlMCA9IGFuZ2xlMDtcblxuXHRpZiAoYW5nbGUxID4gYW5nbGUwKSB7XG5cdFx0aWYgKGFuZ2xlMSAtIGFuZ2xlMCA+PSBNYXRoLlBJIC0gRVBTSUxPTikge1xuXHRcdFx0YW5nbGUxID0gYW5nbGUxIC0gKDIgKiBNYXRoLlBJKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYgKGFuZ2xlMCAtIGFuZ2xlMSA+PSBNYXRoLlBJIC0gRVBTSUxPTikge1xuXHRcdFx0YW5nbGUwID0gYW5nbGUwIC0gKDIgKiBNYXRoLlBJKTtcblx0XHR9XG5cdH1cblxuXHRsZXQgYW5nbGVEaWZmID0gYW5nbGUxIC0gYW5nbGUwO1xuXG5cdGlmIChNYXRoLmFicyhhbmdsZURpZmYpID49IChNYXRoLlBJIC0gRVBTSUxPTikgJiZcblx0XHRNYXRoLmFicyhhbmdsZURpZmYpIDw9IChNYXRoLlBJICsgRVBTSUxPTikpIHtcblx0XHRjb25zdCByMSA9IHN1YihjZW50ZXIsIG5leHRQb2ludEluTGluZSk7XG5cdFx0aWYgKHIxLnggPT09IDApIHtcblx0XHRcdGlmIChyMS55ID4gMCkge1xuXHRcdFx0XHRhbmdsZURpZmYgPSAtYW5nbGVEaWZmO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAocjEueCA+PSAtRVBTSUxPTikge1xuXHRcdFx0YW5nbGVEaWZmID0gLWFuZ2xlRGlmZjtcblx0XHR9XG5cdH1cblxuXHRjb25zdCBzZWdtZW50c1BlclNlbWkgPSAxNjtcblx0Y29uc3QgbnNlZ21lbnRzID0gTWF0aC5jZWlsKE1hdGguYWJzKGFuZ2xlRGlmZiAvIE1hdGguUEkpICogc2VnbWVudHNQZXJTZW1pKTtcblxuXHRjb25zdCBhbmdsZUluYyA9IGFuZ2xlRGlmZiAvIG5zZWdtZW50cztcblx0Y29uc3QgbjAgPSB7XG5cdFx0eDogMCxcblx0XHR5OiAwXG5cdH07XG5cblx0Zm9yIChsZXQgaT0wOyBpPG5zZWdtZW50czsgaSsrKSB7XG5cdFx0Y29uc3QgbjEgPSB7XG5cdFx0XHR4OiBNYXRoLmNvcyhvcmdBbmdsZTAgKyBhbmdsZUluYyAqIGkpLFxuXHRcdFx0eTogTWF0aC5zaW4ob3JnQW5nbGUwICsgYW5nbGVJbmMgKiBpKVxuXHRcdH07XG5cdFx0Y29uc3QgbjIgPSB7XG5cdFx0XHR4OiBNYXRoLmNvcyhvcmdBbmdsZTAgKyBhbmdsZUluYyAqICgxICsgaSkpLFxuXHRcdFx0eTogTWF0aC5zaW4ob3JnQW5nbGUwICsgYW5nbGVJbmMgKiAoMSArIGkpKVxuXHRcdH07XG5cdFx0cG9zaXRpb25zLnB1c2goY2VudGVyKTtcblx0XHRwb3NpdGlvbnMucHVzaChjZW50ZXIpO1xuXHRcdHBvc2l0aW9ucy5wdXNoKGNlbnRlcik7XG5cdFx0bm9ybWFscy5wdXNoKG4wKTtcblx0XHRub3JtYWxzLnB1c2gobjEpO1xuXHRcdG5vcm1hbHMucHVzaChuMik7XG5cdH1cbn07XG5cbmZ1bmN0aW9uIGxpbmVJbnRlcnNlY3Rpb24ocDAsIHAxLCBwMiwgcDMpIHtcblx0Y29uc3QgYTAgPSBwMS55IC0gcDAueTtcblx0Y29uc3QgYjAgPSBwMC54IC0gcDEueDtcblx0Y29uc3QgYTEgPSBwMy55IC0gcDIueTtcblx0Y29uc3QgYjEgPSBwMi54IC0gcDMueDtcblx0Y29uc3QgZGV0ID0gYTAgKiBiMSAtIGExICogYjA7XG5cdGlmIChkZXQgPiAtRVBTSUxPTiAmJiBkZXQgPCBFUFNJTE9OKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0Y29uc3QgYzAgPSBhMCAqIHAwLnggKyBiMCAqIHAwLnk7XG5cdGNvbnN0IGMxID0gYTEgKiBwMi54ICsgYjEgKiBwMi55O1xuXHRjb25zdCB4ID0gKGIxICogYzAgLSBiMCAqIGMxKSAvIGRldDtcblx0Y29uc3QgeSA9IChhMCAqIGMxIC0gYTEgKiBjMCkgLyBkZXQ7XG5cdHJldHVybiB7XG5cdFx0eDogeCxcblx0XHR5OiB5XG5cdH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyaWFuZ2xlcyhwMCwgcDEsIHAyLCBwb3NpdGlvbnMsIG5vcm1hbHMsIGxpbmVXaWR0aCkge1xuXHRsZXQgdDAgPSBzdWIocDEsIHAwKTtcblx0bGV0IHQyID0gc3ViKHAyLCBwMSk7XG5cblx0dDAgPSBwZXJwZW5kaWN1bGFyKHQwKTtcblx0dDIgPSBwZXJwZW5kaWN1bGFyKHQyKTtcblxuXHQvLyB0cmlhbmdsZSBjb21wb3NlZCBieSB0aGUgMyBwb2ludHMgaWYgY2xvY2t3aXNlIG9yIGNvdW50ZXItY2xvY2t3aXNlLlxuXHQvLyBpZiBjb3VudGVyLWNsb2Nrd2lzZSwgd2UgbXVzdCBpbnZlcnQgdGhlIGxpbmUgdGhyZXNob2xkIHBvaW50cywgb3RoZXJ3aXNlXG5cdC8vIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgY291bGQgYmUgZXJyb25lb3VzIGFuZCBsZWFkIHRvIG9kZCByZXN1bHRzLlxuXHRpZiAoc2lnbmVkQXJlYShwMCwgcDEsIHAyKSA+IDApIHtcblx0XHR0MCA9IGludmVydCh0MCk7XG5cdFx0dDIgPSBpbnZlcnQodDIpO1xuXHR9XG5cblx0dDAgPSBub3JtYWxpemUodDApO1xuXHR0MiA9IG5vcm1hbGl6ZSh0Mik7XG5cdHQwID0gc2NhbGFyTXVsdCh0MCwgbGluZVdpZHRoKTtcblx0dDIgPSBzY2FsYXJNdWx0KHQyLCBsaW5lV2lkdGgpO1xuXG5cdGNvbnN0IHBpbnRlcnNlY3QgPSBsaW5lSW50ZXJzZWN0aW9uKFxuXHRcdGFkZCh0MCwgcDApLFxuXHRcdGFkZCh0MCwgcDEpLFxuXHRcdGFkZCh0MiwgcDIpLFxuXHRcdGFkZCh0MiwgcDEpKTtcblxuXHRsZXQgYW5jaG9yID0gbnVsbDtcblx0bGV0IGFuY2hvckxlbmd0aCA9IE51bWJlci5NQVhfVkFMVUU7XG5cdGxldCBpYW4gPSBudWxsO1xuXHRpZiAocGludGVyc2VjdCkge1xuXHRcdGFuY2hvciA9IHN1YihwaW50ZXJzZWN0LCBwMSk7XG5cdFx0YW5jaG9yTGVuZ3RoID0gbGVuZ3RoKGFuY2hvcik7XG5cdFx0aWFuID0gaW52ZXJ0KHNjYWxhck11bHQoYW5jaG9yLCAxLjAgLyBsaW5lV2lkdGgpKTtcblx0fVxuXHRjb25zdCBwMHAxID0gc3ViKHAwLCBwMSk7XG5cdGNvbnN0IHAwcDFMZW5ndGggPSBsZW5ndGgocDBwMSk7XG5cdGNvbnN0IHAxcDIgPSBzdWIocDEsIHAyKTtcblx0Y29uc3QgcDFwMkxlbmd0aCA9IGxlbmd0aChwMXAyKTtcblxuXHRjb25zdCBuMCA9IG5vcm1hbGl6ZSh0MCk7XG5cdGNvbnN0IGluMCA9IGludmVydChuMCk7XG5cdGNvbnN0IG4yID0gbm9ybWFsaXplKHQyKTtcblx0Y29uc3QgaW4yID0gaW52ZXJ0KG4yKTtcblxuXHQvLyB0aGUgY3Jvc3MgcG9pbnQgZXhjZWVkcyBhbnkgb2YgdGhlIHNlZ21lbnRzIGRpbWVuc2lvbi5cblx0Ly8gZG8gbm90IHVzZSBjcm9zcyBwb2ludCBhcyByZWZlcmVuY2UuXG5cdGlmIChhbmNob3JMZW5ndGggPiBwMHAxTGVuZ3RoIHx8IGFuY2hvckxlbmd0aCA+IHAxcDJMZW5ndGgpIHtcblxuXHRcdHBvc2l0aW9ucy5wdXNoKHAwKTtcblx0XHRwb3NpdGlvbnMucHVzaChwMCk7XG5cdFx0cG9zaXRpb25zLnB1c2gocDEpO1xuXG5cdFx0bm9ybWFscy5wdXNoKG4wKTtcblx0XHRub3JtYWxzLnB1c2goaW4wKTtcblx0XHRub3JtYWxzLnB1c2gobjApO1xuXG5cdFx0cG9zaXRpb25zLnB1c2gocDApO1xuXHRcdHBvc2l0aW9ucy5wdXNoKHAxKTtcblx0XHRwb3NpdGlvbnMucHVzaChwMSk7XG5cblx0XHRub3JtYWxzLnB1c2goaW4wKTtcblx0XHRub3JtYWxzLnB1c2gobjApO1xuXHRcdG5vcm1hbHMucHVzaChpbjApO1xuXG5cdFx0Y3JlYXRlUm91bmRDYXAoXG5cdFx0XHRwMSxcblx0XHRcdGFkZChwMSwgdDApLFxuXHRcdFx0YWRkKHAxLCB0MiksXG5cdFx0XHRwMixcblx0XHRcdHBvc2l0aW9ucyxcblx0XHRcdG5vcm1hbHMpO1xuXG5cdFx0cG9zaXRpb25zLnB1c2gocDIpO1xuXHRcdHBvc2l0aW9ucy5wdXNoKHAxKTtcblx0XHRwb3NpdGlvbnMucHVzaChwMSk7XG5cblx0XHRub3JtYWxzLnB1c2gobjIpO1xuXHRcdG5vcm1hbHMucHVzaChpbjIpO1xuXHRcdG5vcm1hbHMucHVzaChuMik7XG5cblx0XHRwb3NpdGlvbnMucHVzaChwMik7XG5cdFx0cG9zaXRpb25zLnB1c2gocDEpO1xuXHRcdHBvc2l0aW9ucy5wdXNoKHAyKTtcblxuXHRcdG5vcm1hbHMucHVzaChuMik7XG5cdFx0bm9ybWFscy5wdXNoKGluMik7XG5cdFx0bm9ybWFscy5wdXNoKGluMik7XG5cblx0fSBlbHNlIHtcblxuXHRcdHBvc2l0aW9ucy5wdXNoKHAwKTtcblx0XHRwb3NpdGlvbnMucHVzaChwMCk7XG5cdFx0cG9zaXRpb25zLnB1c2gocDEpO1xuXG5cdFx0bm9ybWFscy5wdXNoKG4wKTtcblx0XHRub3JtYWxzLnB1c2goaW4wKTtcblx0XHRub3JtYWxzLnB1c2goaWFuKTtcblxuXHRcdHBvc2l0aW9ucy5wdXNoKHAwKTtcblx0XHRwb3NpdGlvbnMucHVzaChwMSk7XG5cdFx0cG9zaXRpb25zLnB1c2gocDEpO1xuXG5cdFx0bm9ybWFscy5wdXNoKG4wKTtcblx0XHRub3JtYWxzLnB1c2goaWFuKTtcblx0XHRub3JtYWxzLnB1c2gobjApO1xuXG5cdFx0cG9zaXRpb25zLnB1c2gocDEpO1xuXHRcdHBvc2l0aW9ucy5wdXNoKHAxKTtcblx0XHRwb3NpdGlvbnMucHVzaChwMSk7XG5cblx0XHRub3JtYWxzLnB1c2gobjApO1xuXHRcdG5vcm1hbHMucHVzaCh7IHg6IDAsIHk6IDAgfSk7XG5cdFx0bm9ybWFscy5wdXNoKGlhbik7XG5cblx0XHRjcmVhdGVSb3VuZENhcChcblx0XHRcdHAxLFxuXHRcdFx0YWRkKHAxLCB0MCksXG5cdFx0XHRhZGQocDEsIHQyKSxcblx0XHRcdHN1YihwMSwgYW5jaG9yKSxcblx0XHRcdHBvc2l0aW9ucyxcblx0XHRcdG5vcm1hbHMpO1xuXG5cdFx0cG9zaXRpb25zLnB1c2gocDEpO1xuXHRcdHBvc2l0aW9ucy5wdXNoKHAxKTtcblx0XHRwb3NpdGlvbnMucHVzaChwMSk7XG5cblx0XHRub3JtYWxzLnB1c2goeyB4OiAwLCB5OiAwIH0pO1xuXHRcdG5vcm1hbHMucHVzaChuMik7XG5cdFx0bm9ybWFscy5wdXNoKGlhbik7XG5cblx0XHRwb3NpdGlvbnMucHVzaChwMik7XG5cdFx0cG9zaXRpb25zLnB1c2gocDEpO1xuXHRcdHBvc2l0aW9ucy5wdXNoKHAxKTtcblxuXHRcdG5vcm1hbHMucHVzaChuMik7XG5cdFx0bm9ybWFscy5wdXNoKGlhbik7XG5cdFx0bm9ybWFscy5wdXNoKG4yKTtcblxuXHRcdHBvc2l0aW9ucy5wdXNoKHAyKTtcblx0XHRwb3NpdGlvbnMucHVzaChwMSk7XG5cdFx0cG9zaXRpb25zLnB1c2gocDIpO1xuXG5cdFx0bm9ybWFscy5wdXNoKG4yKTtcblx0XHRub3JtYWxzLnB1c2goaWFuKTtcblx0XHRub3JtYWxzLnB1c2goaW4yKTtcblx0fVxufVxuXG5jb25zdCBidWZmZXJQb2x5bGluZSA9IGZ1bmN0aW9uKHBvaW50cywgbm9ybWFscykge1xuXHRjb25zdCBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiA0KTtcblx0Zm9yIChsZXQgaT0wOyBpPHBvaW50cy5sZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuXHRcdGNvbnN0IG5vcm1hbCA9IG5vcm1hbHNbaV07XG5cdFx0YnVmZmVyW2kqNF0gPSBwb2ludC54O1xuXHRcdGJ1ZmZlcltpKjQrMV0gPSBwb2ludC55O1xuXHRcdGJ1ZmZlcltpKjQrMl0gPSBub3JtYWwueDtcblx0XHRidWZmZXJbaSo0KzNdID0gbm9ybWFsLnk7XG5cdH1cblx0cmV0dXJuIGJ1ZmZlcjtcbn07XG5cbmNvbnN0IGNyZWF0ZVZlcnRleEJ1ZmZlciA9IGZ1bmN0aW9uKG92ZXJsYXksIHBvaW50cykge1xuXHRjb25zdCBsaW5lV2lkdGggPSBvdmVybGF5LmxpbmVXaWR0aDtcblx0Y29uc3QgZ2VvbWV0cnkgPSBnZXRTdHJva2VHZW9tZXRyeShwb2ludHMsIGxpbmVXaWR0aCk7XG5cdGNvbnN0IGRhdGEgPSBidWZmZXJQb2x5bGluZShnZW9tZXRyeS5wb3NpdGlvbnMsIGdlb21ldHJ5Lm5vcm1hbHMpO1xuXHRyZXR1cm4gbmV3IFZlcnRleEJ1ZmZlcihcblx0XHRvdmVybGF5LmdsLFxuXHRcdGRhdGEsXG5cdFx0e1xuXHRcdFx0MDoge1xuXHRcdFx0XHRzaXplOiAyLFxuXHRcdFx0XHR0eXBlOiAnRkxPQVQnLFxuXHRcdFx0XHRieXRlT2Zmc2V0OiAwXG5cdFx0XHR9LFxuXHRcdFx0MToge1xuXHRcdFx0XHRzaXplOiAyLFxuXHRcdFx0XHR0eXBlOiAnRkxPQVQnLFxuXHRcdFx0XHRieXRlT2Zmc2V0OiAyICogNFxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0bW9kZTogJ1RSSUFOR0xFUycsXG5cdFx0XHRjb3VudDogZ2VvbWV0cnkucG9zaXRpb25zLmxlbmd0aFxuXHRcdH0pO1xufTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSB3ZWJnbCBwb2x5bGluZSBvdmVybGF5IHJlbmRlcmVyLlxuICovXG5jbGFzcyBQb2x5bGluZU92ZXJsYXlSZW5kZXJlciBleHRlbmRzIFdlYkdMT3ZlcmxheVJlbmRlcmVyIHtcblxuXHQvKipcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IFBvbHlsaW5lT3ZlcmxheVJlbmRlcmVyIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3ZlcmxheSBvcHRpb25zLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLmxpbmVDb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgbGluZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubGluZVdpZHRoIC0gVGhlIHBpeGVsIHdpZHRoIG9mIHRoZSBsaW5lLlxuXHQgKi9cblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cdFx0dGhpcy5saW5lQ29sb3IgPSBkZWZhdWx0VG8ob3B0aW9ucy5saW5lQ29sb3IsIFsgMS4wLCAwLjQsIDAuMSwgMC44IF0pO1xuXHRcdHRoaXMubGluZVdpZHRoID0gZGVmYXVsdFRvKG9wdGlvbnMubGluZVdpZHRoLCAyKTtcblx0XHR0aGlzLnNoYWRlciA9IG51bGw7XG5cdFx0dGhpcy5saW5lcyA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgb3ZlcmxheSBpcyBhdHRhY2hlZCB0byBhIHBsb3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UGxvdH0gcGxvdCAtIFRoZSBwbG90IHRvIGF0dGFjaCB0aGUgb3ZlcmxheSB0by5cblx0ICpcblx0ICogQHJldHVybnMge1BvbHlsaW5lT3ZlcmxheVJlbmRlcmVyfSBUaGUgb3ZlcmxheSBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdG9uQWRkKHBsb3QpIHtcblx0XHRzdXBlci5vbkFkZChwbG90KTtcblx0XHR0aGlzLnNoYWRlciA9IHRoaXMuY3JlYXRlU2hhZGVyKFNIQURFUl9HTFNMKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBFeGVjdXRlZCB3aGVuIHRoZSBvdmVybGF5IGlzIHJlbW92ZWQgZnJvbSBhIHBsb3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7UGxvdH0gcGxvdCAtIFRoZSBwbG90IHRvIHJlbW92ZSB0aGUgb3ZlcmxheSBmcm9tLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UG9seWxpbmVPdmVybGF5UmVuZGVyZXJ9IFRoZSBvdmVybGF5IG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0b25SZW1vdmUocGxvdCkge1xuXHRcdHN1cGVyLm9uUmVtb3ZlKHBsb3QpO1xuXHRcdHRoaXMuc2hhZGVyID0gbnVsbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBhbnkgdW5kZXJseWluZyBidWZmZXJzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UG9seWxpbmVPdmVybGF5UmVuZGVyZXJ9IFRoZSBvdmVybGF5IG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0cmVmcmVzaEJ1ZmZlcnMoKSB7XG5cdFx0Y29uc3QgY2xpcHBlZCA9IHRoaXMub3ZlcmxheS5nZXRDbGlwcGVkR2VvbWV0cnkoKTtcblx0XHRpZiAoY2xpcHBlZCkge1xuXHRcdFx0dGhpcy5saW5lcyA9IGNsaXBwZWQubWFwKHBvaW50cyA9PiB7XG5cdFx0XHRcdC8vIGdlbmVyYXRlIHRoZSBidWZmZXJcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZVZlcnRleEJ1ZmZlcih0aGlzLCBwb2ludHMpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubGluZXMgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgZHJhdyBmdW5jdGlvbiB0aGF0IGlzIGV4ZWN1dGVkIHBlciBmcmFtZS5cblx0ICpcblx0ICogQHJldHVybnMge1BvbHlsaW5lT3ZlcmxheVJlbmRlcmVyfSBUaGUgb3ZlcmxheSBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdGRyYXcoKSB7XG5cdFx0aWYgKCF0aGlzLmxpbmVzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XG5cdFx0Y29uc3Qgc2hhZGVyID0gdGhpcy5zaGFkZXI7XG5cdFx0Y29uc3QgbGluZXMgPSB0aGlzLmxpbmVzO1xuXHRcdGNvbnN0IHBsb3QgPSB0aGlzLm92ZXJsYXkucGxvdDtcblx0XHRjb25zdCBjZWxsID0gcGxvdC5jZWxsO1xuXHRcdGNvbnN0IHByb2ogPSB0aGlzLmdldE9ydGhvTWF0cml4KCk7XG5cdFx0Y29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCBwbG90Lnpvb20gLSBjZWxsLnpvb20pO1xuXHRcdGNvbnN0IG9wYWNpdHkgPSB0aGlzLm92ZXJsYXkub3BhY2l0eTtcblxuXHRcdC8vIGdldCB2aWV3IG9mZnNldCBpbiBjZWxsIHNwYWNlXG5cdFx0Y29uc3Qgb2Zmc2V0ID0gY2VsbC5wcm9qZWN0KHBsb3Qudmlld3BvcnQsIHBsb3Quem9vbSk7XG5cblx0XHQvLyBzZXQgYmxlbmRpbmcgZnVuY1xuXHRcdGdsLmVuYWJsZShnbC5CTEVORCk7XG5cdFx0Z2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG5cblx0XHQvLyBiaW5kIHNoYWRlclxuXHRcdHNoYWRlci51c2UoKTtcblxuXHRcdC8vIHNldCBnbG9iYWwgdW5pZm9ybXNcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVByb2plY3Rpb25NYXRyaXgnLCBwcm9qKTtcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVZpZXdPZmZzZXQnLCBbIG9mZnNldC54LCBvZmZzZXQueSBdKTtcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVNjYWxlJywgc2NhbGUpO1xuXHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1TGluZVdpZHRoJywgdGhpcy5saW5lV2lkdGggLyAyKTtcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndUxpbmVDb2xvcicsIHRoaXMubGluZUNvbG9yKTtcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndU9wYWNpdHknLCBvcGFjaXR5KTtcblxuXHRcdC8vIGZvciBlYWNoIHBvbHlsaW5lIGJ1ZmZlclxuXHRcdGxpbmVzLmZvckVhY2goYnVmZmVyID0+IHtcblx0XHRcdC8vIGRyYXcgdGhlIHBvaW50c1xuXHRcdFx0YnVmZmVyLmJpbmQoKTtcblx0XHRcdGJ1ZmZlci5kcmF3KCk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbHlsaW5lT3ZlcmxheVJlbmRlcmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBQcml2YXRlIE1ldGhvZHNcblxuY29uc3QgZ2V0VVZPZmZzZXQgPSBmdW5jdGlvbihhbmNlc3RvciwgZGVzY2VuZGFudCkge1xuXHRjb25zdCBzY2FsZSA9IDEgLyBNYXRoLnBvdygyLCBkZXNjZW5kYW50LnogLSBhbmNlc3Rvci56KTtcblx0cmV0dXJuIFtcblx0XHQoZGVzY2VuZGFudC54ICogc2NhbGUpIC0gYW5jZXN0b3IueCxcblx0XHQoZGVzY2VuZGFudC55ICogc2NhbGUpIC0gYW5jZXN0b3IueSxcblx0XHRzY2FsZSxcblx0XHRzY2FsZVxuXHRdO1xufTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSB0aWxlIHJlbmRlcmFibGUuXG4gKi9cbmNsYXNzIFRpbGVSZW5kZXJhYmxlIHtcblxuXHQvKipcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IFRpbGVSZW5kZXJhYmxlIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtUaWxlfSB0aWxlIC0gVGhlIHRpbGUgZGF0YSB0byBiZSByZW5kZXJlZC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIC0gVGhlIHNjYWxlIHRvIHJlbmRlciB0aGUgdGlsZSBhdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IHRpbGVPZmZzZXQgLSBUaGUgdGlsZSBwaXhlbCBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlxuXHQgKiBAcGFyYW0ge0FycmF5fSB1dk9mZnNldCAtIFRoZSB0ZXh0dXJlIGNvb3JkaW5hdGUgb2Zmc2V0IGRlc2NyaWJpbmcgdGhlIHBvcnRpb24gb2YgdGhlIHRpbGUgdG8gcmVuZGVyLlxuXHQgKi9cblx0Y29uc3RydWN0b3IodGlsZSwgc2NhbGUsIHRpbGVPZmZzZXQsIHV2T2Zmc2V0KSB7XG5cdFx0dGhpcy50aWxlID0gdGlsZTtcblx0XHR0aGlzLmhhc2ggPSB0aWxlLmNvb3JkLmhhc2g7XG5cdFx0dGhpcy5zY2FsZSA9IHNjYWxlO1xuXHRcdHRoaXMudGlsZU9mZnNldCA9IHRpbGVPZmZzZXQ7XG5cdFx0dGhpcy51dk9mZnNldCA9IHV2T2Zmc2V0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlIGEgVGlsZVJlbmRlcmFibGUgb2JqZWN0IGZyb20gYSBzcGVjaWZpYyB0aWxlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1RpbGV9IHRpbGUgLSBUaGUgdGlsZSBkYXRhIHRvIGJlIHJlbmRlcmVkLlxuXHQgKiBAcGFyYW0ge1RpbGVDb29yZH0gY29vcmQgLSBUaGUgdW5ub3JtYWxpemVkIHRpbGUgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIC0gVGhlIHNjYWxlIHRvIHJlbmRlciB0aGUgdGlsZSBhdC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbGVTaXplIC0gVGhlIHNpemUgb2YgdGhlIHRpbGUgaW4gcGl4ZWxzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmlld3BvcnRPZmZzZXQgLSBUaGUgb2Zmc2V0IG9mIHRoZSB2aWV3cG9ydCBpbiBwaXhlbHMuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtUaWxlUmVuZGVyYWJsZX0gVGhlIHJlbmRlcmFibGUgb2JqZWN0LlxuXHQgKi9cblx0c3RhdGljIGZyb21UaWxlKHRpbGUsIGNvb3JkLCBzY2FsZSwgdGlsZVNpemUsIHZpZXdwb3J0T2Zmc2V0KSB7XG5cdFx0Y29uc3Qgc2NhbGVkVGlsZVNpemUgPSBzY2FsZSAqIHRpbGVTaXplO1xuXHRcdGNvbnN0IHRpbGVPZmZzZXQgPSBbXG5cdFx0XHQoY29vcmQueCAqIHNjYWxlZFRpbGVTaXplKSAtIHZpZXdwb3J0T2Zmc2V0LngsXG5cdFx0XHQoY29vcmQueSAqIHNjYWxlZFRpbGVTaXplKSAtIHZpZXdwb3J0T2Zmc2V0Lnlcblx0XHRdO1xuXHRcdHJldHVybiBuZXcgVGlsZVJlbmRlcmFibGUoXG5cdFx0XHR0aWxlLFxuXHRcdFx0c2NhbGUsXG5cdFx0XHR0aWxlT2Zmc2V0LFxuXHRcdFx0WyAwLCAwLCAxLCAxIF0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlIGEgVGlsZVJlbmRlcmFibGUgb2JqZWN0IGZyb20gYW4gYW5jZXN0b3Igb2YgdGhlIHRpbGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VGlsZX0gdGlsZSAtIFRoZSB0aWxlIGRhdGEgdG8gYmUgcmVuZGVyZWQuXG5cdCAqIEBwYXJhbSB7VGlsZUNvb3JkfSBjb29yZCAtIFRoZSB1bm5vcm1hbGl6ZWQgdGlsZSBjb29yZGluYXRlIG9mIHRoZSB0aWxlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2NhbGUgLSBUaGUgc2NhbGUgdG8gcmVuZGVyIHRoZSB0aWxlIGF0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGlsZVNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgdGlsZSBpbiBwaXhlbHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2aWV3cG9ydE9mZnNldCAtIFRoZSBvZmZzZXQgb2YgdGhlIHZpZXdwb3J0IGluIHBpeGVscy5cblx0ICogQHBhcmFtIHtUaWxlQ29vcmR9IHdhbnRlZCAtIFRoZSBjb29yZGluYXRlIHRoZSB0aWxlIHdpbGwgc3Vic3RpdHVlIGZvci5cblx0ICogQHBhcmFtIHtUaWxlQ29vcmR9IGRlc2NlbmRhbnQgLSBUaGUgZGlyZWN0IGRlc2NlbmRhbnQgb2YgdGhlIHN1YnN0aXR1dGVkIHRpbGUuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtUaWxlUmVuZGVyYWJsZX0gVGhlIHJlbmRlcmFibGUgb2JqZWN0LlxuXHQgKi9cblx0c3RhdGljIGZyb21BbmNlc3Rvcih0aWxlLCBjb29yZCwgc2NhbGUsIHRpbGVTaXplLCB2aWV3cG9ydE9mZnNldCwgd2FudGVkLCBkZXNjZW5kYW50KSB7XG5cdFx0Y29uc3Qgc2NhbGVkVGlsZVNpemUgPSBzY2FsZSAqIHRpbGVTaXplO1xuXHRcdGNvbnN0IHRpbGVPZmZzZXQgPSBbIDAsIDAgXTtcblx0XHRpZiAoZGVzY2VuZGFudCA9PT0gd2FudGVkKSB7XG5cdFx0XHQvLyBpZiB0aGUgXCJ3YW50ZWRcIiB0aWxlIGlzIHRoZSBzYW1lIGFzIHRoZSBcImRlc2NlbmRhbnRcIiBvZiB0aGlzXG5cdFx0XHQvLyBhbmNlc3RvciwgdGhlbiB0aGVyZSBpcyBubyBwb3NpdGlvbmFsIG9mZnNldFxuXHRcdFx0dGlsZU9mZnNldFswXSA9IChjb29yZC54ICogc2NhbGVkVGlsZVNpemUpIC0gdmlld3BvcnRPZmZzZXQueDtcblx0XHRcdHRpbGVPZmZzZXRbMV0gPSAoY29vcmQueSAqIHNjYWxlZFRpbGVTaXplKSAtIHZpZXdwb3J0T2Zmc2V0Lnk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGlmIHRoZSBcIndhbnRlZFwiIHRpbGUgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBcImRlc2NlbmRhbnRcIiwgd2UgbmVlZFxuXHRcdFx0Ly8gdG8gcG9zaXRpb24gYW5kIHNjYWxlIHRoaXMgdGlsZSByZWxhdGl2ZSB0byB0aGUgZGVzY2VuZGFudFxuXHRcdFx0Y29uc3Qgb2Zmc2V0U2NhbGUgPSAxIC8gTWF0aC5wb3coMiwgZGVzY2VuZGFudC56IC0gd2FudGVkLnopO1xuXHRcdFx0Y29uc3Qgb2Zmc2V0WCA9IChkZXNjZW5kYW50LnggKiBvZmZzZXRTY2FsZSkgLSB3YW50ZWQueDtcblx0XHRcdGNvbnN0IG9mZnNldFkgPSAoZGVzY2VuZGFudC55ICogb2Zmc2V0U2NhbGUpIC0gd2FudGVkLnk7XG5cdFx0XHR0aWxlT2Zmc2V0WzBdID0gKChjb29yZC54ICsgb2Zmc2V0WCkgKiBzY2FsZWRUaWxlU2l6ZSkgLSB2aWV3cG9ydE9mZnNldC54O1xuXHRcdFx0dGlsZU9mZnNldFsxXSA9ICgoY29vcmQueSArIG9mZnNldFkpICogc2NhbGVkVGlsZVNpemUpIC0gdmlld3BvcnRPZmZzZXQueTtcblx0XHRcdHNjYWxlICo9IG9mZnNldFNjYWxlO1xuXHRcdH1cblx0XHRyZXR1cm4gbmV3IFRpbGVSZW5kZXJhYmxlKFxuXHRcdFx0dGlsZSxcblx0XHRcdHNjYWxlLFxuXHRcdFx0dGlsZU9mZnNldCxcblx0XHRcdGdldFVWT2Zmc2V0KHRpbGUuY29vcmQsIGRlc2NlbmRhbnQpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZSBhIFRpbGVSZW5kZXJhYmxlIG9iamVjdCBmcm9tIGEgZGVzY2VuZGFudCBvZiB0aGUgdGlsZS5cblx0ICpcblx0ICogQHBhcmFtIHtUaWxlfSB0aWxlIC0gVGhlIHRpbGUgZGF0YSB0byBiZSByZW5kZXJlZC5cblx0ICogQHBhcmFtIHtUaWxlQ29vcmR9IGNvb3JkIC0gVGhlIHVubm9ybWFsaXplZCB0aWxlIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAtIFRoZSBzY2FsZSB0byByZW5kZXIgdGhlIHRpbGUgYXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aWxlU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSB0aWxlIGluIHBpeGVscy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHZpZXdwb3J0T2Zmc2V0IC0gVGhlIG9mZnNldCBvZiB0aGUgdmlld3BvcnQgaW4gcGl4ZWxzLlxuXHQgKiBAcGFyYW0ge1RpbGVDb29yZH0gd2FudGVkIC0gVGhlIGNvb3JkaW5hdGUgdGhlIHRpbGUgd2lsbCBzdWJzdGl0dWUgZm9yLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7VGlsZVJlbmRlcmFibGV9IFRoZSByZW5kZXJhYmxlIG9iamVjdC5cblx0ICovXG5cdHN0YXRpYyBmcm9tRGVzY2VuZGFudCh0aWxlLCBjb29yZCwgc2NhbGUsIHRpbGVTaXplLCB2aWV3cG9ydE9mZnNldCwgd2FudGVkKSB7XG5cdFx0Y29uc3Qgc2NhbGVkVGlsZVNpemUgPSBzY2FsZSAqIHRpbGVTaXplO1xuXHRcdGNvbnN0IG9mZnNldFNjYWxlID0gMSAvIE1hdGgucG93KDIsIHRpbGUuY29vcmQueiAtIHdhbnRlZC56KTtcblx0XHRjb25zdCBvZmZzZXRYID0gKHRpbGUuY29vcmQueCAqIG9mZnNldFNjYWxlKSAtIHdhbnRlZC54O1xuXHRcdGNvbnN0IG9mZnNldFkgPSAodGlsZS5jb29yZC55ICogb2Zmc2V0U2NhbGUpIC0gd2FudGVkLnk7XG5cdFx0Y29uc3QgdGlsZU9mZnNldCA9IFtcblx0XHRcdCgoY29vcmQueCArIG9mZnNldFgpICogc2NhbGVkVGlsZVNpemUpIC0gdmlld3BvcnRPZmZzZXQueCxcblx0XHRcdCgoY29vcmQueSArIG9mZnNldFkpICogc2NhbGVkVGlsZVNpemUpIC0gdmlld3BvcnRPZmZzZXQueVxuXHRcdF07XG5cdFx0cmV0dXJuIG5ldyBUaWxlUmVuZGVyYWJsZShcblx0XHRcdHRpbGUsXG5cdFx0XHRzY2FsZSAqIG9mZnNldFNjYWxlLFxuXHRcdFx0dGlsZU9mZnNldCxcblx0XHRcdFsgMCwgMCwgMSwgMSBdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZSBhIFRpbGVSZW5kZXJhYmxlIG9iamVjdCBmcm9tIGFuIGFuY2VzdG9yIG9mIHRoZSB0aWxlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1RpbGVQYXJ0aWFsfSBwYXJ0aWFsIC0gVGhlIHRpbGUgcGFydGlhbCB0byBiZSByZW5kZXJlZC5cblx0ICogQHBhcmFtIHtUaWxlQ29vcmR9IGNvb3JkIC0gVGhlIHVubm9ybWFsaXplZCB0aWxlIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAtIFRoZSBzY2FsZSB0byByZW5kZXIgdGhlIHRpbGUgYXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aWxlU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSB0aWxlIGluIHBpeGVscy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHZpZXdwb3J0T2Zmc2V0IC0gVGhlIG9mZnNldCBvZiB0aGUgdmlld3BvcnQgaW4gcGl4ZWxzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7VGlsZVJlbmRlcmFibGV9IFRoZSByZW5kZXJhYmxlIG9iamVjdC5cblx0ICovXG5cdHN0YXRpYyBmcm9tQW5jZXN0b3JQYXJ0aWFsKHBhcnRpYWwsIGNvb3JkLCBzY2FsZSwgdGlsZVNpemUsIHZpZXdwb3J0T2Zmc2V0KSB7XG5cdFx0Y29uc3QgdGlsZSA9IHBhcnRpYWwudGlsZTsgLy8gdGlsZSB3ZSBoYXZlXG5cdFx0Y29uc3QgdGFyZ2V0ID0gcGFydGlhbC50YXJnZXQ7IC8vIHRpbGUgd2Ugd2FudGVkXG5cdFx0Y29uc3QgcmVsYXRpdmUgPSBwYXJ0aWFsLnJlbGF0aXZlOyAvLyB3aGVyZSB0byBwb3NpdGlvbiB0aGUgdGlsZSByZWxhdGl2ZSB0b1xuXHRcdGNvbnN0IHNjYWxlZFRpbGVTaXplID0gc2NhbGUgKiB0aWxlU2l6ZTtcblx0XHRjb25zdCB0aWxlT2Zmc2V0ID0gWyAwLCAwIF07XG5cdFx0aWYgKHJlbGF0aXZlID09PSBwYXJ0aWFsLnRhcmdldCkge1xuXHRcdFx0Ly8gaWYgdGhlIFwidGFyZ2V0XCIgdGlsZSBpcyB0aGUgc2FtZSBhcyB0aGUgXCJyZWxhdGl2ZVwiIG9mIHRoaXNcblx0XHRcdC8vIGFuY2VzdG9yLCB0aGVuIHRoZXJlIGlzIG5vIHBvc2l0aW9uYWwgb2Zmc2V0XG5cdFx0XHR0aWxlT2Zmc2V0WzBdID0gKGNvb3JkLnggKiBzY2FsZWRUaWxlU2l6ZSkgLSB2aWV3cG9ydE9mZnNldC54O1xuXHRcdFx0dGlsZU9mZnNldFsxXSA9IChjb29yZC55ICogc2NhbGVkVGlsZVNpemUpIC0gdmlld3BvcnRPZmZzZXQueTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaWYgdGhlIFwidGFyZ2V0XCIgdGlsZSBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIFwicmVsYXRpdmVcIiwgd2UgbmVlZFxuXHRcdFx0Ly8gdG8gcG9zaXRpb24gYW5kIHNjYWxlIHRoaXMgdGlsZSByZWxhdGl2ZSB0byB0aGUgcmVsYXRpdmVcblx0XHRcdGNvbnN0IG9mZnNldFNjYWxlID0gMSAvIE1hdGgucG93KDIsIHJlbGF0aXZlLnogLSB0YXJnZXQueik7XG5cdFx0XHRjb25zdCBvZmZzZXRYID0gKHJlbGF0aXZlLnggKiBvZmZzZXRTY2FsZSkgLSB0YXJnZXQueDtcblx0XHRcdGNvbnN0IG9mZnNldFkgPSAocmVsYXRpdmUueSAqIG9mZnNldFNjYWxlKSAtIHRhcmdldC55O1xuXHRcdFx0dGlsZU9mZnNldFswXSA9ICgoY29vcmQueCArIG9mZnNldFgpICogc2NhbGVkVGlsZVNpemUpIC0gdmlld3BvcnRPZmZzZXQueDtcblx0XHRcdHRpbGVPZmZzZXRbMV0gPSAoKGNvb3JkLnkgKyBvZmZzZXRZKSAqIHNjYWxlZFRpbGVTaXplKSAtIHZpZXdwb3J0T2Zmc2V0Lnk7XG5cdFx0XHRzY2FsZSAqPSBvZmZzZXRTY2FsZTtcblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBUaWxlUmVuZGVyYWJsZShcblx0XHRcdHRpbGUsXG5cdFx0XHRzY2FsZSxcblx0XHRcdHRpbGVPZmZzZXQsXG5cdFx0XHRnZXRVVk9mZnNldCh0aWxlLmNvb3JkLCByZWxhdGl2ZSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlIGEgVGlsZVJlbmRlcmFibGUgb2JqZWN0IGZyb20gYSBkZXNjZW5kYW50IG9mIHRoZSB0aWxlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1RpbGVQYXJ0aWFsfSBwYXJ0aWFsIC0gVGhlIHRpbGUgcGFydGlhbCB0byBiZSByZW5kZXJlZC5cblx0ICogQHBhcmFtIHtUaWxlQ29vcmR9IGNvb3JkIC0gVGhlIHVubm9ybWFsaXplZCB0aWxlIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAtIFRoZSBzY2FsZSB0byByZW5kZXIgdGhlIHRpbGUgYXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aWxlU2l6ZSAtIFRoZSBzaXplIG9mIHRoZSB0aWxlIGluIHBpeGVscy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHZpZXdwb3J0T2Zmc2V0IC0gVGhlIG9mZnNldCBvZiB0aGUgdmlld3BvcnQgaW4gcGl4ZWxzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7VGlsZVJlbmRlcmFibGV9IFRoZSByZW5kZXJhYmxlIG9iamVjdC5cblx0ICovXG5cdHN0YXRpYyBmcm9tRGVzY2VuZGFudFBhcnRpYWwocGFydGlhbCwgY29vcmQsIHNjYWxlLCB0aWxlU2l6ZSwgdmlld3BvcnRPZmZzZXQpIHtcblx0XHRjb25zdCB0aWxlID0gcGFydGlhbC50aWxlOyAvLyB0aWxlIHdlIGhhdmVcblx0XHRjb25zdCB0YXJnZXQgPSBwYXJ0aWFsLnRhcmdldDsgLy8gdGlsZSB3ZSB3YW50ZWRcblx0XHRjb25zdCBzY2FsZWRUaWxlU2l6ZSA9IHNjYWxlICogdGlsZVNpemU7XG5cdFx0Y29uc3Qgb2Zmc2V0U2NhbGUgPSAxIC8gTWF0aC5wb3coMiwgdGlsZS5jb29yZC56IC0gdGFyZ2V0LnopO1xuXHRcdGNvbnN0IG9mZnNldFggPSAodGlsZS5jb29yZC54ICogb2Zmc2V0U2NhbGUpIC0gdGFyZ2V0Lng7XG5cdFx0Y29uc3Qgb2Zmc2V0WSA9ICh0aWxlLmNvb3JkLnkgKiBvZmZzZXRTY2FsZSkgLSB0YXJnZXQueTtcblx0XHRjb25zdCB0aWxlT2Zmc2V0ID0gW1xuXHRcdFx0KChjb29yZC54ICsgb2Zmc2V0WCkgKiBzY2FsZWRUaWxlU2l6ZSkgLSB2aWV3cG9ydE9mZnNldC54LFxuXHRcdFx0KChjb29yZC55ICsgb2Zmc2V0WSkgKiBzY2FsZWRUaWxlU2l6ZSkgLSB2aWV3cG9ydE9mZnNldC55XG5cdFx0XTtcblx0XHRyZXR1cm4gbmV3IFRpbGVSZW5kZXJhYmxlKFxuXHRcdFx0dGlsZSxcblx0XHRcdHNjYWxlICogb2Zmc2V0U2NhbGUsXG5cdFx0XHR0aWxlT2Zmc2V0LFxuXHRcdFx0WyAwLCAwLCAxLCAxIF0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBgdXZPZmZzZXRgIGFuZCBgdGlsZU9mZnNldGAgcGFyYW1ldGVycyB0byB0aGUgY2FudmFzXG5cdCAqIGNvb3JkaW5hdGUgc3lzdGVtLCB3aXRoIFswLCAwXSBiZWluZyB0aGUgdG9wLWxlZnQgY29ybmVyLiBUaGUgY29udmVyc2lvblxuXHQgKiBpcyBkb25lIGluLXBsYWNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdmlld3BvcnQgLSBUaGUgcGl4ZWwgZGltZW5zaW9ucyBvZiB0aGUgdmlld3BvcnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aWxlU2l6ZSAtIFRoZSBzaXplIG9mIGVhY2ggdGlsZSBpbiBwaXhlbHMuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtUaWxlUmVuZGVyYWJsZX0gVGhlIHJlbmRlcmFibGUgb2JqZWN0LlxuXHQgKi9cblx0dG9DYW52YXModmlld3BvcnQsIHRpbGVTaXplKSB7XG5cdFx0Ly8gZmxpcCB5IGNvbXBvbmVudCBvZiB1diBvZmZzZXRcblx0XHRjb25zdCB1dk9mZnNldCA9IHRoaXMudXZPZmZzZXQ7XG5cdFx0dXZPZmZzZXRbMV0gPSAoMSAtIHV2T2Zmc2V0WzJdIC0gdXZPZmZzZXRbMV0pO1xuXHRcdC8vIGZsaXAgeSBjb21wb25lbnQgb2YgdGlsZSBvZmZzZXRcblx0XHRjb25zdCB0aWxlT2Zmc2V0ID0gdGhpcy50aWxlT2Zmc2V0O1xuXHRcdHRpbGVPZmZzZXRbMV0gPSB2aWV3cG9ydC5oZWlnaHQgLSB0aWxlT2Zmc2V0WzFdIC0gKHRpbGVTaXplICogdGhpcy5zY2FsZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUaWxlUmVuZGVyYWJsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRUeXBlID0gcmVxdWlyZSgnLi4vLi4vZXZlbnQvRXZlbnRUeXBlJyk7XG5jb25zdCBSVHJlZVB5cmFtaWQgPSByZXF1aXJlKCcuLi8uLi9nZW9tZXRyeS9SVHJlZVB5cmFtaWQnKTtcbmNvbnN0IFJlbmRlcmVyID0gcmVxdWlyZSgnLi4vUmVuZGVyZXInKTtcbmNvbnN0IFRpbGVSZW5kZXJhYmxlID0gcmVxdWlyZSgnLi9UaWxlUmVuZGVyYWJsZScpO1xuXG4vLyBDb25zdGFudHNcblxuLyoqXG4gKiBUaWxlIGluZGV4IGhhbmRsZXIgc3ltYm9sLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxuICovXG5jb25zdCBUSUxFX0lOREVYID0gU3ltYm9sKCk7XG5cbi8qKlxuICogVGlsZSB1bmluZGV4IGhhbmRsZXIgc3ltYm9sLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxuICovXG5jb25zdCBUSUxFX1VOSU5ERVggPSBTeW1ib2woKTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSB0aWxlIHJlbmRlcmVyLlxuICovXG5jbGFzcyBUaWxlUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJlciB7XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBUaWxlUmVuZGVyZXIgb2JqZWN0LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzW1RJTEVfSU5ERVhdID0gbmV3IE1hcCgpO1xuXHRcdHRoaXNbVElMRV9VTklOREVYXSA9IG5ldyBNYXAoKTtcblx0XHR0aGlzLmxheWVyID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBFeGVjdXRlZCB3aGVuIHRoZSBsYXllciBpcyBhdHRhY2hlZCB0byBhIHBsb3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyIC0gVGhlIGxheWVyIHRvIGF0dGFjaCB0aGUgcmVuZGVyZXIgdG8uXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtUaWxlUmVuZGVyZXJ9IFRoZSByZW5kZXJlciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdG9uQWRkKGxheWVyKSB7XG5cdFx0aWYgKCFsYXllcikge1xuXHRcdFx0dGhyb3cgJ05vIGxheWVyIHByb3ZpZGVkIGFzIGFyZ3VtZW50Jztcblx0XHR9XG5cdFx0dGhpcy5sYXllciA9IGxheWVyO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4ZWN1dGVkIHdoZW4gdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSBhIHBsb3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyIC0gVGhlIGxheWVyIHRvIHJlbW92ZSB0aGUgcmVuZGVyZXIgZnJvbS5cblx0ICpcblx0ICogQHJldHVybnMge1RpbGVSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0b25SZW1vdmUobGF5ZXIpIHtcblx0XHRpZiAoIWxheWVyKSB7XG5cdFx0XHR0aHJvdyAnTm8gbGF5ZXIgcHJvdmlkZWQgYXMgYXJndW1lbnQnO1xuXHRcdH1cblx0XHR0aGlzLmxheWVyID0gbnVsbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIHJ0cmVlIHB5cmFtaWQgb2JqZWN0LiBDcmVhdGVzIGFuZCBhdHRhY2hlcyB0aGUgbmVjZXNzYXJ5XG5cdCAqIGV2ZW50IGhhbmRsZXJzIHRvIGFkZCBhbmQgcmVtb3ZlIGRhdGEgZnJvbSB0aGUgcnRyZWUgYWNjb3JkaW5nbHkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSByLXRyZWUgcHlyYW1pZC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubm9kZUNhcGFjaXR5IC0gVGhlIG5vZGUgY2FwYWNpdHkgb2YgdGhlIHJ0cmVlLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLmNyZWF0ZUNvbGxpZGFibGVzIC0gVGhlIGZ1bmN0aW9uIHRvIGNyZWF0ZSBjb2xsaWRhYmxlcyBmcm9tIGEgdGlsZS5cblx0ICpcblx0ICogQHJldHVybnMge1JUcmVlUHlyYW1pZH0gVGhlIHItdHJlZSBweXJhbWlkIG9iamVjdC5cblx0ICovXG5cdGNyZWF0ZVJUcmVlUHlyYW1pZChvcHRpb25zID0ge30pIHtcblx0XHRjb25zdCBjcmVhdGVDb2xsaWRhYmxlcyA9IG9wdGlvbnMuY3JlYXRlQ29sbGlkYWJsZXM7XG5cdFx0aWYgKCFjcmVhdGVDb2xsaWRhYmxlcykge1xuXHRcdFx0dGhyb3cgJ2BvcHRpb25zLmNyZWF0ZUNvbGxpZGFibGVzYCBhcmd1bWVudCBpcyBtaXNzaW5nJztcblx0XHR9XG5cdFx0Ly8gY3JlYXRlIHJ0cmVlIHB5cmFtaWRcblx0XHRjb25zdCBweXJhbWlkID0gbmV3IFJUcmVlUHlyYW1pZCh7XG5cdFx0XHRub2RlQ2FwYWNpdHk6IG9wdGlvbnMubm9kZUNhcGFjaXR5XG5cdFx0fSk7XG5cdFx0Ly8gY3JlYXRlIGhhbmRsZXJzXG5cdFx0Y29uc3QgaW5kZXggPSBldmVudCA9PiB7XG5cdFx0XHRjb25zdCB0aWxlID0gZXZlbnQudGlsZTtcblx0XHRcdGNvbnN0IGNvb3JkID0gdGlsZS5jb29yZDtcblx0XHRcdGNvbnN0IHRpbGVTaXplID0gdGhpcy5sYXllci5wbG90LnRpbGVTaXplO1xuXHRcdFx0Y29uc3QgeE9mZnNldCA9IGNvb3JkLnggKiB0aWxlU2l6ZTtcblx0XHRcdGNvbnN0IHlPZmZzZXQgPSBjb29yZC55ICogdGlsZVNpemU7XG5cdFx0XHRjb25zdCBjb2xsaWRhYmxlcyA9IGNyZWF0ZUNvbGxpZGFibGVzKHRpbGUsIHhPZmZzZXQsIHlPZmZzZXQpO1xuXHRcdFx0cHlyYW1pZC5pbnNlcnQoY29vcmQsIGNvbGxpZGFibGVzKTtcblx0XHR9O1xuXHRcdGNvbnN0IHVuaW5kZXggPSBldmVudCA9PiB7XG5cdFx0XHRweXJhbWlkLnJlbW92ZShldmVudC50aWxlLmNvb3JkKTtcblx0XHR9O1xuXHRcdC8vIGF0dGFjaCBoYW5kbGVyc1xuXHRcdHRoaXMubGF5ZXIub24oRXZlbnRUeXBlLlRJTEVfQURELCBpbmRleCk7XG5cdFx0dGhpcy5sYXllci5vbihFdmVudFR5cGUuVElMRV9SRU1PVkUsIHVuaW5kZXgpO1xuXHRcdC8vIHN0b3JlIHRoZSBoYW5kbGVycyB1bmRlciB0aGUgYXRsYXNcblx0XHR0aGlzW1RJTEVfSU5ERVhdLnNldChweXJhbWlkLCBpbmRleCk7XG5cdFx0dGhpc1tUSUxFX1VOSU5ERVhdLnNldChweXJhbWlkLCB1bmluZGV4KTtcblx0XHRyZXR1cm4gcHlyYW1pZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXN0cm95cyBhIHZlcnRleCBhdGxhcyBvYmplY3QgYW5kIHJlbW92ZXMgYWxsIGV2ZW50IGhhbmRsZXJzIHVzZWQgdG8gYWRkXG5cdCAqIGFuZCByZW1vdmUgZGF0YSBmcm9tIHRoZSBhdGxhcy5cblx0ICpcblx0ICogQHBhcmFtIHtSVHJlZVB5cmFtaWR9IHB5cmFtaWQgLSBUaGUgci10cmVlIHB5cmFtaWQgb2JqZWN0IHRvIGRlc3Ryb3kuXG5cdCAqL1xuXHRkZXN0cm95UlRyZWVQeXJhbWlkKHB5cmFtaWQpIHtcblx0XHQvLyBkZXRhY2ggaGFuZGxlcnNcblx0XHR0aGlzLmxheWVyLnJlbW92ZUxpc3RlbmVyKEV2ZW50VHlwZS5USUxFX0FERCwgdGhpc1tUSUxFX0lOREVYXS5nZXQocHlyYW1pZCkpO1xuXHRcdHRoaXMubGF5ZXIucmVtb3ZlTGlzdGVuZXIoRXZlbnRUeXBlLlRJTEVfUkVNT1ZFLCB0aGlzW1RJTEVfVU5JTkRFWF0uZ2V0KHB5cmFtaWQpKTtcblx0XHQvLyByZW1vdmUgaGFuZGxlcnNcblx0XHR0aGlzW1RJTEVfSU5ERVhdLmRlbGV0ZShweXJhbWlkKTtcblx0XHR0aGlzW1RJTEVfVU5JTkRFWF0uZGVsZXRlKHB5cmFtaWQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHRpbGUgcmVuZGVyYWJsZXMgZm9yIHRoZSB1bmRlcmx5aW5nIGxheWVyLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBvZiB0aWxlIHJlbmRlcmFibGVzLlxuXHQgKi9cblx0Z2V0UmVuZGVyYWJsZXMoKSB7XG5cdFx0Y29uc3QgcGxvdCA9IHRoaXMubGF5ZXIucGxvdDtcblx0XHRjb25zdCBweXJhbWlkID0gdGhpcy5sYXllci5weXJhbWlkO1xuXHRcdGNvbnN0IHRpbGVTaXplID0gcGxvdC50aWxlU2l6ZTtcblx0XHRjb25zdCB6b29tID0gcGxvdC56b29tO1xuXHRcdGNvbnN0IHZpZXdwb3J0ID0gcGxvdC5nZXRWaWV3cG9ydFBpeGVsT2Zmc2V0KCk7XG5cdFx0Y29uc3QgY29vcmRzID0gcGxvdC5nZXRWaXNpYmxlQ29vcmRzKCk7XG5cdFx0Y29uc3QgcmVuZGVyYWJsZXMgPSBbXTtcblx0XHRmb3IgKGxldCBpPTA7IGk8Y29vcmRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBjb29yZCA9IGNvb3Jkc1tpXTtcblx0XHRcdGNvbnN0IG5jb29yZCA9IGNvb3JkLm5vcm1hbGl6ZSgpO1xuXHRcdFx0Ly8gY2hlY2sgaWYgd2UgaGF2ZSB0aGUgdGlsZVxuXHRcdFx0Y29uc3QgdGlsZSA9IHB5cmFtaWQuZ2V0KG5jb29yZCk7XG5cdFx0XHRpZiAodGlsZSkge1xuXHRcdFx0XHRjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIHpvb20gLSBjb29yZC56KTtcblx0XHRcdFx0Y29uc3QgcmVuZGVyYWJsZSA9IFRpbGVSZW5kZXJhYmxlLmZyb21UaWxlKFxuXHRcdFx0XHRcdHRpbGUsXG5cdFx0XHRcdFx0Y29vcmQsXG5cdFx0XHRcdFx0c2NhbGUsXG5cdFx0XHRcdFx0dGlsZVNpemUsXG5cdFx0XHRcdFx0dmlld3BvcnQpO1xuXHRcdFx0XHRyZW5kZXJhYmxlcy5wdXNoKHJlbmRlcmFibGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyYWJsZXM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdGlsZSByZW5kZXJhYmxlcyBmb3IgdGhlIHVuZGVybHlpbmcgbGF5ZXIgYXQgdGhlIGNsb3Nlc3Rcblx0ICogYXZhaWxhYmxlIGxldmVsLW9mLWRldGFpbC5cblx0ICpcblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2YgdGlsZSByZW5kZXJhYmxlcy5cblx0ICovXG5cdGdldFJlbmRlcmFibGVzTE9EKCkge1xuXHRcdGNvbnN0IHBsb3QgPSB0aGlzLmxheWVyLnBsb3Q7XG5cdFx0Y29uc3QgcHlyYW1pZCA9IHRoaXMubGF5ZXIucHlyYW1pZDtcblx0XHRjb25zdCB0aWxlU2l6ZSA9IHBsb3QudGlsZVNpemU7XG5cdFx0Y29uc3Qgem9vbSA9IHBsb3Quem9vbTtcblx0XHRjb25zdCB2aWV3cG9ydCA9IHBsb3QuZ2V0Vmlld3BvcnRQaXhlbE9mZnNldCgpO1xuXHRcdGNvbnN0IGNvb3JkcyA9IHBsb3QuZ2V0VmlzaWJsZUNvb3JkcygpO1xuXHRcdGNvbnN0IHJlbmRlcmFibGVzID0gW107XG5cdFx0Zm9yIChsZXQgaT0wOyBpPGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgY29vcmQgPSBjb29yZHNbaV07XG5cdFx0XHRjb25zdCBuY29vcmQgPSBjb29yZC5ub3JtYWxpemUoKTtcblx0XHRcdGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMiwgem9vbSAtIGNvb3JkLnopO1xuXHRcdFx0Ly8gY2hlY2sgaWYgd2UgaGF2ZSBhbnkgdGlsZSBMT0QgYXZhaWxhYmxlXG5cdFx0XHRjb25zdCBwYXJ0aWFscyA9IHB5cmFtaWQuZ2V0QXZhaWxhYmxlTE9EKG5jb29yZCk7XG5cdFx0XHRpZiAocGFydGlhbHMpIHtcblx0XHRcdFx0Zm9yIChsZXQgaj0wOyBqPHBhcnRpYWxzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0Y29uc3QgcGFydGlhbCA9IHBhcnRpYWxzW2pdO1xuXHRcdFx0XHRcdGNvbnN0IHRpbGUgPSBwYXJ0aWFsLnRpbGU7XG5cdFx0XHRcdFx0bGV0IHJlbmRlcmFibGU7XG5cdFx0XHRcdFx0aWYgKHRpbGUuY29vcmQueiA9PT0gY29vcmQueikge1xuXHRcdFx0XHRcdFx0Ly8gZXhhY3QgdGlsZVxuXHRcdFx0XHRcdFx0cmVuZGVyYWJsZSA9IFRpbGVSZW5kZXJhYmxlLmZyb21UaWxlKFxuXHRcdFx0XHRcdFx0XHR0aWxlLFxuXHRcdFx0XHRcdFx0XHRjb29yZCxcblx0XHRcdFx0XHRcdFx0c2NhbGUsXG5cdFx0XHRcdFx0XHRcdHRpbGVTaXplLFxuXHRcdFx0XHRcdFx0XHR2aWV3cG9ydCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aWxlLmNvb3JkLnogPCBjb29yZC56KSB7XG5cdFx0XHRcdFx0XHQvLyBhbmNlc3RvciBvZiB0aGUgdGlsZVxuXHRcdFx0XHRcdFx0cmVuZGVyYWJsZSA9IFRpbGVSZW5kZXJhYmxlLmZyb21BbmNlc3RvclBhcnRpYWwoXG5cdFx0XHRcdFx0XHRcdHBhcnRpYWwsXG5cdFx0XHRcdFx0XHRcdGNvb3JkLFxuXHRcdFx0XHRcdFx0XHRzY2FsZSxcblx0XHRcdFx0XHRcdFx0dGlsZVNpemUsXG5cdFx0XHRcdFx0XHRcdHZpZXdwb3J0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gZGVzY2VuZGFudCBvZiB0aGUgdGlsZVxuXHRcdFx0XHRcdFx0cmVuZGVyYWJsZSA9IFRpbGVSZW5kZXJhYmxlLmZyb21EZXNjZW5kYW50UGFydGlhbChcblx0XHRcdFx0XHRcdFx0cGFydGlhbCxcblx0XHRcdFx0XHRcdFx0Y29vcmQsXG5cdFx0XHRcdFx0XHRcdHNjYWxlLFxuXHRcdFx0XHRcdFx0XHR0aWxlU2l6ZSxcblx0XHRcdFx0XHRcdFx0dmlld3BvcnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZW5kZXJhYmxlcy5wdXNoKHJlbmRlcmFibGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZW5kZXJhYmxlcztcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGVSZW5kZXJlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZGVmYXVsdFRvID0gcmVxdWlyZSgnbG9kYXNoL2RlZmF1bHRUbycpO1xuY29uc3QgRXZlbnRUeXBlID0gcmVxdWlyZSgnLi4vLi4vZXZlbnQvRXZlbnRUeXBlJyk7XG5jb25zdCBTaGFkZXIgPSByZXF1aXJlKCcuLi8uLi93ZWJnbC9zaGFkZXIvU2hhZGVyJyk7XG5jb25zdCBUZXh0dXJlQXJyYXkgPSByZXF1aXJlKCcuLi8uLi93ZWJnbC90ZXh0dXJlL1RleHR1cmVBcnJheScpO1xuY29uc3QgVmVydGV4QXRsYXMgPSByZXF1aXJlKCcuLi8uLi93ZWJnbC92ZXJ0ZXgvVmVydGV4QXRsYXMnKTtcbmNvbnN0IFRpbGVSZW5kZXJlciA9IHJlcXVpcmUoJy4vVGlsZVJlbmRlcmVyJyk7XG5cbi8vIENvbnN0YW50c1xuXG4vKipcbiAqIFRpbGUgYWRkIGhhbmRsZXIgc3ltYm9sLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxuICovXG5jb25zdCBUSUxFX0FERCA9IFN5bWJvbCgpO1xuXG4vKipcbiAqIFRpbGUgcmVtb3ZlIGhhbmRsZXIgc3ltYm9sLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxuICovXG5jb25zdCBUSUxFX1JFTU9WRSA9IFN5bWJvbCgpO1xuXG4vLyBQcml2YXRlIE1ldGhvZHNcblxuY29uc3QgYWRkVGlsZVRvVGV4dHVyZUFycmF5ID0gZnVuY3Rpb24oYXJyYXksIHRpbGUpIHtcblx0YXJyYXkuc2V0KHRpbGUuY29vcmQuaGFzaCwgdGlsZS5kYXRhKTtcbn07XG5cbmNvbnN0IHJlbW92ZVRpbGVGcm9tVGV4dHVyZUFycmF5ID0gZnVuY3Rpb24oYXJyYXksIHRpbGUpIHtcblx0YXJyYXkuZGVsZXRlKHRpbGUuY29vcmQuaGFzaCk7XG59O1xuXG5jb25zdCBhZGRUaWxlVG9WZXJ0ZXhBdGxhcyA9IGZ1bmN0aW9uKGF0bGFzLCB0aWxlKSB7XG5cdGF0bGFzLnNldChcblx0XHR0aWxlLmNvb3JkLmhhc2gsXG5cdFx0dGlsZS5kYXRhLFxuXHRcdHRpbGUuZGF0YS5sZW5ndGggLyBhdGxhcy5zdHJpZGUpO1xufTtcblxuY29uc3QgcmVtb3ZlVGlsZUZyb21WZXJ0ZXhBdGxhcyA9IGZ1bmN0aW9uKGF0bGFzLCB0aWxlKSB7XG5cdGF0bGFzLmRlbGV0ZSh0aWxlLmNvb3JkLmhhc2gpO1xufTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSB3ZWJnbCB0aWxlIHJlbmRlcmVyLlxuICovXG5jbGFzcyBXZWJHTFRpbGVSZW5kZXJlciBleHRlbmRzIFRpbGVSZW5kZXJlciB7XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBXZWJHTFRpbGVSZW5kZXJlciBvYmplY3QuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuZ2wgPSBudWxsO1xuXHRcdHRoaXNbVElMRV9BRERdID0gbmV3IE1hcCgpO1xuXHRcdHRoaXNbVElMRV9SRU1PVkVdID0gbmV3IE1hcCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4ZWN1dGVkIHdoZW4gdGhlIGxheWVyIGlzIGF0dGFjaGVkIHRvIGEgcGxvdC5cblx0ICpcblx0ICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSBUaGUgbGF5ZXIgdG8gYXR0YWNoIHRoZSByZW5kZXJlciB0by5cblx0ICpcblx0ICogQHJldHVybnMge1dlYkdMVGlsZVJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRvbkFkZChsYXllcikge1xuXHRcdHN1cGVyLm9uQWRkKGxheWVyKTtcblx0XHR0aGlzLmdsID0gdGhpcy5sYXllci5wbG90LmdldFJlbmRlcmluZ0NvbnRleHQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBFeGVjdXRlZCB3aGVuIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gYSBwbG90LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0xheWVyfSBsYXllciAtIFRoZSBsYXllciB0byByZW1vdmUgdGhlIHJlbmRlcmVyIGZyb20uXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtXZWJHTFJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRvblJlbW92ZShsYXllcikge1xuXHRcdHRoaXMuZ2wgPSBudWxsO1xuXHRcdHN1cGVyLm9uUmVtb3ZlKGxheWVyKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXggZm9yIHRoZSB2aWV3cG9ydC5cblx0ICpcblx0ICogQHJldHVybnMge0Zsb2F0MzJBcnJheX0gVGhlIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uIG1hdHJpeC5cblx0ICovXG5cdGdldE9ydGhvTWF0cml4KCkge1xuXHRcdHJldHVybiB0aGlzLmxheWVyLnBsb3QuZ2V0T3J0aG9NYXRyaXgoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFNoYWRlciBvYmplY3QgdXNpbmcgdGhlIHJlbmRlcmVycyBpbnRlcm5hbFxuXHQgKiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgLSBUaGUgc2hhZGVyIHBhcmFtIG9iamVjdC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZS5jb21tb24gLSBDb21tb24gZ2xzbCB0byBiZSBzaGFyZWQgYnkgYm90aCB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlcnMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UudmVydCAtIFRoZSB2ZXJ0ZXggc2hhZGVyIGdsc2wuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UuZnJhZyAtIFRoZSBmcmFnbWVudCBzaGFkZXIgZ2xzbC5cblx0ICpcblx0ICogQHJldHVybnMge1NoYWRlcn0gVGhlIHNoYWRlciBvYmplY3QuXG5cdCAqL1xuXHRjcmVhdGVTaGFkZXIoc291cmNlKSB7XG5cdFx0cmV0dXJuIG5ldyBTaGFkZXIodGhpcy5nbCwgc291cmNlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgdGV4dHVyZSBhcnJheSBvZiBhcHByb3ByaWF0ZSBzaXplIGZvciB0aGUgbGF5ZXIgcHlyYW1pZCB1c2luZ1xuXHQgKiB0aGUgcHJvdmlkZWQgdGV4dHVyZSBzaXplLiBDcmVhdGVzIGFuZCBhdHRhY2hlcyB0aGUgbmVjZXNzYXJ5IGV2ZW50XG5cdCAqIGhhbmRsZXJzIHRvIGFkZCBhbmQgcmVtb3ZlIGRhdGEgZnJvbSB0aGUgYXJyYXkgYWNjb3JkaW5nbHkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSB0ZXh0dXJlIGFycmF5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaHVua1NpemUgLSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgdGlsZSB0ZXh0dXJlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5mb3JtYXQgLSBUaGUgdGV4dHVyZSBwaXhlbCBmb3JtYXQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnR5cGUgLSBUaGUgdGV4dHVyZSBwaXhlbCBjb21wb25lbnQgdHlwZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZmlsdGVyIC0gVGhlIG1pbiAvIG1hZyBmaWx0ZXIgdXNlZCBkdXJpbmcgc2NhbGluZy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMud3JhcCAtIFRoZSB3cmFwcGluZyB0eXBlIG92ZXIgYm90aCBTIGFuZCBUIGRpbWVuc2lvbi5cblx0ICogQHBhcmFtIHtib29sfSBvcHRpb25zLmludmVydFkgLSBXaGV0aGVyIG9yIG5vdCBpbnZlcnQteSBpcyBlbmFibGVkLlxuXHQgKiBAcGFyYW0ge2Jvb2x9IG9wdGlvbnMucHJlbXVsdGlwbHlBbHBoYSAtIFdoZXRoZXIgb3Igbm90IGFscGhhIHByZW11bHRpcGx5aW5nIGlzIGVuYWJsZWQuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25BZGQgLSBUaGUgZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiBhIHRpbGUgaXMgYWRkZWQuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25SZW1vdmUgLSBUaGUgZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiBhIHRpbGUgaXMgcmVtb3ZlZC5cblx0ICpcblx0ICogQHJldHVybnMge1RleHR1cmVBcnJheX0gVGhlIHRleHR1cmUgYXJyYXkgb2JqZWN0LlxuXHQgKi9cblx0Y3JlYXRlVGV4dHVyZUFycmF5KG9wdGlvbnMgPSB7fSkge1xuXHRcdC8vIGNyZWF0ZSB0ZXh0dXJlIGFycmF5XG5cdFx0Y29uc3QgYXJyYXkgPSBuZXcgVGV4dHVyZUFycmF5KFxuXHRcdFx0dGhpcy5nbCxcblx0XHRcdHtcblx0XHRcdFx0Ly8gc2V0IHRleHR1cmUgcGFyYW1zXG5cdFx0XHRcdGZvcm1hdDogb3B0aW9ucy5mb3JtYXQsXG5cdFx0XHRcdHR5cGU6IG9wdGlvbnMudHlwZSxcblx0XHRcdFx0ZmlsdGVyOiBvcHRpb25zLmZpbHRlcixcblx0XHRcdFx0aW52ZXJ0WTogb3B0aW9ucy5pbnZlcnRZLFxuXHRcdFx0XHRwcmVtdWx0aXBseUFscGhhOiBvcHRpb25zLnByZW11bHRpcGx5QWxwaGFcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdC8vIHNldCBudW0gY2h1bmtzIHRvIGJlIGFibGUgdG8gZml0IHRoZSBjYXBhY2l0eSBvZiB0aGUgcHlyYW1pZFxuXHRcdFx0XHRudW1DaHVua3M6IHRoaXMubGF5ZXIucHlyYW1pZC5nZXRDYXBhY2l0eSgpLFxuXHRcdFx0XHRjaHVua1NpemU6IG9wdGlvbnMuY2h1bmtTaXplXG5cdFx0XHR9KTtcblx0XHQvLyBjcmVhdGUgaGFuZGxlcnNcblx0XHRjb25zdCBvbkFkZCA9IGRlZmF1bHRUbyhvcHRpb25zLm9uQWRkLCBhZGRUaWxlVG9UZXh0dXJlQXJyYXkpO1xuXHRcdGNvbnN0IG9uUmVtb3ZlID0gZGVmYXVsdFRvKG9wdGlvbnMub25SZW1vdmUsIHJlbW92ZVRpbGVGcm9tVGV4dHVyZUFycmF5KTtcblx0XHRjb25zdCBhZGQgPSBldmVudCA9PiB7XG5cdFx0XHRvbkFkZChhcnJheSwgZXZlbnQudGlsZSk7XG5cdFx0fTtcblx0XHRjb25zdCByZW1vdmUgPSBldmVudCA9PiB7XG5cdFx0XHRvblJlbW92ZShhcnJheSwgZXZlbnQudGlsZSk7XG5cdFx0fTtcblx0XHQvLyBhdHRhY2ggaGFuZGxlcnNcblx0XHR0aGlzLmxheWVyLm9uKEV2ZW50VHlwZS5USUxFX0FERCwgYWRkKTtcblx0XHR0aGlzLmxheWVyLm9uKEV2ZW50VHlwZS5USUxFX1JFTU9WRSwgcmVtb3ZlKTtcblx0XHQvLyBzdG9yZSB0aGUgaGFuZGxlcnMgdW5kZXIgdGhlIGFycmF5XG5cdFx0dGhpc1tUSUxFX0FERF0uc2V0KGFycmF5LCBhZGQpO1xuXHRcdHRoaXNbVElMRV9SRU1PVkVdLnNldChhcnJheSwgcmVtb3ZlKTtcblx0XHRyZXR1cm4gYXJyYXk7XG5cdH1cblxuXHQvKipcblx0ICogRGVzdHJveXMgYSB0ZXh0dXJlIGFycmF5IG9iamVjdCBhbmQgcmVtb3ZlcyBhbGwgZXZlbnQgaGFuZGxlcnMgdXNlZCB0b1xuXHQgKiBhZGQgYW5kIHJlbW92ZSBkYXRhIGZyb20gdGhlIGFycmF5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1RleHR1cmVBcnJheX0gYXJyYXkgLSBUaGUgdGV4dHVyZSBhcnJheSB0byBkZXN0cm95LlxuXHQgKi9cblx0ZGVzdHJveVRleHR1cmVBcnJheShhcnJheSkge1xuXHRcdC8vIGRldGFjaCBoYW5kbGVyc1xuXHRcdHRoaXMubGF5ZXIucmVtb3ZlTGlzdGVuZXIoRXZlbnRUeXBlLlRJTEVfQURELCB0aGlzW1RJTEVfQUREXS5nZXQoYXJyYXkpKTtcblx0XHR0aGlzLmxheWVyLnJlbW92ZUxpc3RlbmVyKEV2ZW50VHlwZS5USUxFX1JFTU9WRSwgdGhpc1tUSUxFX1JFTU9WRV0uZ2V0KGFycmF5KSk7XG5cdFx0Ly8gcmVtb3ZlIGhhbmRsZXJzXG5cdFx0dGhpc1tUSUxFX0FERF0uZGVsZXRlKGFycmF5KTtcblx0XHR0aGlzW1RJTEVfUkVNT1ZFXS5kZWxldGUoYXJyYXkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSB2ZXJ0ZXggYXRsYXMgb2YgYXBwcm9wcmlhdGUgc2l6ZSBmb3IgdGhlIGxheWVyIHB5cmFtaWQgdXNpbmdcblx0ICogdGhlIHByb3ZpZGVkIGF0dHJpYnV0ZSBwb2ludGVycy4gQ3JlYXRlcyBhbmQgYXR0YWNoZXMgdGhlIG5lY2Vzc2FyeVxuXHQgKiBldmVudCBoYW5kbGVycyB0byBhZGQgYW5kIHJlbW92ZSBkYXRhIGZyb20gdGhlIGF0bGFzIGFjY29yZGluZ2x5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgdmVydGV4IGF0bGFzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5hdHRyaWJ1dGVQb2ludGVycyAtIFRoZSB2ZXJ0ZXggYXR0cmlidXRlIHBvaW50ZXJzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaHVua1NpemUgLSBUaGUgc2l6ZSBvZiBhIHNpbmdsZSBjaHVuaywgaW4gdmVydGljZXMuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25BZGQgLSBUaGUgZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiBhIHRpbGUgaXMgYWRkZWQuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25SZW1vdmUgLSBUaGUgZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiBhIHRpbGUgaXMgcmVtb3ZlZC5cblx0ICpcblx0ICogQHJldHVybnMge1ZlcnRleEF0bGFzfSBUaGUgdmVydGV4IGF0bGFzIG9iamVjdC5cblx0ICovXG5cdGNyZWF0ZVZlcnRleEF0bGFzKG9wdGlvbnMgPSB7fSkge1xuXHRcdC8vIGNyZWF0ZSB2ZXJ0ZXggYXRsYXNcblx0XHRjb25zdCBhdGxhcyA9IG5ldyBWZXJ0ZXhBdGxhcyhcblx0XHRcdHRoaXMuZ2wsXG5cdFx0XHRvcHRpb25zLmF0dHJpYnV0ZVBvaW50ZXJzLFxuXHRcdFx0e1xuXHRcdFx0XHQvLyBzZXQgbnVtIGNodW5rcyB0byBiZSBhYmxlIHRvIGZpdCB0aGUgY2FwYWNpdHkgb2YgdGhlIHB5cmFtaWRcblx0XHRcdFx0bnVtQ2h1bmtzOiB0aGlzLmxheWVyLnB5cmFtaWQuZ2V0Q2FwYWNpdHkoKSxcblx0XHRcdFx0Y2h1bmtTaXplOiBvcHRpb25zLmNodW5rU2l6ZVxuXHRcdFx0fSk7XG5cdFx0Ly8gY3JlYXRlIGhhbmRsZXJzXG5cdFx0Y29uc3Qgb25BZGQgPSBkZWZhdWx0VG8ob3B0aW9ucy5vbkFkZCwgYWRkVGlsZVRvVmVydGV4QXRsYXMpO1xuXHRcdGNvbnN0IG9uUmVtb3ZlID0gZGVmYXVsdFRvKG9wdGlvbnMub25SZW1vdmUsIHJlbW92ZVRpbGVGcm9tVmVydGV4QXRsYXMpO1xuXHRcdGNvbnN0IGFkZCA9IGV2ZW50ID0+IHtcblx0XHRcdG9uQWRkKGF0bGFzLCBldmVudC50aWxlKTtcblx0XHR9O1xuXHRcdGNvbnN0IHJlbW92ZSA9IGV2ZW50ID0+IHtcblx0XHRcdG9uUmVtb3ZlKGF0bGFzLCBldmVudC50aWxlKTtcblx0XHR9O1xuXHRcdC8vIGF0dGFjaCBoYW5kbGVyc1xuXHRcdHRoaXMubGF5ZXIub24oRXZlbnRUeXBlLlRJTEVfQURELCBhZGQpO1xuXHRcdHRoaXMubGF5ZXIub24oRXZlbnRUeXBlLlRJTEVfUkVNT1ZFLCByZW1vdmUpO1xuXHRcdC8vIHN0b3JlIHRoZSBoYW5kbGVycyB1bmRlciB0aGUgYXRsYXNcblx0XHR0aGlzW1RJTEVfQUREXS5zZXQoYXRsYXMsIGFkZCk7XG5cdFx0dGhpc1tUSUxFX1JFTU9WRV0uc2V0KGF0bGFzLCByZW1vdmUpO1xuXHRcdHJldHVybiBhdGxhcztcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXN0cm95cyBhIHZlcnRleCBhdGxhcyBvYmplY3QgYW5kIHJlbW92ZXMgYWxsIGV2ZW50IGhhbmRsZXJzIHVzZWQgdG8gYWRkXG5cdCAqIGFuZCByZW1vdmUgZGF0YSBmcm9tIHRoZSBhdGxhcy5cblx0ICpcblx0ICogQHBhcmFtIHtWZXJ0ZXhBdGxhc30gYXRsYXMgLSBUaGUgdmVydGV4IGF0bGFzIHRvIGRlc3Ryb3kuXG5cdCAqL1xuXHRkZXN0cm95VmVydGV4QXRsYXMoYXRsYXMpIHtcblx0XHQvLyBkZXRhY2ggaGFuZGxlcnNcblx0XHR0aGlzLmxheWVyLnJlbW92ZUxpc3RlbmVyKEV2ZW50VHlwZS5USUxFX0FERCwgdGhpc1tUSUxFX0FERF0uZ2V0KGF0bGFzKSk7XG5cdFx0dGhpcy5sYXllci5yZW1vdmVMaXN0ZW5lcihFdmVudFR5cGUuVElMRV9SRU1PVkUsIHRoaXNbVElMRV9SRU1PVkVdLmdldChhdGxhcykpO1xuXHRcdC8vIHJlbW92ZSBoYW5kbGVyc1xuXHRcdHRoaXNbVElMRV9BRERdLmRlbGV0ZShhdGxhcyk7XG5cdFx0dGhpc1tUSUxFX1JFTU9WRV0uZGVsZXRlKGF0bGFzKTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYkdMVGlsZVJlbmRlcmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBWZXJ0ZXhCdWZmZXIgPSByZXF1aXJlKCcuLi8uLi8uLi93ZWJnbC92ZXJ0ZXgvVmVydGV4QnVmZmVyJyk7XG5jb25zdCBXZWJHTFRpbGVSZW5kZXJlciA9IHJlcXVpcmUoJy4uL1dlYkdMVGlsZVJlbmRlcmVyJyk7XG5cbi8vIENvbnN0YW50c1xuXG4vKipcbiAqIFNoYWRlciBHTFNMIHNvdXJjZS5cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnQge09iamVjdH1cbiAqL1xuY29uc3QgU0hBREVSX0dMU0wgPSB7XG5cdHZlcnQ6XG5cdFx0YFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblx0XHRhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XG5cdFx0YXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcblx0XHR1bmlmb3JtIHZlYzQgdVRleHR1cmVDb29yZE9mZnNldDtcblx0XHR1bmlmb3JtIHZlYzIgdVRpbGVPZmZzZXQ7XG5cdFx0dW5pZm9ybSBmbG9hdCB1U2NhbGU7XG5cdFx0dW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xuXHRcdHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuXHRcdHZvaWQgbWFpbigpIHtcblx0XHRcdHZUZXh0dXJlQ29vcmQgPSB2ZWMyKFxuXHRcdFx0XHR1VGV4dHVyZUNvb3JkT2Zmc2V0LnggKyAoYVRleHR1cmVDb29yZC54ICogdVRleHR1cmVDb29yZE9mZnNldC56KSxcblx0XHRcdFx0dVRleHR1cmVDb29yZE9mZnNldC55ICsgKGFUZXh0dXJlQ29vcmQueSAqIHVUZXh0dXJlQ29vcmRPZmZzZXQudykpO1xuXHRcdFx0dmVjMiB3UG9zaXRpb24gPSAoYVBvc2l0aW9uICogdVNjYWxlKSArIHVUaWxlT2Zmc2V0O1xuXHRcdFx0Z2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQod1Bvc2l0aW9uLCAwLjAsIDEuMCk7XG5cdFx0fVxuXHRcdGAsXG5cdGZyYWc6XG5cdFx0YFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZVNhbXBsZXI7XG5cdFx0dW5pZm9ybSBmbG9hdCB1T3BhY2l0eTtcblx0XHR2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcblx0XHR2b2lkIG1haW4oKSB7XG5cdFx0XHR2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlU2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLngsIDEuMCAtIHZUZXh0dXJlQ29vcmQueSkpO1xuXHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvci5yZ2IsIGNvbG9yLmEgKiB1T3BhY2l0eSk7XG5cdFx0fVxuXHRcdGBcbn07XG5cbmNvbnN0IGNyZWF0ZVF1YWQgPSBmdW5jdGlvbihnbCwgbWluLCBtYXgpIHtcblx0Y29uc3QgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KDI0KTtcblx0Ly8gcG9zaXRpb25zXG5cdHZlcnRpY2VzWzBdID0gbWluO1xuXHR2ZXJ0aWNlc1sxXSA9IG1pbjtcblx0dmVydGljZXNbMl0gPSBtYXg7XG5cdHZlcnRpY2VzWzNdID0gbWluO1xuXHR2ZXJ0aWNlc1s0XSA9IG1heDtcblx0dmVydGljZXNbNV0gPSBtYXg7XG5cdHZlcnRpY2VzWzZdID0gbWluO1xuXHR2ZXJ0aWNlc1s3XSA9IG1pbjtcblx0dmVydGljZXNbOF0gPSBtYXg7XG5cdHZlcnRpY2VzWzldID0gbWF4O1xuXHR2ZXJ0aWNlc1sxMF0gPSBtaW47XG5cdHZlcnRpY2VzWzExXSA9IG1heDtcblx0Ly8gdXZzXG5cdHZlcnRpY2VzWzEyXSA9IDA7XG5cdHZlcnRpY2VzWzEzXSA9IDA7XG5cdHZlcnRpY2VzWzE0XSA9IDE7XG5cdHZlcnRpY2VzWzE1XSA9IDA7XG5cdHZlcnRpY2VzWzE2XSA9IDE7XG5cdHZlcnRpY2VzWzE3XSA9IDE7XG5cdHZlcnRpY2VzWzE4XSA9IDA7XG5cdHZlcnRpY2VzWzE5XSA9IDA7XG5cdHZlcnRpY2VzWzIwXSA9IDE7XG5cdHZlcnRpY2VzWzIxXSA9IDE7XG5cdHZlcnRpY2VzWzIyXSA9IDA7XG5cdHZlcnRpY2VzWzIzXSA9IDE7XG5cdC8vIGNyZWF0ZSBxdWFkIGJ1ZmZlclxuXHRyZXR1cm4gbmV3IFZlcnRleEJ1ZmZlcihcblx0XHRnbCxcblx0XHR2ZXJ0aWNlcyxcblx0XHR7XG5cdFx0XHQwOiB7XG5cdFx0XHRcdHNpemU6IDIsXG5cdFx0XHRcdHR5cGU6ICdGTE9BVCcsXG5cdFx0XHRcdGJ5dGVPZmZzZXQ6IDBcblx0XHRcdH0sXG5cdFx0XHQxOiB7XG5cdFx0XHRcdHNpemU6IDIsXG5cdFx0XHRcdHR5cGU6ICdGTE9BVCcsXG5cdFx0XHRcdGJ5dGVPZmZzZXQ6IDIgKiA2ICogNFxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0Y291bnQ6IDYsXG5cdFx0fSk7XG59O1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHdlYmdsIGltYWdlIHRpbGUgcmVuZGVyZXIuXG4gKi9cbmNsYXNzIEltYWdlVGlsZVJlbmRlcmVyIGV4dGVuZHMgV2ViR0xUaWxlUmVuZGVyZXIge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgSW1hZ2VUaWxlUmVuZGVyZXIgb2JqZWN0LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnF1YWQgPSBudWxsO1xuXHRcdHRoaXMuc2hhZGVyID0gbnVsbDtcblx0XHR0aGlzLmFycmF5ID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBFeGVjdXRlZCB3aGVuIHRoZSBsYXllciBpcyBhdHRhY2hlZCB0byBhIHBsb3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyIC0gVGhlIGxheWVyIHRvIGF0dGFjaCB0aGUgcmVuZGVyZXIgdG8uXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtJbWFnZVRpbGVSZW5kZXJlcn0gVGhlIHJlbmRlcmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0b25BZGQobGF5ZXIpIHtcblx0XHRzdXBlci5vbkFkZChsYXllcik7XG5cdFx0dGhpcy5xdWFkID0gY3JlYXRlUXVhZCh0aGlzLmdsLCAwLCBsYXllci5wbG90LnRpbGVTaXplKTtcblx0XHR0aGlzLnNoYWRlciA9IHRoaXMuY3JlYXRlU2hhZGVyKFNIQURFUl9HTFNMKTtcblx0XHR0aGlzLmFycmF5ID0gdGhpcy5jcmVhdGVUZXh0dXJlQXJyYXkoe1xuXHRcdFx0Y2h1bmtTaXplOiBsYXllci5wbG90LnRpbGVTaXplXG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIGEgcGxvdC5cblx0ICpcblx0ICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSBUaGUgbGF5ZXIgdG8gcmVtb3ZlIHRoZSByZW5kZXJlciBmcm9tLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7SW1hZ2VUaWxlUmVuZGVyZXJ9IFRoZSByZW5kZXJlciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdG9uUmVtb3ZlKGxheWVyKSB7XG5cdFx0dGhpcy5kZXN0cm95VGV4dHVyZUFycmF5KHRoaXMuYXJyYXkpO1xuXHRcdHRoaXMuYXJyYXkgPSBudWxsO1xuXHRcdHRoaXMucXVhZCA9IG51bGw7XG5cdFx0dGhpcy5zaGFkZXIgPSBudWxsO1xuXHRcdHN1cGVyLm9uUmVtb3ZlKGxheWVyKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgZHJhdyBmdW5jdGlvbiB0aGF0IGlzIGV4ZWN1dGVkIHBlciBmcmFtZS5cblx0ICpcblx0ICogQHJldHVybnMge0ltYWdlVGlsZVJlbmRlcmVyfSBUaGUgcmVuZGVyZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRkcmF3KCkge1xuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcblx0XHRjb25zdCBzaGFkZXIgPSB0aGlzLnNoYWRlcjtcblx0XHRjb25zdCBhcnJheSA9IHRoaXMuYXJyYXk7XG5cdFx0Y29uc3QgcXVhZCA9IHRoaXMucXVhZDtcblx0XHRjb25zdCByZW5kZXJhYmxlcyA9IHRoaXMuZ2V0UmVuZGVyYWJsZXNMT0QoKTtcblx0XHRjb25zdCBwcm9qID0gdGhpcy5nZXRPcnRob01hdHJpeCgpO1xuXG5cdFx0Ly8gYmluZCBzaGFkZXJcblx0XHRzaGFkZXIudXNlKCk7XG5cdFx0Ly8gc2V0IGdsb2JhbCB1bmlmb3Jtc1xuXHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1UHJvamVjdGlvbk1hdHJpeCcsIHByb2opO1xuXHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1VGV4dHVyZVNhbXBsZXInLCAwKTtcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndU9wYWNpdHknLCB0aGlzLmxheWVyLm9wYWNpdHkpO1xuXG5cdFx0Ly8gc2V0IGJsZW5kaW5nIGZ1bmNcblx0XHRnbC5lbmFibGUoZ2wuQkxFTkQpO1xuXHRcdGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuXG5cdFx0Ly8gYmluZCBxdWFkXG5cdFx0cXVhZC5iaW5kKCk7XG5cblx0XHQvLyBmb3IgZWFjaCByZW5kZXJhYmxlXG5cdFx0Zm9yIChsZXQgaT0wOyBpPHJlbmRlcmFibGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCByZW5kZXJhYmxlID0gcmVuZGVyYWJsZXNbaV07XG5cdFx0XHRhcnJheS5iaW5kKHJlbmRlcmFibGUuaGFzaCwgMCk7XG5cdFx0XHQvLyBzZXQgdGlsZSB1bmlmb3Jtc1xuXHRcdFx0c2hhZGVyLnNldFVuaWZvcm0oJ3VUZXh0dXJlQ29vcmRPZmZzZXQnLCByZW5kZXJhYmxlLnV2T2Zmc2V0KTtcblx0XHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1U2NhbGUnLCByZW5kZXJhYmxlLnNjYWxlKTtcblx0XHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1VGlsZU9mZnNldCcsIHJlbmRlcmFibGUudGlsZU9mZnNldCk7XG5cdFx0XHQvLyBkcmF3XG5cdFx0XHRxdWFkLmRyYXcoKTtcblx0XHRcdC8vIG5vIG5lZWQgdG8gdW5iaW5kIHRleHR1cmVcblx0XHR9XG5cblx0XHQvLyB1bmJpbmQgcXVhZFxuXHRcdHF1YWQudW5iaW5kKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZVRpbGVSZW5kZXJlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZGVmYXVsdFRvID0gcmVxdWlyZSgnbG9kYXNoL2RlZmF1bHRUbycpO1xuY29uc3QgVmVydGV4QnVmZmVyID0gcmVxdWlyZSgnLi4vLi4vLi4vd2ViZ2wvdmVydGV4L1ZlcnRleEJ1ZmZlcicpO1xuY29uc3QgV2ViR0xUaWxlUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9XZWJHTFRpbGVSZW5kZXJlcicpO1xuXG4vLyBDb25zdGFudHNcblxuLyoqXG4gKiBOdW12ZXIgb2YgdmVydGljZXMgc3VwcG9ydGVkIHBlciBjaHVuay5cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnQge251bWJlcn1cbiAqL1xuY29uc3QgQ0hVTktfU0laRSA9IDEyOCAqIDEyODtcblxuLyoqXG4gKiBJbm5lciByYWRpdXMgb2Ygc3Rhci5cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnQge251bWJlcn1cbiAqL1xuY29uc3QgU1RBUl9JTk5FUl9SQURJVVMgPSAwLjQ7XG5cbi8qKlxuICogT3V0ZXIgcmFkaXVzIG9mIHN0YXIuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50IHtudW1iZXJ9XG4gKi9cbmNvbnN0IFNUQVJfT1VURVJfUkFESVVTID0gMS4wO1xuXG4vKipcbiAqIG51bWJlciBvZiBwb2ludHMgb24gdGhlIHN0YXIuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50IHtudW1iZXJ9XG4gKi9cbmNvbnN0IFNUQVJfTlVNX1BPSU5UUyA9IDU7XG5cbi8qKlxuICogU2hhZGVyIEdMU0wgc291cmNlLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7T2JqZWN0fVxuICovXG5jb25zdCBTSEFERVJfR0xTTCA9IHtcblx0dmVydDpcblx0XHRgXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXHRcdGF0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbjtcblx0XHRhdHRyaWJ1dGUgdmVjMiBhT2Zmc2V0O1xuXHRcdGF0dHJpYnV0ZSBmbG9hdCBhUmFkaXVzO1xuXHRcdHVuaWZvcm0gdmVjMiB1VGlsZU9mZnNldDtcblx0XHR1bmlmb3JtIGZsb2F0IHVTY2FsZTtcblx0XHR1bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XG5cdFx0dm9pZCBtYWluKCkge1xuXHRcdFx0dmVjMiB3UG9zaXRpb24gPSAoYVBvc2l0aW9uICogYVJhZGl1cykgKyAoYU9mZnNldCAqIHVTY2FsZSkgKyB1VGlsZU9mZnNldDtcblx0XHRcdGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB2ZWM0KHdQb3NpdGlvbiwgMC4wLCAxLjApO1xuXHRcdH1cblx0XHRgLFxuXHRmcmFnOlxuXHRcdGBcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5cdFx0dW5pZm9ybSB2ZWM0IHVDb2xvcjtcblx0XHR2b2lkIG1haW4oKSB7XG5cdFx0XHRnbF9GcmFnQ29sb3IgPSB1Q29sb3I7XG5cdFx0fVxuXHRcdGBcbn07XG5cbi8vIFByaXZhdGUgTWV0aG9kc1xuXG5jb25zdCBjcmVhdGVTdGFyID0gZnVuY3Rpb24oZ2wpIHtcblx0Y29uc3QgdGhldGEgPSAoMiAqIE1hdGguUEkpIC8gU1RBUl9OVU1fUE9JTlRTO1xuXHRjb25zdCBodGhldGEgPSB0aGV0YSAvIDIuMDtcblx0Y29uc3QgcXRoZXRhID0gdGhldGEgLyA0LjA7XG5cdGNvbnN0IHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoKFNUQVJfTlVNX1BPSU5UUyAqIDIpICogMiArIDQpO1xuXHRwb3NpdGlvbnNbMF0gPSAwO1xuXHRwb3NpdGlvbnNbMV0gPSAwO1xuXHRmb3IgKGxldCBpPTA7IGk8U1RBUl9OVU1fUE9JTlRTOyBpKyspIHtcblx0XHRjb25zdCBhbmdsZSA9IGkgKiB0aGV0YTtcblx0XHRsZXQgc3ggPSBNYXRoLmNvcyhhbmdsZSAtIHF0aGV0YSkgKiBTVEFSX0lOTkVSX1JBRElVUztcblx0XHRsZXQgc3kgPSBNYXRoLnNpbihhbmdsZSAtIHF0aGV0YSkgKiBTVEFSX0lOTkVSX1JBRElVUztcblx0XHRwb3NpdGlvbnNbaSo0KzJdID0gc3g7XG5cdFx0cG9zaXRpb25zW2kqNCsxKzJdID0gc3k7XG5cdFx0c3ggPSBNYXRoLmNvcyhhbmdsZSArIGh0aGV0YSAtIHF0aGV0YSkgKiBTVEFSX09VVEVSX1JBRElVUztcblx0XHRzeSA9IE1hdGguc2luKGFuZ2xlICsgaHRoZXRhIC0gcXRoZXRhKSAqIFNUQVJfT1VURVJfUkFESVVTO1xuXHRcdHBvc2l0aW9uc1tpKjQrMisyXSA9IHN4O1xuXHRcdHBvc2l0aW9uc1tpKjQrMysyXSA9IHN5O1xuXHR9XG5cdHBvc2l0aW9uc1twb3NpdGlvbnMubGVuZ3RoLTJdID0gcG9zaXRpb25zWzJdO1xuXHRwb3NpdGlvbnNbcG9zaXRpb25zLmxlbmd0aC0xXSA9IHBvc2l0aW9uc1szXTtcblx0cmV0dXJuIG5ldyBWZXJ0ZXhCdWZmZXIoXG5cdFx0Z2wsXG5cdFx0cG9zaXRpb25zLFxuXHRcdHtcblx0XHRcdDA6IHtcblx0XHRcdFx0c2l6ZTogMixcblx0XHRcdFx0dHlwZTogJ0ZMT0FUJ1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0bW9kZTogJ1RSSUFOR0xFX0ZBTicsXG5cdFx0XHRjb3VudDogcG9zaXRpb25zLmxlbmd0aCAvIDJcblx0XHR9KTtcbn07XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgd2ViZ2wgaW5zdGFuY2VkIHNoYXBlIHRpbGUgcmVuZGVyZXIuXG4gKi9cbmNsYXNzIEluc3RhbmNlZFRpbGVSZW5kZXJlciBleHRlbmRzIFdlYkdMVGlsZVJlbmRlcmVyIHtcblxuXHQvKipcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IEluc3RhbmNlZFRpbGVSZW5kZXJlciBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLmNvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBwb2ludHMuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuY29sb3IgPSBkZWZhdWx0VG8ob3B0aW9ucy5jb2xvciwgWyAxLjAsIDAuNCwgMC4xLCAwLjggXSk7XG5cdFx0dGhpcy5zaGFwZSA9IG51bGw7XG5cdFx0dGhpcy5zaGFkZXIgPSBudWxsO1xuXHRcdHRoaXMuYXRsYXMgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4ZWN1dGVkIHdoZW4gdGhlIGxheWVyIGlzIGF0dGFjaGVkIHRvIGEgcGxvdC5cblx0ICpcblx0ICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSBUaGUgbGF5ZXIgdG8gYXR0YWNoIHRoZSByZW5kZXJlciB0by5cblx0ICpcblx0ICogQHJldHVybnMge1JlbmRlcmVyfSBUaGUgcmVuZGVyZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRvbkFkZChsYXllcikge1xuXHRcdHN1cGVyLm9uQWRkKGxheWVyKTtcblx0XHR0aGlzLnNoYXBlID0gY3JlYXRlU3Rhcih0aGlzLmdsKTtcblx0XHR0aGlzLnNoYWRlciA9IHRoaXMuY3JlYXRlU2hhZGVyKFNIQURFUl9HTFNMKTtcblx0XHR0aGlzLmF0bGFzID0gdGhpcy5jcmVhdGVWZXJ0ZXhBdGxhcyh7XG5cdFx0XHRjaHVua1NpemU6IENIVU5LX1NJWkUsXG5cdFx0XHRhdHRyaWJ1dGVQb2ludGVyczoge1xuXHRcdFx0XHQvLyBvZmZzZXRcblx0XHRcdFx0MToge1xuXHRcdFx0XHRcdHNpemU6IDIsXG5cdFx0XHRcdFx0dHlwZTogJ0ZMT0FUJ1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyByYWRpdXNcblx0XHRcdFx0Mjoge1xuXHRcdFx0XHRcdHNpemU6IDEsXG5cdFx0XHRcdFx0dHlwZTogJ0ZMT0FUJ1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIGEgcGxvdC5cblx0ICpcblx0ICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSBUaGUgbGF5ZXIgdG8gcmVtb3ZlIHRoZSByZW5kZXJlciBmcm9tLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UmVuZGVyZXJ9IFRoZSByZW5kZXJlciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdG9uUmVtb3ZlKGxheWVyKSB7XG5cdFx0dGhpcy5kZXN0cm95VmVydGV4QXRsYXModGhpcy5hdGxhcyk7XG5cdFx0dGhpcy5hdGxhcyA9IG51bGw7XG5cdFx0dGhpcy5zaGFwZSA9IG51bGw7XG5cdFx0dGhpcy5zaGFkZXIgPSBudWxsO1xuXHRcdHN1cGVyLm9uUmVtb3ZlKGxheWVyKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgZHJhdyBmdW5jdGlvbiB0aGF0IGlzIGV4ZWN1dGVkIHBlciBmcmFtZS5cblx0ICpcblx0ICogQHJldHVybnMge1JlbmRlcmVyfSBUaGUgcmVuZGVyZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRkcmF3KCkge1xuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcblx0XHRjb25zdCBzaGFkZXIgPSB0aGlzLnNoYWRlcjtcblx0XHRjb25zdCBhdGxhcyA9IHRoaXMuYXRsYXM7XG5cdFx0Y29uc3Qgc2hhcGUgPSB0aGlzLnNoYXBlO1xuXHRcdGNvbnN0IHJlbmRlcmFibGVzID0gdGhpcy5nZXRSZW5kZXJhYmxlcygpO1xuXHRcdGNvbnN0IHByb2ogPSB0aGlzLmdldE9ydGhvTWF0cml4KCk7XG5cblx0XHQvLyBzZXQgYmxlbmRpbmcgZnVuY1xuXHRcdGdsLmVuYWJsZShnbC5CTEVORCk7XG5cdFx0Z2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG5cblx0XHQvLyBiaW5kIHNoYWRlclxuXHRcdHNoYWRlci51c2UoKTtcblxuXHRcdC8vIHNldCBnbG9iYWwgdW5pZm9ybXNcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVByb2plY3Rpb25NYXRyaXgnLCBwcm9qKTtcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndUNvbG9yJywgdGhpcy5jb2xvcik7XG5cblx0XHQvLyBiaW5kIHNoYXBlXG5cdFx0c2hhcGUuYmluZCgpO1xuXG5cdFx0Ly8gYmluZHMgdGhlIGJ1ZmZlciB0byBpbnN0YW5jZVxuXHRcdGF0bGFzLmJpbmRJbnN0YW5jZWQoKTtcblxuXHRcdC8vIGZvciBlYWNoIHJlbmRlcmFibGVcblx0XHRmb3IgKGxldCBpPTA7IGk8cmVuZGVyYWJsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IHJlbmRlcmFibGUgPSByZW5kZXJhYmxlc1tpXTtcblx0XHRcdC8vIHNldCB0aWxlIHVuaWZvcm1zXG5cdFx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVNjYWxlJywgcmVuZGVyYWJsZS5zY2FsZSk7XG5cdFx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVRpbGVPZmZzZXQnLCByZW5kZXJhYmxlLnRpbGVPZmZzZXQpO1xuXHRcdFx0Ly8gZHJhdyB0aGUgaW5zdGFuY2VzXG5cdFx0XHRhdGxhcy5kcmF3SW5zdGFuY2VkKHJlbmRlcmFibGUuaGFzaCwgc2hhcGUubW9kZSwgc2hhcGUuY291bnQpO1xuXHRcdH1cblxuXHRcdC8vIHVuYmluZFxuXHRcdGF0bGFzLnVuYmluZEluc3RhbmNlZCgpO1xuXG5cdFx0Ly8gdW5iaW5kIHF1YWRcblx0XHRzaGFwZS51bmJpbmQoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSW5zdGFuY2VkVGlsZVJlbmRlcmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkZWZhdWx0VG8gPSByZXF1aXJlKCdsb2Rhc2gvZGVmYXVsdFRvJyk7XG5jb25zdCBDaXJjbGVDb2xsaWRhYmxlID0gcmVxdWlyZSgnLi4vLi4vLi4vZ2VvbWV0cnkvQ2lyY2xlQ29sbGlkYWJsZScpO1xuY29uc3QgVmVydGV4QnVmZmVyID0gcmVxdWlyZSgnLi4vLi4vLi4vd2ViZ2wvdmVydGV4L1ZlcnRleEJ1ZmZlcicpO1xuY29uc3QgV2ViR0xUaWxlUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9XZWJHTFRpbGVSZW5kZXJlcicpO1xuXG4vLyBDb25zdGFudHNcblxuLyoqXG4gKiBOdW12ZXIgb2YgdmVydGljZXMgc3VwcG9ydGVkIHBlciBjaHVuay5cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnQge251bWJlcn1cbiAqL1xuY29uc3QgQ0hVTktfU0laRSA9IDEyOCAqIDEyODtcblxuLyoqXG4gKiBIaWdobGlnaHRlZCBwb2ludCByYWRpdXMgaW5jcmVhc2UuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50IHtudW1iZXJ9XG4gKi9cbmNvbnN0IEhJR0hMSUdIVEVEX1JBRElVU19PRkZTRVQgPSAyO1xuXG4vKipcbiAqIFNlbGVjdGVkIHBvaW50IHJhZGl1cyBpbmNyZWFzZS5cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnQge251bWJlcn1cbiAqL1xuY29uc3QgU0VMRUNURURfUkFESVVTX09GRlNFVCA9IDQ7XG5cbi8qKlxuICogUi1UcmVlIG5vZGUgY2FwYWNpdHkuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50IHtudW1iZXJ9XG4gKi9cbmNvbnN0IE5PREVfQ0FQQUNJVFkgPSAzMjtcblxuLyoqXG4gKiBTaGFkZXIgR0xTTCBzb3VyY2UuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50IHtPYmplY3R9XG4gKi9cbmNvbnN0IFNIQURFUl9HTFNMID0ge1xuXHR2ZXJ0OlxuXHRcdGBcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5cdFx0YXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xuXHRcdGF0dHJpYnV0ZSBmbG9hdCBhUmFkaXVzO1xuXHRcdHVuaWZvcm0gZmxvYXQgdVJhZGl1c09mZnNldDtcblx0XHR1bmlmb3JtIHZlYzIgdVRpbGVPZmZzZXQ7XG5cdFx0dW5pZm9ybSBmbG9hdCB1U2NhbGU7XG5cdFx0dW5pZm9ybSBmbG9hdCB1UGl4ZWxSYXRpbztcblx0XHR1bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XG5cdFx0dm9pZCBtYWluKCkge1xuXHRcdFx0dmVjMiB3UG9zaXRpb24gPSAoYVBvc2l0aW9uICogdVNjYWxlKSArIHVUaWxlT2Zmc2V0O1xuXHRcdFx0Z2xfUG9pbnRTaXplID0gKGFSYWRpdXMgKyB1UmFkaXVzT2Zmc2V0KSAqIHVTY2FsZSAqIDIuMCAqIHVQaXhlbFJhdGlvO1xuXHRcdFx0Z2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQod1Bvc2l0aW9uLCAwLjAsIDEuMCk7XG5cdFx0fVxuXHRcdGAsXG5cdGZyYWc6XG5cdFx0YFxuXHRcdCNpZmRlZiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcblx0XHRcdCNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogZW5hYmxlXG5cdFx0I2VuZGlmXG5cdFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXHRcdHVuaWZvcm0gdmVjNCB1Q29sb3I7XG5cdFx0dm9pZCBtYWluKCkge1xuXHRcdFx0dmVjMiBjeHkgPSAyLjAgKiBnbF9Qb2ludENvb3JkIC0gMS4wO1xuXHRcdFx0ZmxvYXQgcmFkaXVzID0gZG90KGN4eSwgY3h5KTtcblx0XHRcdGZsb2F0IGFscGhhID0gMS4wO1xuXHRcdFx0I2lmZGVmIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1xuXHRcdFx0XHRmbG9hdCBkZWx0YSA9IGZ3aWR0aChyYWRpdXMpO1xuXHRcdFx0XHRhbHBoYSA9IDEuMCAtIHNtb290aHN0ZXAoMS4wIC0gZGVsdGEsIDEuMCArIGRlbHRhLCByYWRpdXMpO1xuXHRcdFx0I2Vsc2Vcblx0XHRcdFx0aWYgKHJhZGl1cyA+IDEuMCkge1xuXHRcdFx0XHRcdGRpc2NhcmQ7XG5cdFx0XHRcdH1cblx0XHRcdCNlbmRpZlxuXHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCh1Q29sb3IucmdiLCB1Q29sb3IuYSAqIGFscGhhKTtcblx0XHR9XG5cdFx0YFxufTtcblxuLy8gUHJpdmF0ZSBNZXRob2RzXG5cbmNvbnN0IGNyZWF0ZVBvaW50ID0gZnVuY3Rpb24oZ2wpIHtcblx0Y29uc3QgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuXHR2ZXJ0aWNlc1swXSA9IDAuMDtcblx0dmVydGljZXNbMV0gPSAwLjA7XG5cdC8vIGNyZWF0ZSBxdWFkIGJ1ZmZlclxuXHRyZXR1cm4gbmV3IFZlcnRleEJ1ZmZlcihcblx0XHRnbCxcblx0XHR2ZXJ0aWNlcyxcblx0XHR7XG5cdFx0XHQwOiB7XG5cdFx0XHRcdHNpemU6IDIsXG5cdFx0XHRcdHR5cGU6ICdGTE9BVCdcblx0XHRcdH1cblx0XHR9LFxuXHRcdHtcblx0XHRcdG1vZGU6ICdQT0lOVFMnLFxuXHRcdFx0Y291bnQ6IDFcblx0XHR9KTtcbn07XG5cbmNvbnN0IGNyZWF0ZUNvbGxpZGFibGVzID0gZnVuY3Rpb24odGlsZSwgeE9mZnNldCwgeU9mZnNldCkge1xuXHRjb25zdCBkYXRhID0gdGlsZS5kYXRhO1xuXHRjb25zdCBjb2xsaWRhYmxlcyA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCAvIDMpO1xuXHRmb3IgKGxldCBpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrPTMpIHtcblx0XHQvLyBhZGQgY29sbGlkYWJsZVxuXHRcdGNvbGxpZGFibGVzW2kvM10gPSBuZXcgQ2lyY2xlQ29sbGlkYWJsZShcblx0XHRcdGRhdGFbaV0sIC8vIHhcblx0XHRcdGRhdGFbaSsxXSwgLy8geVxuXHRcdFx0ZGF0YVtpKzJdLCAvLyByYWRpdXNcblx0XHRcdHhPZmZzZXQsXG5cdFx0XHR5T2Zmc2V0LFxuXHRcdFx0dGlsZSk7XG5cdH1cblx0cmV0dXJuIGNvbGxpZGFibGVzO1xufTtcblxuY29uc3QgcmVuZGVyVGlsZXMgPSBmdW5jdGlvbihhdGxhcywgc2hhZGVyLCByZW5kZXJhYmxlcywgY29sb3IpIHtcblx0Ly8gc2V0IGdsb2JhbCB1bmlmb3Jtc1xuXHRzaGFkZXIuc2V0VW5pZm9ybSgndUNvbG9yJywgY29sb3IpO1xuXHRzaGFkZXIuc2V0VW5pZm9ybSgndVJhZGl1c09mZnNldCcsIDApO1xuXG5cdC8vIGJpbmRzIHRoZSBidWZmZXIgdG8gaW5zdGFuY2Vcblx0YXRsYXMuYmluZCgpO1xuXG5cdC8vIGZvciBlYWNoIHJlbmRlcmFibGVcblx0Zm9yIChsZXQgaT0wOyBpPHJlbmRlcmFibGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3QgcmVuZGVyYWJsZSA9IHJlbmRlcmFibGVzW2ldO1xuXHRcdC8vIHNldCB0aWxlIHVuaWZvcm1zXG5cdFx0c2hhZGVyLnNldFVuaWZvcm0oJ3VTY2FsZScsIHJlbmRlcmFibGUuc2NhbGUpO1xuXHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1VGlsZU9mZnNldCcsIHJlbmRlcmFibGUudGlsZU9mZnNldCk7XG5cdFx0Ly8gZHJhdyBwb2ludHNcblx0XHRhdGxhcy5kcmF3KHJlbmRlcmFibGUuaGFzaCwgJ1BPSU5UUycpO1xuXHR9XG5cblx0Ly8gdW5iaW5kXG5cdGF0bGFzLnVuYmluZCgpO1xufTtcblxuY29uc3QgcmVuZGVyUG9pbnQgPSBmdW5jdGlvbihwb2ludCwgc2hhZGVyLCBwbG90LCB0YXJnZXQsIGNvbG9yLCByYWRpdXMpIHtcblx0Ly8gZ2V0IHRpbGUgb2Zmc2V0XG5cdGNvbnN0IGNvb3JkID0gdGFyZ2V0LnRpbGUuY29vcmQ7XG5cdGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMiwgcGxvdC56b29tIC0gY29vcmQueik7XG5cdGNvbnN0IHZpZXdwb3J0ID0gcGxvdC5nZXRWaWV3cG9ydFBpeGVsT2Zmc2V0KCk7XG5cdGNvbnN0IHRpbGVPZmZzZXQgPSBbXG5cdFx0KCgoY29vcmQueCAqIHBsb3QudGlsZVNpemUpICsgdGFyZ2V0LngpICogc2NhbGUpIC0gdmlld3BvcnQueCxcblx0XHQoKChjb29yZC55ICogcGxvdC50aWxlU2l6ZSkgKyB0YXJnZXQueSkgKiBzY2FsZSkgLSB2aWV3cG9ydC55XG5cdF07XG5cdC8vIHNldCB1bmlmb3Jtc1xuXHRzaGFkZXIuc2V0VW5pZm9ybSgndVRpbGVPZmZzZXQnLCB0aWxlT2Zmc2V0KTtcblx0c2hhZGVyLnNldFVuaWZvcm0oJ3VTY2FsZScsIHNjYWxlKTtcblx0c2hhZGVyLnNldFVuaWZvcm0oJ3VDb2xvcicsIGNvbG9yKTtcblx0c2hhZGVyLnNldFVuaWZvcm0oJ3VSYWRpdXNPZmZzZXQnLCByYWRpdXMgKyB0YXJnZXQucmFkaXVzKTtcblx0Ly8gYmluZHMgdGhlIGJ1ZmZlciB0byBpbnN0YW5jZVxuXHRwb2ludC5iaW5kKCk7XG5cdC8vIGRyYXcgdGhlIHBvaW50c1xuXHRwb2ludC5kcmF3KCk7XG5cdC8vIHVuYmluZFxuXHRwb2ludC51bmJpbmQoKTtcbn07XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgd2ViZ2wgaW50ZXJhY3RpdmUgcG9pbnQgdGlsZSByZW5kZXJlci5cbiAqL1xuY2xhc3MgSW50ZXJhY3RpdmVUaWxlUmVuZGVyZXIgZXh0ZW5kcyBXZWJHTFRpbGVSZW5kZXJlciB7XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBJbnRlcmFjdGl2ZVRpbGVSZW5kZXJlciBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLmNvbG9yIC0gVGhlIGNvbG9yIG9mIHRoZSBwb2ludHMuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuY29sb3IgPSBkZWZhdWx0VG8ob3B0aW9ucy5jb2xvciwgWyAxLjAsIDAuNCwgMC4xLCAwLjggXSk7XG5cdFx0dGhpcy5zaGFkZXIgPSBudWxsO1xuXHRcdHRoaXMucG9pbnQgPSBudWxsO1xuXHRcdHRoaXMudHJlZSA9IG51bGw7XG5cdFx0dGhpcy5hdGxhcyA9IG51bGw7XG5cdFx0dGhpcy5leHQgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4ZWN1dGVkIHdoZW4gdGhlIGxheWVyIGlzIGF0dGFjaGVkIHRvIGEgcGxvdC5cblx0ICpcblx0ICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSBUaGUgbGF5ZXIgdG8gYXR0YWNoIHRoZSByZW5kZXJlciB0by5cblx0ICpcblx0ICogQHJldHVybnMge1JlbmRlcmVyfSBUaGUgcmVuZGVyZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRvbkFkZChsYXllcikge1xuXHRcdHN1cGVyLm9uQWRkKGxheWVyKTtcblx0XHQvLyBnZXQgdGhlIGV4dGVuc2lvbiBmb3Igc3RhbmRhcmQgZGVyaXZhdGl2ZXNcblx0XHR0aGlzLmV4dCA9IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnKTtcblx0XHR0aGlzLnBvaW50ID0gY3JlYXRlUG9pbnQodGhpcy5nbCk7XG5cdFx0dGhpcy5zaGFkZXIgPSB0aGlzLmNyZWF0ZVNoYWRlcihTSEFERVJfR0xTTCk7XG5cdFx0dGhpcy50cmVlID0gdGhpcy5jcmVhdGVSVHJlZVB5cmFtaWQoe1xuXHRcdFx0bm9kZUNhcGFjaXR5OiBOT0RFX0NBUEFDSVRZLFxuXHRcdFx0Y3JlYXRlQ29sbGlkYWJsZXM6IGNyZWF0ZUNvbGxpZGFibGVzXG5cdFx0fSk7XG5cdFx0dGhpcy5hdGxhcyA9IHRoaXMuY3JlYXRlVmVydGV4QXRsYXMoe1xuXHRcdFx0Y2h1bmtTaXplOiBDSFVOS19TSVpFLFxuXHRcdFx0YXR0cmlidXRlUG9pbnRlcnM6IHtcblx0XHRcdFx0Ly8gcG9zaXRpb25cblx0XHRcdFx0MDoge1xuXHRcdFx0XHRcdHNpemU6IDIsXG5cdFx0XHRcdFx0dHlwZTogJ0ZMT0FUJ1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyByYWRpdXNcblx0XHRcdFx0MToge1xuXHRcdFx0XHRcdHNpemU6IDEsXG5cdFx0XHRcdFx0dHlwZTogJ0ZMT0FUJ1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIGEgcGxvdC5cblx0ICpcblx0ICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSBUaGUgbGF5ZXIgdG8gcmVtb3ZlIHRoZSByZW5kZXJlciBmcm9tLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UmVuZGVyZXJ9IFRoZSByZW5kZXJlciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdG9uUmVtb3ZlKGxheWVyKSB7XG5cdFx0dGhpcy5kZXN0cm95VmVydGV4QXRsYXModGhpcy5hdGxhcyk7XG5cdFx0dGhpcy5kZXN0cm95UlRyZWVQeXJhbWlkKHRoaXMudHJlZSk7XG5cdFx0dGhpcy5hdGxhcyA9IG51bGw7XG5cdFx0dGhpcy5zaGFkZXIgPSBudWxsO1xuXHRcdHRoaXMucG9pbnQgPSBudWxsO1xuXHRcdHRoaXMudHJlZSA9IG51bGw7XG5cdFx0dGhpcy5leHQgPSBudWxsO1xuXHRcdHN1cGVyLm9uUmVtb3ZlKGxheWVyKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBQaWNrIGEgcG9zaXRpb24gb2YgdGhlIHJlbmRlcmVyIGZvciBhIGNvbGxpc2lvbiB3aXRoIGFueSByZW5kZXJlZCBvYmplY3RzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcG9zIC0gVGhlIHBsb3QgcG9zaXRpb24gdG8gcGljayBhdC5cblx0ICpcblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIGNvbGxpc2lvbiwgaWYgYW55LlxuXHQgKi9cblx0cGljayhwb3MpIHtcblx0XHRpZiAodGhpcy5sYXllci5wbG90LmlzWm9vbWluZygpKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMudHJlZS5zZWFyY2hQb2ludChcblx0XHRcdHBvcy54LFxuXHRcdFx0cG9zLnksXG5cdFx0XHR0aGlzLmxheWVyLnBsb3Quem9vbSxcblx0XHRcdHRoaXMubGF5ZXIucGxvdC5nZXRQaXhlbEV4dGVudCgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgZHJhdyBmdW5jdGlvbiB0aGF0IGlzIGV4ZWN1dGVkIHBlciBmcmFtZS5cblx0ICpcblx0ICogQHJldHVybnMge1JlbmRlcmVyfSBUaGUgcmVuZGVyZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRkcmF3KCkge1xuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcblx0XHRjb25zdCBsYXllciA9IHRoaXMubGF5ZXI7XG5cdFx0Y29uc3QgcGxvdCA9IGxheWVyLnBsb3Q7XG5cdFx0Y29uc3QgcHJvamVjdGlvbiA9IHRoaXMuZ2V0T3J0aG9NYXRyaXgoKTtcblx0XHRjb25zdCBzaGFkZXIgPSB0aGlzLnNoYWRlcjtcblxuXHRcdC8vIGJpbmQgcmVuZGVyIHRhcmdldFxuXHRcdHBsb3QucmVuZGVyQnVmZmVyLmJpbmQoKTtcblx0XHQvLyBjbGVhciByZW5kZXIgdGFyZ2V0XG5cdFx0cGxvdC5yZW5kZXJCdWZmZXIuY2xlYXIoKTtcblxuXHRcdC8vIHNldCBibGVuZGluZyBmdW5jXG5cdFx0Z2wuZW5hYmxlKGdsLkJMRU5EKTtcblx0XHRnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkUpO1xuXG5cdFx0Ly8gdXNlIHNoYWRlclxuXHRcdHNoYWRlci51c2UoKTtcblxuXHRcdC8vIHNldCB1bmlmb3Jtc1xuXHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1UHJvamVjdGlvbk1hdHJpeCcsIHByb2plY3Rpb24pO1xuXHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1UGl4ZWxSYXRpbycsIHBsb3QucGl4ZWxSYXRpbyk7XG5cblx0XHQvLyByZW5kZXIgdGhlIHRpbGVzXG5cdFx0cmVuZGVyVGlsZXMoXG5cdFx0XHR0aGlzLmF0bGFzLFxuXHRcdFx0c2hhZGVyLFxuXHRcdFx0dGhpcy5nZXRSZW5kZXJhYmxlcygpLFxuXHRcdFx0dGhpcy5jb2xvcik7XG5cblx0XHQvLyByZW5kZXIgc2VsZWN0ZWRcblx0XHRsYXllci5nZXRTZWxlY3RlZCgpLmZvckVhY2goc2VsZWN0ZWQgPT4ge1xuXHRcdFx0cmVuZGVyUG9pbnQoXG5cdFx0XHRcdHRoaXMucG9pbnQsXG5cdFx0XHRcdHNoYWRlcixcblx0XHRcdFx0cGxvdCxcblx0XHRcdFx0c2VsZWN0ZWQsXG5cdFx0XHRcdHRoaXMuY29sb3IsXG5cdFx0XHRcdFNFTEVDVEVEX1JBRElVU19PRkZTRVQpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gcmVuZGVyIGhpZ2hsaWdodGVkXG5cdFx0Y29uc3QgaGlnaGxpZ2h0ZWQgPSBsYXllci5nZXRIaWdobGlnaHRlZCgpO1xuXHRcdGlmIChoaWdobGlnaHRlZCAmJiAhbGF5ZXIuaXNTZWxlY3RlZChoaWdobGlnaHRlZCkpIHtcblx0XHRcdHJlbmRlclBvaW50KFxuXHRcdFx0XHR0aGlzLnBvaW50LFxuXHRcdFx0XHRzaGFkZXIsXG5cdFx0XHRcdHBsb3QsXG5cdFx0XHRcdGhpZ2hsaWdodGVkLFxuXHRcdFx0XHR0aGlzLmNvbG9yLFxuXHRcdFx0XHRISUdITElHSFRFRF9SQURJVVNfT0ZGU0VUKTtcblx0XHR9XG5cblx0XHQvLyB1bmJpbmQgcmVuZGVyIHRhcmdldFxuXHRcdHBsb3QucmVuZGVyQnVmZmVyLnVuYmluZCgpO1xuXG5cdFx0Ly8gcmVuZGVyIGZyYW1lYnVmZmVyIHRvIHRoZSBiYWNrYnVmZmVyXG5cdFx0cGxvdC5yZW5kZXJCdWZmZXIuYmxpdFRvU2NyZWVuKHRoaXMubGF5ZXIub3BhY2l0eSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmFjdGl2ZVRpbGVSZW5kZXJlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZGVmYXVsdFRvID0gcmVxdWlyZSgnbG9kYXNoL2RlZmF1bHRUbycpO1xuY29uc3QgV2ViR0xUaWxlUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9XZWJHTFRpbGVSZW5kZXJlcicpO1xuXG4vLyBDb25zdGFudHNcblxuLyoqXG4gKiBOdW12ZXIgb2YgdmVydGljZXMgc3VwcG9ydGVkIHBlciBjaHVuay5cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnQge251bWJlcn1cbiAqL1xuY29uc3QgQ0hVTktfU0laRSA9IDEyOCAqIDEyODtcblxuLyoqXG4gKiBTaGFkZXIgR0xTTCBzb3VyY2UuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50IHtPYmplY3R9XG4gKi9cbmNvbnN0IFNIQURFUl9HTFNMID0ge1xuXHR2ZXJ0OlxuXHRcdGBcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5cdFx0YXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xuXHRcdGF0dHJpYnV0ZSBmbG9hdCBhUmFkaXVzO1xuXHRcdHVuaWZvcm0gdmVjMiB1VGlsZU9mZnNldDtcblx0XHR1bmlmb3JtIGZsb2F0IHVTY2FsZTtcblx0XHR1bmlmb3JtIGZsb2F0IHVQaXhlbFJhdGlvO1xuXHRcdHVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcblx0XHR2b2lkIG1haW4oKSB7XG5cdFx0XHR2ZWMyIHdQb3NpdGlvbiA9IChhUG9zaXRpb24gKiB1U2NhbGUpICsgdVRpbGVPZmZzZXQ7XG5cdFx0XHRnbF9Qb2ludFNpemUgPSBhUmFkaXVzICogMi4wICogdVBpeGVsUmF0aW87XG5cdFx0XHRnbF9Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uTWF0cml4ICogdmVjNCh3UG9zaXRpb24sIDAuMCwgMS4wKTtcblx0XHR9XG5cdFx0YCxcblx0ZnJhZzpcblx0XHRgXG5cdFx0I2lmZGVmIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1xuXHRcdFx0I2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGVcblx0XHQjZW5kaWZcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5cdFx0dW5pZm9ybSB2ZWM0IHVDb2xvcjtcblx0XHR2b2lkIG1haW4oKSB7XG5cdFx0XHR2ZWMyIGN4eSA9IDIuMCAqIGdsX1BvaW50Q29vcmQgLSAxLjA7XG5cdFx0XHRmbG9hdCByYWRpdXMgPSBkb3QoY3h5LCBjeHkpO1xuXHRcdFx0ZmxvYXQgYWxwaGEgPSAxLjA7XG5cdFx0XHQjaWZkZWYgR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXG5cdFx0XHRcdGZsb2F0IGRlbHRhID0gZndpZHRoKHJhZGl1cyk7XG5cdFx0XHRcdGFscGhhID0gMS4wIC0gc21vb3Roc3RlcCgxLjAgLSBkZWx0YSwgMS4wICsgZGVsdGEsIHJhZGl1cyk7XG5cdFx0XHQjZWxzZVxuXHRcdFx0XHRpZiAocmFkaXVzID4gMS4wKSB7XG5cdFx0XHRcdFx0ZGlzY2FyZDtcblx0XHRcdFx0fVxuXHRcdFx0I2VuZGlmXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KHVDb2xvci5yZ2IsIHVDb2xvci5hICogYWxwaGEpO1xuXHRcdH1cblx0XHRgXG59O1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHdlYmdsIHBvaW50IHRpbGUgcmVuZGVyZXIuXG4gKi9cbmNsYXNzIFBvaW50VGlsZVJlbmRlcmVyIGV4dGVuZHMgV2ViR0xUaWxlUmVuZGVyZXIge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgUG9pbnRUaWxlUmVuZGVyZXIgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdC5cblx0ICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy5jb2xvciAtIFRoZSBjb2xvciBvZiB0aGUgcG9pbnRzLlxuXHQgKi9cblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmNvbG9yID0gZGVmYXVsdFRvKG9wdGlvbnMuY29sb3IsIFsgMS4wLCAwLjQsIDAuMSwgMC44IF0pO1xuXHRcdHRoaXMuc2hhZGVyID0gbnVsbDtcblx0XHR0aGlzLmF0bGFzID0gbnVsbDtcblx0XHR0aGlzLmV4dCA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogRXhlY3V0ZWQgd2hlbiB0aGUgbGF5ZXIgaXMgYXR0YWNoZWQgdG8gYSBwbG90LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0xheWVyfSBsYXllciAtIFRoZSBsYXllciB0byBhdHRhY2ggdGhlIHJlbmRlcmVyIHRvLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UmVuZGVyZXJ9IFRoZSByZW5kZXJlciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdG9uQWRkKGxheWVyKSB7XG5cdFx0c3VwZXIub25BZGQobGF5ZXIpO1xuXHRcdC8vIGdldCB0aGUgZXh0ZW5zaW9uIGZvciBzdGFuZGFyZCBkZXJpdmF0aXZlc1xuXHRcdHRoaXMuZXh0ID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycpO1xuXHRcdHRoaXMuc2hhZGVyID0gdGhpcy5jcmVhdGVTaGFkZXIoU0hBREVSX0dMU0wpO1xuXHRcdHRoaXMuYXRsYXMgPSB0aGlzLmNyZWF0ZVZlcnRleEF0bGFzKHtcblx0XHRcdGNodW5rU2l6ZTogQ0hVTktfU0laRSxcblx0XHRcdGF0dHJpYnV0ZVBvaW50ZXJzOiB7XG5cdFx0XHRcdC8vIHBvc2l0aW9uXG5cdFx0XHRcdDA6IHtcblx0XHRcdFx0XHRzaXplOiAyLFxuXHRcdFx0XHRcdHR5cGU6ICdGTE9BVCdcblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gcmFkaXVzXG5cdFx0XHRcdDE6IHtcblx0XHRcdFx0XHRzaXplOiAxLFxuXHRcdFx0XHRcdHR5cGU6ICdGTE9BVCdcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4ZWN1dGVkIHdoZW4gdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSBhIHBsb3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyIC0gVGhlIGxheWVyIHRvIHJlbW92ZSB0aGUgcmVuZGVyZXIgZnJvbS5cblx0ICpcblx0ICogQHJldHVybnMge1JlbmRlcmVyfSBUaGUgcmVuZGVyZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRvblJlbW92ZShsYXllcikge1xuXHRcdHRoaXMuZGVzdHJveVZlcnRleEF0bGFzKHRoaXMuYXRsYXMpO1xuXHRcdHRoaXMuYXRsYXMgPSBudWxsO1xuXHRcdHRoaXMuc2hhZGVyID0gbnVsbDtcblx0XHR0aGlzLmV4dCA9IG51bGw7XG5cdFx0c3VwZXIub25SZW1vdmUobGF5ZXIpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBkcmF3IGZ1bmN0aW9uIHRoYXQgaXMgZXhlY3V0ZWQgcGVyIGZyYW1lLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UmVuZGVyZXJ9IFRoZSByZW5kZXJlciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdGRyYXcoKSB7XG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xuXHRcdGNvbnN0IHNoYWRlciA9IHRoaXMuc2hhZGVyO1xuXHRcdGNvbnN0IGF0bGFzID0gdGhpcy5hdGxhcztcblx0XHRjb25zdCBwbG90ID0gdGhpcy5sYXllci5wbG90O1xuXHRcdGNvbnN0IHJlbmRlcmFibGVzID0gdGhpcy5nZXRSZW5kZXJhYmxlcygpO1xuXHRcdGNvbnN0IHByb2ogPSB0aGlzLmdldE9ydGhvTWF0cml4KCk7XG5cblx0XHQvLyBiaW5kIHJlbmRlciB0YXJnZXRcblx0XHRwbG90LnJlbmRlckJ1ZmZlci5iaW5kKCk7XG5cdFx0Ly8gY2xlYXIgcmVuZGVyIHRhcmdldFxuXHRcdHBsb3QucmVuZGVyQnVmZmVyLmNsZWFyKCk7XG5cblx0XHQvLyBzZXQgYmxlbmRpbmcgZnVuY1xuXHRcdGdsLmVuYWJsZShnbC5CTEVORCk7XG5cdFx0Z2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FKTtcblxuXHRcdC8vIGJpbmQgc2hhZGVyXG5cdFx0c2hhZGVyLnVzZSgpO1xuXG5cdFx0Ly8gc2V0IGdsb2JhbCB1bmlmb3Jtc1xuXHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1UHJvamVjdGlvbk1hdHJpeCcsIHByb2opO1xuXHRcdHNoYWRlci5zZXRVbmlmb3JtKCd1Q29sb3InLCB0aGlzLmNvbG9yKTtcblx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVBpeGVsUmF0aW8nLCBwbG90LnBpeGVsUmF0aW8pO1xuXG5cdFx0Ly8gYmluZHMgdGhlIHZlcnRleCBhdGxhc1xuXHRcdGF0bGFzLmJpbmQoKTtcblxuXHRcdC8vIGZvciBlYWNoIHJlbmRlcmFibGVcblx0XHRmb3IgKGxldCBpPTA7IGk8cmVuZGVyYWJsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IHJlbmRlcmFibGUgPSByZW5kZXJhYmxlc1tpXTtcblx0XHRcdC8vIHNldCB0aWxlIHVuaWZvcm1zXG5cdFx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVNjYWxlJywgcmVuZGVyYWJsZS5zY2FsZSk7XG5cdFx0XHRzaGFkZXIuc2V0VW5pZm9ybSgndVRpbGVPZmZzZXQnLCByZW5kZXJhYmxlLnRpbGVPZmZzZXQpO1xuXHRcdFx0Ly8gZHJhdyB0aGUgcG9pbnRzXG5cdFx0XHRhdGxhcy5kcmF3KHJlbmRlcmFibGUuaGFzaCwgJ1BPSU5UUycpO1xuXHRcdH1cblxuXHRcdC8vIHVuYmluZFxuXHRcdGF0bGFzLnVuYmluZCgpO1xuXG5cdFx0Ly8gdW5iaW5kIHJlbmRlciB0YXJnZXRcblx0XHRwbG90LnJlbmRlckJ1ZmZlci51bmJpbmQoKTtcblxuXHRcdC8vIHJlbmRlciBmcmFtZWJ1ZmZlciB0byB0aGUgYmFja2J1ZmZlclxuXHRcdHBsb3QucmVuZGVyQnVmZmVyLmJsaXRUb1NjcmVlbih0aGlzLmxheWVyLm9wYWNpdHkpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludFRpbGVSZW5kZXJlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2FyYXNhdGFzYXlnaW4vaXMuanMvYmxvYi9tYXN0ZXIvaXMuanNcblxuY29uc3QgdXNlckFnZW50ID0gKG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuY29uc3QgdmVuZG9yID0gKG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudmVuZG9yIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4vKipcbiAqIFRlc3QgaWYgdGhlIGJyb3dzZXIgaXMgZmlyZWZveC5cbiAqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEByZXR1cm5zIHtBcnJheX0gV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgaXMgZmlyZWZveC5cbiAqL1xuY29uc3QgaXNGaXJlZm94ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB1c2VyQWdlbnQubWF0Y2goLyg/OmZpcmVmb3h8Znhpb3MpXFwvKFxcZCspLyk7XG59O1xuXG4vKipcbiAqIFRlc3QgaWYgdGhlIGJyb3dzZXIgaXMgY2hyb21lLlxuICpcbiAqIEBwcml2YXRlXG4gKlxuICogQHJldHVybnMge0FycmF5fSBXaGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciBpcyBjaHJvbWUuXG4gKi9cbmNvbnN0IGlzQ2hyb21lID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiAvZ29vZ2xlIGluYy8udGVzdCh2ZW5kb3IpID8gdXNlckFnZW50Lm1hdGNoKC8oPzpjaHJvbWV8Y3Jpb3MpXFwvKFxcZCspLykgOiBudWxsO1xufTtcblxuLyoqXG4gKiBUZXN0IGlmIHRoZSBicm93c2VyIGlzIGludGVybmV0IGV4cGxvcmVyLlxuICpcbiAqIEBwcml2YXRlXG4gKlxuICogQHJldHVybnMge0FycmF5fSBXaGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciBpcyBpbnRlcm5ldCBleHBsb3Jlci5cbiAqL1xuY29uc3QgaXNJRSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdXNlckFnZW50Lm1hdGNoKC8oPzptc2llIHx0cmlkZW50Lis/OyBydjopKFxcZCspLyk7XG59O1xuXG4vKipcbiAqIFRlc3QgaWYgdGhlIGJyb3dzZXIgaXMgZWRnZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEByZXR1cm5zIHtBcnJheX0gV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgaXMgZWRnZS5cbiAqL1xuY29uc3QgaXNFZGdlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB1c2VyQWdlbnQubWF0Y2goL2VkZ2VcXC8oXFxkKykvKTtcbn07XG5cbi8qKlxuICogVGVzdCBpZiB0aGUgYnJvd3NlciBpcyBvcGVyYS5cbiAqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEByZXR1cm5zIHtBcnJheX0gV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgaXMgb3BlcmEuXG4gKi9cbmNvbnN0IGlzT3BlcmEgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHVzZXJBZ2VudC5tYXRjaCgvKD86Xm9wZXJhLis/dmVyc2lvbnxvcHIpXFwvKFxcZCspLyk7XG59O1xuXG4vKipcbiAqIFRlc3QgaWYgdGhlIGJyb3dzZXIgaXMgc2FmYXJpLlxuICpcbiAqIEBwcml2YXRlXG4gKlxuICogQHJldHVybnMge0FycmF5fSBXaGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciBpcyBzYWZhcmkuXG4gKi9cbmNvbnN0IGlzU2FmYXJpID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB1c2VyQWdlbnQubWF0Y2goL3ZlcnNpb25cXC8oXFxkKykuKz9zYWZhcmkvKTtcbn07XG5cbi8qKlxuICogQnJvd3NlciBkZXRlY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuXHQvKipcblx0ICogV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgaXMgZmlyZWZveC5cblx0ICogQGNvbnN0YW50IHtib29sZWFufVxuXHQgKi9cblx0ZmlyZWZveDogISFpc0ZpcmVmb3goKSxcblxuXHQvKipcblx0ICogV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgaXMgY2hyb21lLlxuXHQgKiBAY29uc3RhbnQge2Jvb2xlYW59XG5cdCAqL1xuXHRjaHJvbWU6ICEhaXNDaHJvbWUoKSxcblxuXHQvKipcblx0ICogV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgaXMgaWUuXG5cdCAqIEBjb25zdGFudCB7Ym9vbGVhbn1cblx0ICovXG5cdGllOiAhIWlzSUUoKSxcblxuXHQvKipcblx0ICogV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgaXMgZWRnZS5cblx0ICogQGNvbnN0YW50IHtib29sZWFufVxuXHQgKi9cblx0ZWRnZTogISFpc0VkZ2UoKSxcblxuXHQvKipcblx0ICogV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgaXMgb3BlcmEuXG5cdCAqIEBjb25zdGFudCB7Ym9vbGVhbn1cblx0ICovXG5cdG9wZXJhOiAhIWlzT3BlcmEoKSxcblxuXHQvKipcblx0ICogV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgaXMgc2FmYXJpLlxuXHQgKiBAY29uc3RhbnQge2Jvb2xlYW59XG5cdCAqL1xuXHRzYWZhcmk6ICEhaXNTYWZhcmkoKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZGVmYXVsdFRvID0gcmVxdWlyZSgnbG9kYXNoL2RlZmF1bHRUbycpO1xuY29uc3QgTGlua2VkTGlzdCA9IHJlcXVpcmUoJy4vTGlua2VkTGlzdCcpO1xuXG4vLyBDb25zdGFudHNcblxuLyoqXG4gKiBNYXggc2l6ZSBzeW1ib2wuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50IHtTeW1ib2x9XG4gKi9cbmNvbnN0IENBUEFDSVRZID0gU3ltYm9sKCk7XG5cbi8qKlxuICogRGlzcG9zZSBmdW5jdGlvbiBzeW1ib2wuXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50IHtTeW1ib2x9XG4gKi9cbmNvbnN0IE9OX1JFTU9WRSA9IFN5bWJvbCgpO1xuXG4vKipcbiAqIENhY2hlIHN5bWJvbC5cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnQge1N5bWJvbH1cbiAqL1xuY29uc3QgQ0FDSEUgPSBTeW1ib2woKTtcblxuLyoqXG4gKiBMUlUgbGlua2VkIGxpc3Qgc3ltYm9sLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxuICovXG5jb25zdCBMUlVfTElTVCA9IFN5bWJvbCgpO1xuXG4vKipcbiAqIExSVSBsZW5ndGggc3ltYm9sLlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudCB7U3ltYm9sfVxuICovXG5jb25zdCBMRU5HVEggPSBTeW1ib2woKTtcblxuLy8gUHJpdmF0ZSBNZXRob2RzXG5cbmNvbnN0IGRlbCA9IGZ1bmN0aW9uKHNlbGYsIG5vZGUpIHtcblx0aWYgKG5vZGUpIHtcblx0XHRjb25zdCBoaXQgPSBub2RlLnZhbHVlO1xuXHRcdGlmIChzZWxmW09OX1JFTU9WRV0pIHtcblx0XHRcdHNlbGZbT05fUkVNT1ZFXShoaXQudmFsdWUsIGhpdC5rZXkpO1xuXHRcdH1cblx0XHRzZWxmW0xFTkdUSF0tLTtcblx0XHRzZWxmW0NBQ0hFXS5kZWxldGUoaGl0LmtleSk7XG5cdFx0c2VsZltMUlVfTElTVF0ucmVtb3ZlTm9kZShub2RlKTtcblx0fVxufTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gTFJVIGNhY2hlLlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgTFJVQ2FjaGUge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgTFJVQ2FjaGUgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2FwYWNpdHkgLSBUaGUgY2FwYWNpdHkgb2YgdGhlIGNhY2hlLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uUmVtb3ZlIC0gQSBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gYSB2YWx1ZSBpcyBldmljdGVkLlxuXHQgKi9cblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG5cdFx0dGhpc1tDQVBBQ0lUWV0gPSBkZWZhdWx0VG8oTWF0aC5tYXgoMSwgb3B0aW9ucy5jYXBhY2l0eSksIDI1Nik7XG5cdFx0dGhpc1tPTl9SRU1PVkVdID0gZGVmYXVsdFRvKG9wdGlvbnMub25SZW1vdmUsIG51bGwpO1xuXHRcdHRoaXMuY2xlYXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjYXBhY2l0eSBvZiB0aGUgY2FjaGUuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIGNhcGNpdHkgb2YgdGhlIGNhY2hlLlxuXHQgKi9cblx0Z2V0Q2FwYWNpdHkoKSB7XG5cdFx0cmV0dXJuIHRoaXNbQ0FQQUNJVFldO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgY2FjaGUuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIGxlbmd0aCBvZiB0aGUgY2FjaGUuXG5cdCAqL1xuXHRnZXRMZW5ndGgoKSB7XG5cdFx0cmV0dXJuIHRoaXNbTEVOR1RIXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJdGVyYXRlcyBvdmVyIGFuZCBleGVjdXRlcyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gZm9yIGFsbCB2YWx1ZXMuXG5cdCAqIE5PVEU6IERvZXMgbm90IHVwZGF0ZSByZWNlbnRuZXNzIG9mIHRoZSBlbnRyaWVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgYW5kIGtleS5cblx0ICovXG5cdGZvckVhY2goZm4pIHtcblx0XHRmb3IgKGxldCBub2RlID0gdGhpc1tMUlVfTElTVF0uaGVhZDsgbm9kZSAhPT0gbnVsbDspIHtcblx0XHRcdGNvbnN0IG5leHQgPSBub2RlLm5leHQ7XG5cdFx0XHRmbihub2RlLnZhbHVlLnZhbHVlLCBub2RlLnZhbHVlLmtleSk7XG5cdFx0XHRub2RlID0gbmV4dDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIGFsbCBlbnRyaWVzIGluIHRoZSBjYWNoZS5cblx0ICovXG5cdGNsZWFyKCkge1xuXHRcdGlmICh0aGlzW09OX1JFTU9WRV0gJiYgdGhpc1tMUlVfTElTVF0pIHtcblx0XHRcdHRoaXNbTFJVX0xJU1RdLmZvckVhY2goaGl0ID0+IHtcblx0XHRcdFx0dGhpc1tPTl9SRU1PVkVdKGhpdC52YWx1ZSwgaGl0LmtleSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0dGhpc1tDQUNIRV0gPSBuZXcgTWFwKCk7XG5cdFx0dGhpc1tMUlVfTElTVF0gPSBuZXcgTGlua2VkTGlzdCgpO1xuXHRcdHRoaXNbTEVOR1RIXSA9IDA7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IGEgdmFsdWUgdW5kZXIgdGhlIHByb3ZpZGVkIGtleSwgcmVtb3ZpbmcgdGhlIHByZXZpb3VzIGVudHJ5IGlmIG9uZVxuXHQgKiBleGlzdHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHN0cmluZy5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZS5cblx0ICovXG5cdHNldChrZXksIHZhbHVlKSB7XG5cdFx0aWYgKHRoaXNbQ0FDSEVdLmhhcyhrZXkpKSB7XG5cdFx0XHQvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYW4gZW50cnlcblx0XHRcdGNvbnN0IG5vZGUgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KTtcblx0XHRcdGNvbnN0IGl0ZW0gPSBub2RlLnZhbHVlO1xuXHRcdFx0Ly8gZXhlY3V0ZSBvblJlbW92ZSBmb3Igb2xkIHZhbHVlIGJlZm9yZSBldmljdGluZ1xuXHRcdFx0aWYgKHRoaXNbT05fUkVNT1ZFXSkge1xuXHRcdFx0XHR0aGlzW09OX1JFTU9WRV0oaXRlbS52YWx1ZSwga2V5KTtcblx0XHRcdH1cblx0XHRcdC8vIHNldCB0aGUgbmV3IHZhbHVlXG5cdFx0XHRpdGVtLnZhbHVlID0gdmFsdWU7XG5cdFx0XHR0aGlzLmdldChrZXkpO1xuXHRcdFx0Ly8gbm8gbmVlZCB0byB0cmltLCBzaW5jZSB0aGUgbGVuZ3RoIHJlbWFpbmVkIGNvbnN0YW50XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdC8vIGFkZCBuZXcgZW50cnlcblx0XHRjb25zdCBoaXQgPSBuZXcgRW50cnkoa2V5LCB2YWx1ZSk7XG5cdFx0dGhpc1tMRU5HVEhdKys7XG5cdFx0dGhpc1tMUlVfTElTVF0udW5zaGlmdChoaXQpO1xuXHRcdHRoaXNbQ0FDSEVdLnNldChrZXksIHRoaXNbTFJVX0xJU1RdLmhlYWQpO1xuXHRcdC8vIHRyaW0gYW55IG9sZCBlbnRyeVxuXHRcdGlmICh0aGlzW0xFTkdUSF0gPiB0aGlzW0NBUEFDSVRZXSkge1xuXHRcdFx0Ly8gZGVsZXRlIG9sZGVzdCBlbnRyeVxuXHRcdFx0ZGVsKHRoaXMsIHRoaXNbTFJVX0xJU1RdLnRhaWwpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBlbnRyeSBpcyBpbiB0aGUgTFJVIGNhY2hlIHVuZGVyIHRoZSBwcm92aWRlZFxuXHQgKiBrZXkuXG5cdCAqIE5PVEU6IERvZXMgbm90IHVwZGF0ZSByZWNlbnRuZXNzIG9mIHRoZSBlbnRyeS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgc3RyaW5nLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGtleSBleGlzdHMuXG5cdCAqL1xuXHRoYXMoa2V5KSB7XG5cdFx0aWYgKCF0aGlzW0NBQ0hFXS5oYXMoa2V5KSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBlbnRyeSBpbiB0aGUgTFJVIGNhY2hlIHVuZGVyIHRoZSBwcm92aWRlZCBrZXkuXG5cdCAqIE5PVEU6IFVwZGF0ZXMgdGhlIHJlY2VudG5lc3Mgb2YgdGhlIGVudHJ5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBzdHJpbmcuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgaW4gdGhlIGNhY2hlLlxuXHQgKi9cblx0Z2V0KGtleSkge1xuXHRcdGNvbnN0IG5vZGUgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KTtcblx0XHRpZiAobm9kZSkge1xuXHRcdFx0Ly8gdXBkYXRlIHJlY2VudG5lc3Ncblx0XHRcdHRoaXNbTFJVX0xJU1RdLnVuc2hpZnROb2RlKG5vZGUpO1xuXHRcdFx0cmV0dXJuIG5vZGUudmFsdWUudmFsdWU7XG5cdFx0fVxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZW50cnkgaW4gdGhlIExSVSBjYWNoZSB1bmRlciB0aGUgcHJvdmlkZWQga2V5LlxuXHQgKiBOT1RFOiBEb2VzIG5vdCB1cGRhdGUgcmVjZW50bmVzcyBvZiB0aGUgZW50cnkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHN0cmluZy5cblx0ICpcblx0ICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSBpbiB0aGUgY2FjaGUuXG5cdCAqL1xuXHRwZWVrKGtleSkge1xuXHRcdGNvbnN0IG5vZGUgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KTtcblx0XHRpZiAobm9kZSkge1xuXHRcdFx0cmV0dXJuIG5vZGUudmFsdWUudmFsdWU7XG5cdFx0fVxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgZW50cnkgaW4gdGhlIExSVSBjYWNoZSB1bmRlciB0aGUgcHJvdmlkZWQga2V5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBzdHJpbmcuXG5cdCAqL1xuXHRkZWxldGUoa2V5KSB7XG5cdFx0ZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKTtcblx0fVxufVxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBMUlUgY2FjaGUgZW50cnkuXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBFbnRyeSB7XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBFbnRyeSBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUgZW50cnkga2V5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIGVudHJ5IHZhbHVlLlxuXHQgKi9cblx0Y29uc3RydWN0b3Ioa2V5LCB2YWx1ZSkge1xuXHRcdHRoaXMua2V5ID0ga2V5O1xuXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExSVUNhY2hlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGxpbmtlZCBsaXN0LlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgTGlua2VkTGlzdCB7XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlcyBhIG5ldyBMaW5rZWRMaXN0IG9iamVjdC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMudGFpbCA9IG51bGw7XG5cdFx0dGhpcy5oZWFkID0gbnVsbDtcblx0XHR0aGlzLmxlbmd0aCA9IDA7XG5cdH1cblxuXHQvKipcblx0ICogUHVzaCBhbiBpdGVtIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmtlZCBsaXN0LlxuXHQgKlxuXHQgKiBAcGFyYW0geyp9IGl0ZW0gLSBUaGUgaXRlbSB0byBhZGQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBuZXcgbGVuZ3RoIG9mIHRoZSBsaXN0LlxuXHQgKi9cblx0cHVzaChpdGVtKSB7XG5cdFx0dGhpcy50YWlsID0gbmV3IE5vZGUoaXRlbSwgdGhpcy50YWlsLCBudWxsLCB0aGlzKTtcblx0XHRpZiAoIXRoaXMuaGVhZCkge1xuXHRcdFx0dGhpcy5oZWFkID0gdGhpcy50YWlsO1xuXHRcdH1cblx0XHR0aGlzLmxlbmd0aCsrO1xuXHRcdHJldHVybiB0aGlzLmxlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQgKiBQdXNoIGFuIGl0ZW0gdG8gdGhlIGZyb250IG9mIHRoZSBsaW5rZWQgbGlzdC5cblx0ICpcblx0ICogQHBhcmFtIHsqfSBpdGVtIC0gVGhlIGl0ZW0gdG8gYWRkLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbmV3IGxlbmd0aCBvZiB0aGUgbGlzdC5cblx0ICovXG5cdHVuc2hpZnQoaXRlbSkge1xuXHRcdHRoaXMuaGVhZCA9IG5ldyBOb2RlKGl0ZW0sIG51bGwsIHRoaXMuaGVhZCwgdGhpcyk7XG5cdFx0aWYgKCF0aGlzLnRhaWwpIHtcblx0XHRcdHRoaXMudGFpbCA9IHRoaXMuaGVhZDtcblx0XHR9XG5cdFx0dGhpcy5sZW5ndGgrKztcblx0XHRyZXR1cm4gdGhpcy5sZW5ndGg7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlIGFuIGl0ZW0gZnJvbnQgdGhlIGVuZCBvZiB0aGUgbGlua2VkIGxpc3QuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHsqfSBUaGUgcmVtb3ZlZCB2YWx1ZS5cblx0ICovXG5cdHBvcCgpIHtcblx0XHRpZiAoIXRoaXMudGFpbCkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Y29uc3QgcmVzID0gdGhpcy50YWlsLnZhbHVlO1xuXHRcdHRoaXMudGFpbCA9IHRoaXMudGFpbC5wcmV2O1xuXHRcdGlmICh0aGlzLnRhaWwpIHtcblx0XHRcdHRoaXMudGFpbC5uZXh0ID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5oZWFkID0gbnVsbDtcblx0XHR9XG5cdFx0dGhpcy5sZW5ndGgtLTtcblx0XHRyZXR1cm4gcmVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbiBpdGVtIGZyb20gdGhlIGZyb250IG9mIHRoZSBsaW5rZWQgbGlzdC5cblx0ICpcblx0ICogQHJldHVybnMgeyp9IFRoZSByZW1vdmVkIHZhbHVlLlxuXHQgKi9cblx0c2hpZnQoKSB7XG5cdFx0aWYgKCF0aGlzLmhlYWQpIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGNvbnN0IHJlcyA9IHRoaXMuaGVhZC52YWx1ZTtcblx0XHR0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcblx0XHRpZiAodGhpcy5oZWFkKSB7XG5cdFx0XHR0aGlzLmhlYWQucHJldiA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudGFpbCA9IG51bGw7XG5cdFx0fVxuXHRcdHRoaXMubGVuZ3RoLS07XG5cdFx0cmV0dXJuIHJlcztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgYW4gaXRlbSBhdCBhIHBhcnRpY3VsYXIgaW5kZXggaW4gdGhlIGxpc3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBuIC0gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlLlxuXHQgKi9cblx0Z2V0KG4pIHtcblx0XHRsZXQgaTtcblx0XHRsZXQgbm9kZTtcblx0XHRmb3IgKGkgPSAwLCBub2RlID0gdGhpcy5oZWFkOyBub2RlICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcblx0XHRcdC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuXHRcdFx0bm9kZSA9IG5vZGUubmV4dDtcblx0XHR9XG5cdFx0aWYgKGkgPT09IG4gJiYgbm9kZSAhPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIG5vZGUudmFsdWU7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEl0ZXJhdGVzIG92ZXIgYW5kIGV4ZWN1dGVzIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBmb3IgYWxsIHZhbHVlcy5cblx0ICpcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIHZhbHVlLlxuXHQgKi9cblx0Zm9yRWFjaChmbikge1xuXHRcdGZvciAobGV0IG5vZGUgPSB0aGlzLmhlYWQsIGkgPSAwOyBub2RlICE9PSBudWxsOyBpKyspIHtcblx0XHRcdGZuKG5vZGUudmFsdWUsIGkpO1xuXHRcdFx0bm9kZSA9IG5vZGUubmV4dDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSXRlcmF0ZXMgb3ZlciBhbmQgZXhlY3V0ZXMgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGZvciBhbGwgdmFsdWVzIHJldHVybmluZ1xuXHQgKiBhbiBhcnJheSBvZiBhbGwgbWFwcGVkIHZhbHVlcy5cblx0ICpcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIHRpbGUuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFycmF5IG9mIG1hcHBlZCB2YWx1ZXMuXG5cdCAqL1xuXHRtYXAoZm4pIHtcblx0XHRjb25zdCBhcnIgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXHRcdGZvciAobGV0IGkgPSAwLCBub2RlID0gdGhpcy5oZWFkOyBub2RlICE9PSBudWxsOyBpKyspIHtcblx0XHRcdGFycltpXSA9IGZuKG5vZGUudmFsdWUsIGkpO1xuXHRcdFx0bm9kZSA9IG5vZGUubmV4dDtcblx0XHR9XG5cdFx0cmV0dXJuIGFycjtcblx0fVxuXG5cdC8qKlxuXHQgKiBQdXNoIGEgbm9kZSB0byB0aGUgZW5kIG9mIHRoZSBsaW5rZWQgbGlzdC5cblx0ICpcblx0ICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgdG8gYWRkLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbmV3IGxlbmd0aCBvZiB0aGUgbGlzdC5cblx0ICovXG5cdHB1c2hOb2RlKG5vZGUpIHtcblx0XHRpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmIChub2RlLmxpc3QpIHtcblx0XHRcdG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpO1xuXHRcdH1cblx0XHRjb25zdCB0YWlsID0gdGhpcy50YWlsO1xuXHRcdG5vZGUubGlzdCA9IHRoaXM7XG5cdFx0bm9kZS5wcmV2ID0gdGFpbDtcblx0XHRpZiAodGFpbCkge1xuXHRcdFx0dGFpbC5uZXh0ID0gbm9kZTtcblx0XHR9XG5cdFx0dGhpcy50YWlsID0gbm9kZTtcblx0XHRpZiAoIXRoaXMuaGVhZCkge1xuXHRcdFx0dGhpcy5oZWFkID0gbm9kZTtcblx0XHR9XG5cdFx0dGhpcy5sZW5ndGgrKztcblx0XHRyZXR1cm4gdGhpcy5sZW5ndGg7XG5cdH1cblxuXHQvKipcblx0ICogUHVzaCBhIG5vZGUgdG8gdGhlIGZyb250IG9mIHRoZSBsaW5rZWQgbGlzdC5cblx0ICpcblx0ICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgdG8gYWRkLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbmV3IGxlbmd0aCBvZiB0aGUgbGlzdC5cblx0ICovXG5cdHVuc2hpZnROb2RlKG5vZGUpIHtcblx0XHRpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmIChub2RlLmxpc3QpIHtcblx0XHRcdG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpO1xuXHRcdH1cblx0XHRjb25zdCBoZWFkID0gdGhpcy5oZWFkO1xuXHRcdG5vZGUubGlzdCA9IHRoaXM7XG5cdFx0bm9kZS5uZXh0ID0gaGVhZDtcblx0XHRpZiAoaGVhZCkge1xuXHRcdFx0aGVhZC5wcmV2ID0gbm9kZTtcblx0XHR9XG5cdFx0dGhpcy5oZWFkID0gbm9kZTtcblx0XHRpZiAoIXRoaXMudGFpbCkge1xuXHRcdFx0dGhpcy50YWlsID0gbm9kZTtcblx0XHR9XG5cdFx0dGhpcy5sZW5ndGgrKztcblx0XHRyZXR1cm4gdGhpcy5sZW5ndGg7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlIGEgbm9kZSBmcm9tIHRoZSBsaW5rZWQgbGlzdC5cblx0ICpcblx0ICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgdG8gcmVtb3ZlLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbmV3IGxlbmd0aCBvZiB0aGUgbGlzdC5cblx0ICovXG5cdHJlbW92ZU5vZGUobm9kZSkge1xuXHRcdGlmIChub2RlLmxpc3QgIT09IHRoaXMpIHtcblx0XHRcdHRocm93ICdSZW1vdmluZyBub2RlIHdoaWNoIGRvZXMgbm90IGJlbG9uZyB0byB0aGlzIGxpc3QnO1xuXHRcdH1cblx0XHRjb25zdCBuZXh0ID0gbm9kZS5uZXh0O1xuXHRcdGNvbnN0IHByZXYgPSBub2RlLnByZXY7XG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fVxuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuXHRcdH1cblx0XHRpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG5cdFx0XHR0aGlzLmhlYWQgPSBuZXh0O1xuXHRcdH1cblx0XHRpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG5cdFx0XHR0aGlzLnRhaWwgPSBwcmV2O1xuXHRcdH1cblx0XHRub2RlLmxpc3QubGVuZ3RoLS07XG5cdFx0bm9kZS5uZXh0ID0gbnVsbDtcblx0XHRub2RlLnByZXYgPSBudWxsO1xuXHRcdG5vZGUubGlzdCA9IG51bGw7XG5cdFx0cmV0dXJuIHRoaXMubGVuZ3RoO1xuXHR9XG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbGlua2VkIGxpc3Qgbm9kZS5cbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIE5vZGUge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgTm9kZSBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIG5vZGUuXG5cdCAqIEBwYXJhbSB7Tm9kZX0gcHJldiAtIFRoZSBwcmV2aW91cyBub2RlLlxuXHQgKiBAcGFyYW0ge05vZGV9IG5leHQgLSBUaGUgbmV4dCBub2RlLlxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3R9IGxpc3QgLSBUaGUgbGlua2VkIGxpc3QuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih2YWx1ZSwgcHJldiwgbmV4dCwgbGlzdCkge1xuXHRcdHRoaXMubGlzdCA9IGxpc3Q7XG5cdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHRwcmV2Lm5leHQgPSB0aGlzO1xuXHRcdFx0dGhpcy5wcmV2ID0gcHJldjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wcmV2ID0gbnVsbDtcblx0XHR9XG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHRoaXM7XG5cdFx0XHR0aGlzLm5leHQgPSBuZXh0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm5leHQgPSBudWxsO1xuXHRcdH1cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtlZExpc3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogSXNzdWVzIGEgWEhSIGFuZCBsb2FkcyBhbiBBcnJheUJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIHVybC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgLSBUaGUgY2FsbGJhY2suXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXJsLCBkb25lKSB7XG5cdGNvbnN0IHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRyZXEub3BlbignR0VUJywgdXJsLCB0cnVlKTtcblx0cmVxLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cdHJlcS5vbmxvYWQgPSAoKSA9PiB7XG5cdFx0Y29uc3QgYXJyYXlidWZmZXIgPSByZXEucmVzcG9uc2U7XG5cdFx0aWYgKGFycmF5YnVmZmVyKSB7XG5cdFx0XHRkb25lKG51bGwsIGFycmF5YnVmZmVyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgZXJyID0gYFVuYWJsZSB0byBsb2FkIEFycmF5QnVmZmVyIGZyb20gVVJMOiBcXGAke2V2ZW50LnBhdGhbMF0uY3VycmVudFNyY31cXGBgO1xuXHRcdFx0ZG9uZShlcnIsIG51bGwpO1xuXHRcdH1cblx0fTtcblx0cmVxLm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcblx0XHRjb25zdCBlcnIgPSBgVW5hYmxlIHRvIGxvYWQgQXJyYXlCdWZmZXIgZnJvbSBVUkw6IFxcYCR7ZXZlbnQucGF0aFswXS5jdXJyZW50U3JjfVxcYGA7XG5cdFx0ZG9uZShlcnIsIG51bGwpO1xuXHR9O1xuXHRyZXEud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblx0cmVxLnNlbmQobnVsbCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIElzc3VlcyBhIFhIUiBhbmQgbG9hZHMgYW4gSW1hZ2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSB1cmwuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lIC0gVGhlIGNhbGxiYWNrLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVybCwgZG9uZSkge1xuXHRjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuXHRpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG5cdFx0ZG9uZShudWxsLCBpbWFnZSk7XG5cdH07XG5cdGltYWdlLm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcblx0XHRjb25zdCBlcnIgPSBgVW5hYmxlIHRvIGxvYWQgaW1hZ2UgZnJvbSBVUkw6IFxcYCR7ZXZlbnQucGF0aFswXS5jdXJyZW50U3JjfVxcYGA7XG5cdFx0ZG9uZShlcnIsIG51bGwpO1xuXHR9O1xuXHRpbWFnZS5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuXHRpbWFnZS5zcmMgPSB1cmw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBUZXh0dXJlID0gcmVxdWlyZSgnLi90ZXh0dXJlL1RleHR1cmUnKTtcbmNvbnN0IFNoYWRlciA9IHJlcXVpcmUoJy4vc2hhZGVyL1NoYWRlcicpO1xuY29uc3QgVmVydGV4QnVmZmVyID0gcmVxdWlyZSgnLi92ZXJ0ZXgvVmVydGV4QnVmZmVyJyk7XG5cbi8vIENvbnN0YW50c1xuXG4vKipcbiAqIFNoYWRlciBHTFNMIHNvdXJjZS5cbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnQge09iamVjdH1cbiAqL1xuY29uc3QgU0hBREVSX0dMU0wgPSB7XG5cdHZlcnQ6XG5cdFx0YFxuXHRcdHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblx0XHRhdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247XG5cdFx0YXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcblx0XHR2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcblx0XHR2b2lkIG1haW4odm9pZCkge1xuXHRcdFx0dlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XG5cdFx0XHRnbF9Qb3NpdGlvbiA9IHZlYzQoYVZlcnRleFBvc2l0aW9uLCAxLjApO1xuXHRcdH1cblx0XHRgLFxuXHRmcmFnOlxuXHRcdGBcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5cdFx0dW5pZm9ybSBmbG9hdCB1T3BhY2l0eTtcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZVNhbXBsZXI7XG5cdFx0dmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG5cdFx0dm9pZCBtYWluKHZvaWQpIHtcblx0XHRcdHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcblx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IucmdiLCBjb2xvci5hICogdU9wYWNpdHkpO1xuXHRcdH1cblx0XHRgXG59O1xuXG4vLyBQcml2YXRlIE1ldGhvZHNcblxuY29uc3QgY3JlYXRlUXVhZCA9IGZ1bmN0aW9uKGdsLCBtaW4sIG1heCkge1xuXHRjb25zdCB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoMjQpO1xuXHQvLyBwb3NpdGlvbnNcblx0dmVydGljZXNbMF0gPSBtaW47XG5cdHZlcnRpY2VzWzFdID0gbWluO1xuXHR2ZXJ0aWNlc1syXSA9IG1heDtcblx0dmVydGljZXNbM10gPSBtaW47XG5cdHZlcnRpY2VzWzRdID0gbWF4O1xuXHR2ZXJ0aWNlc1s1XSA9IG1heDtcblx0dmVydGljZXNbNl0gPSBtaW47XG5cdHZlcnRpY2VzWzddID0gbWluO1xuXHR2ZXJ0aWNlc1s4XSA9IG1heDtcblx0dmVydGljZXNbOV0gPSBtYXg7XG5cdHZlcnRpY2VzWzEwXSA9IG1pbjtcblx0dmVydGljZXNbMTFdID0gbWF4O1xuXHQvLyB1dnNcblx0dmVydGljZXNbMTJdID0gMDtcblx0dmVydGljZXNbMTNdID0gMDtcblx0dmVydGljZXNbMTRdID0gMTtcblx0dmVydGljZXNbMTVdID0gMDtcblx0dmVydGljZXNbMTZdID0gMTtcblx0dmVydGljZXNbMTddID0gMTtcblx0dmVydGljZXNbMThdID0gMDtcblx0dmVydGljZXNbMTldID0gMDtcblx0dmVydGljZXNbMjBdID0gMTtcblx0dmVydGljZXNbMjFdID0gMTtcblx0dmVydGljZXNbMjJdID0gMDtcblx0dmVydGljZXNbMjNdID0gMTtcblx0Ly8gY3JlYXRlIHF1YWQgYnVmZmVyXG5cdHJldHVybiBuZXcgVmVydGV4QnVmZmVyKFxuXHRcdGdsLFxuXHRcdHZlcnRpY2VzLFxuXHRcdHtcblx0XHRcdDA6IHtcblx0XHRcdFx0c2l6ZTogMixcblx0XHRcdFx0dHlwZTogJ0ZMT0FUJyxcblx0XHRcdFx0Ynl0ZU9mZnNldDogMFxuXHRcdFx0fSxcblx0XHRcdDE6IHtcblx0XHRcdFx0c2l6ZTogMixcblx0XHRcdFx0dHlwZTogJ0ZMT0FUJyxcblx0XHRcdFx0Ynl0ZU9mZnNldDogMiAqIDYgKiA0XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR7XG5cdFx0XHRjb3VudDogNixcblx0XHR9KTtcbn07XG5cbmNvbnN0IHNldENvbG9yVGFyZ2V0ID0gZnVuY3Rpb24oZ2wsIGZyYW1lYnVmZmVyLCBhdHRhY2htZW50LCBpbmRleCkge1xuXHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcblx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG5cdFx0Z2wuRlJBTUVCVUZGRVIsXG5cdFx0Z2xbYENPTE9SX0FUVEFDSE1FTlQke2luZGV4fWBdLFxuXHRcdGdsLlRFWFRVUkVfMkQsXG5cdFx0YXR0YWNobWVudC50ZXh0dXJlLFxuXHRcdDApO1xuXHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xufTtcblxuY29uc3QgcmVuZGVyVG9TY3JlZW4gPSBmdW5jdGlvbihnbCwgdGV4dHVyZSwgc2hhZGVyLCBxdWFkLCBvcGFjaXR5KSB7XG5cdC8vIGJpbmQgc2hhZGVyXG5cdHNoYWRlci51c2UoKTtcblx0Ly8gc2V0IGJsZW5kaW5nIGZ1bmNcblx0Z2wuZW5hYmxlKGdsLkJMRU5EKTtcblx0Z2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG5cdC8vIHNldCB1bmlmb3Jtc1xuXHRzaGFkZXIuc2V0VW5pZm9ybSgndU9wYWNpdHknLCBvcGFjaXR5KTtcblx0Ly8gc2V0IHRleHR1cmUgc2FtcGxlciB1bml0XG5cdHNoYWRlci5zZXRVbmlmb3JtKCd1VGV4dHVyZVNhbXBsZXInLCAwKTtcblx0Ly8gYmluZCB0ZXh0dXJlXG5cdHRleHR1cmUuYmluZCgwKTtcblx0Ly8gZHJhdyBxdWFkXG5cdHF1YWQuYmluZCgpO1xuXHRxdWFkLmRyYXcoKTtcblx0cXVhZC51bmJpbmQoKTtcbn07XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgd2ViZ2wgcmVuZGVyYnVmZmVyLlxuICovXG5jbGFzcyBSZW5kZXJCdWZmZXIge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBSZW5kZXJCdWZmZXIgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBUaGUgV2ViR0wgY29udGV4dC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSByZW5kZXJidWZmZXIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSByZW5kZXJidWZmZXIuXG5cdCAqL1xuXHQgY29uc3RydWN0b3IoZ2wsIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR0aGlzLmdsID0gZ2w7XG5cdFx0dGhpcy5mcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cdFx0dGhpcy5zaGFkZXIgPSBuZXcgU2hhZGVyKGdsLCBTSEFERVJfR0xTTCk7XG5cdFx0dGhpcy5xdWFkID0gY3JlYXRlUXVhZChnbCwgLTEsIDEpO1xuXHRcdHRoaXMudGV4dHVyZSA9IG5ldyBUZXh0dXJlKGdsLCBudWxsLCB7XG5cdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdGZpbHRlcjogJ05FQVJFU1QnLFxuXHRcdFx0aW52ZXJ0WTogZmFsc2UsXG5cdFx0XHRwcmVtdWx0aXBseUFscGhhOiBmYWxzZVxuXHRcdH0pO1xuXHRcdHNldENvbG9yVGFyZ2V0KFxuXHRcdFx0dGhpcy5nbCxcblx0XHRcdHRoaXMuZnJhbWVidWZmZXIsXG5cdFx0XHR0aGlzLnRleHR1cmUsXG5cdFx0XHQwKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaW5kcyB0aGUgcmVuZGVyYnVmZmVyIGZvciB3cml0aW5nLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UmVuZGVyQnVmZmVyfSBUaGUgcmVuZGVyYnVmZmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0YmluZCgpIHtcblx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBVbmJpbmRzIHRoZSByZW5kZXJidWZmZXIgZm9yIHdyaXRpbmcuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtSZW5kZXJCdWZmZXJ9IFRoZSByZW5kZXJidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHR1bmJpbmQoKSB7XG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ2xlYXJzIHRoZSByZW5kZXJidWZmZXIgYnVmZmVyIGNvbG9yIGJpdHMuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtSZW5kZXJCdWZmZXJ9IFRoZSByZW5kZXJidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRjbGVhcigpIHtcblx0XHR0aGlzLmdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XG5cdFx0dGhpcy5nbC5jbGVhcih0aGlzLmdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJsaXRzIHRoZSByZW5kZXJidWZmZXIgdGV4dHVyZSB0byB0aGUgc2NyZWVuLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eSAtIFRoZSBvcGFjaXR5IHRvIGJsaXQgYXQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtSZW5kZXJCdWZmZXJ9IFRoZSByZW5kZXJidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRibGl0VG9TY3JlZW4ob3BhY2l0eSkge1xuXHRcdHJlbmRlclRvU2NyZWVuKFxuXHRcdFx0dGhpcy5nbCxcblx0XHRcdHRoaXMudGV4dHVyZSxcblx0XHRcdHRoaXMuc2hhZGVyLFxuXHRcdFx0dGhpcy5xdWFkLFxuXHRcdFx0b3BhY2l0eSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmVzaXplcyB0aGUgcmVuZGVyYnVmZmVyIHRvIHRoZSBwcm92aWRlZCBoZWlnaHQgYW5kIHdpZHRoLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgbmV3IHdpZHRoIG9mIHRoZSByZW5kZXJidWZmZXIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgbmV3IGhlaWdodCBvZiB0aGUgcmVuZGVyYnVmZmVyLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7UmVuZGVyQnVmZmVyfSBUaGUgcmVuZGVyYnVmZmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0cmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcblx0XHR0aGlzLnRleHR1cmUucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyQnVmZmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBtYXAgPSByZXF1aXJlKCdsb2Rhc2gvbWFwJyk7XG5jb25zdCBwYXJzZVNoYWRlciA9IHJlcXVpcmUoJy4vcGFyc2VTaGFkZXInKTtcblxuLy8gQ29uc3RhbnRzXG5cbmNvbnN0IFVOSUZPUk1fRlVOQ1RJT05TID0ge1xuXHQnYm9vbCc6ICd1bmlmb3JtMWknLFxuXHQnYm9vbFtdJzogJ3VuaWZvcm0xaXYnLFxuXHQnZmxvYXQnOiAndW5pZm9ybTFmJyxcblx0J2Zsb2F0W10nOiAndW5pZm9ybTFmdicsXG5cdCdpbnQnOiAndW5pZm9ybTFpJyxcblx0J2ludFtdJzogJ3VuaWZvcm0xaXYnLFxuXHQndWludCc6ICd1bmlmb3JtMWknLFxuXHQndWludFtdJzogJ3VuaWZvcm0xaXYnLFxuXHQndmVjMic6ICd1bmlmb3JtMmZ2Jyxcblx0J3ZlYzJbXSc6ICd1bmlmb3JtMmZ2Jyxcblx0J2l2ZWMyJzogJ3VuaWZvcm0yaXYnLFxuXHQnaXZlYzJbXSc6ICd1bmlmb3JtMml2Jyxcblx0J3ZlYzMnOiAndW5pZm9ybTNmdicsXG5cdCd2ZWMzW10nOiAndW5pZm9ybTNmdicsXG5cdCdpdmVjMyc6ICd1bmlmb3JtM2l2Jyxcblx0J2l2ZWMzW10nOiAndW5pZm9ybTNpdicsXG5cdCd2ZWM0JzogJ3VuaWZvcm00ZnYnLFxuXHQndmVjNFtdJzogJ3VuaWZvcm00ZnYnLFxuXHQnaXZlYzQnOiAndW5pZm9ybTRpdicsXG5cdCdpdmVjNFtdJzogJ3VuaWZvcm00aXYnLFxuXHQnbWF0Mic6ICd1bmlmb3JtTWF0cml4MmZ2Jyxcblx0J21hdDJbXSc6ICd1bmlmb3JtTWF0cml4MmZ2Jyxcblx0J21hdDMnOiAndW5pZm9ybU1hdHJpeDNmdicsXG5cdCdtYXQzW10nOiAndW5pZm9ybU1hdHJpeDNmdicsXG5cdCdtYXQ0JzogJ3VuaWZvcm1NYXRyaXg0ZnYnLFxuXHQnbWF0NFtdJzogJ3VuaWZvcm1NYXRyaXg0ZnYnLFxuXHQnc2FtcGxlcjJEJzogJ3VuaWZvcm0xaScsXG5cdCdzYW1wbGVyQ3ViZSc6ICd1bmlmb3JtMWknXG59O1xuXG4vLyBQcml2YXRlIE1ldGhvZHNcblxuY29uc3Qgc2V0QXR0cmlidXRlc0FuZFVuaWZvcm1zID0gZnVuY3Rpb24oc2hhZGVyLCB2ZXJ0U291cmNlLCBmcmFnU291cmNlKSB7XG5cdC8vIHBhcnNlIHNoYWRlciBkZWxjYXJhdGlvbnNcblx0Y29uc3QgZGVjbGFyYXRpb25zID0gcGFyc2VTaGFkZXIoXG5cdFx0WyB2ZXJ0U291cmNlLCBmcmFnU291cmNlIF0sXG5cdFx0WyAndW5pZm9ybScsICdhdHRyaWJ1dGUnIF0pO1xuXHQvLyBmb3IgZWFjaCBkZWNsYXJhdGlvbiBpbiB0aGUgc2hhZGVyXG5cdGRlY2xhcmF0aW9ucy5mb3JFYWNoKGRlY2xhcmF0aW9uID0+IHtcblx0XHQvLyBjaGVjayBpZiBpdHMgYW4gYXR0cmlidXRlIG9yIHVuaWZvcm1cblx0XHRpZiAoZGVjbGFyYXRpb24ucXVhbGlmaWVyID09PSAnYXR0cmlidXRlJykge1xuXHRcdFx0Ly8gaWYgYXR0cmlidXRlLCBzdG9yZSB0eXBlIGFuZCBpbmRleFxuXHRcdFx0c2hhZGVyLmF0dHJpYnV0ZXMuc2V0KGRlY2xhcmF0aW9uLm5hbWUsIHtcblx0XHRcdFx0dHlwZTogZGVjbGFyYXRpb24udHlwZSxcblx0XHRcdFx0aW5kZXg6IHNoYWRlci5hdHRyaWJ1dGVzLnNpemVcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7IC8vIGlmIChkZWNsYXJhdGlvbi5xdWFsaWZpZXIgPT09ICd1bmlmb3JtJykge1xuXHRcdFx0Ly8gaWYgdW5pZm9ybSwgc3RvcmUgdHlwZSBhbmQgYnVmZmVyIGZ1bmN0aW9uIG5hbWVcblx0XHRcdGNvbnN0IHR5cGUgPSBkZWNsYXJhdGlvbi50eXBlICsgKGRlY2xhcmF0aW9uLmNvdW50ID4gMSA/ICdbXScgOiAnJyk7XG5cdFx0XHRzaGFkZXIudW5pZm9ybXMuc2V0KGRlY2xhcmF0aW9uLm5hbWUsIHtcblx0XHRcdFx0dHlwZTogZGVjbGFyYXRpb24udHlwZSxcblx0XHRcdFx0ZnVuYzogVU5JRk9STV9GVU5DVElPTlNbdHlwZV1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG59O1xuXG5jb25zdCBmb3JtYXRMaW5lID0gZnVuY3Rpb24oc3RyLCBudW0pIHtcblx0c3RyID0gc3RyLnRvU3RyaW5nKCk7XG5cdGNvbnN0IGRpZmYgPSBudW0gLSBzdHIubGVuZ3RoO1xuXHRzdHIgKz0gJzonO1xuXHRmb3IgKGxldCBpPTA7IGk8ZGlmZjsgaSsrKSB7XG5cdFx0c3RyICs9ICcgJztcblx0fVxuXHRyZXR1cm4gc3RyO1xufTtcblxuY29uc3QgY29tcGlsZVNoYWRlciA9IGZ1bmN0aW9uKGdsLCBzaGFkZXJTb3VyY2UsIHR5cGUpIHtcblx0Y29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsW3R5cGVdKTtcblx0Z2wuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKTtcblx0Z2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXHRpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuXHRcdGNvbnN0IHNwbGl0ID0gc2hhZGVyU291cmNlLnNwbGl0KCdcXG4nKTtcblx0XHRjb25zdCBtYXhEaWdpdHMgPSAoc3BsaXQubGVuZ3RoKS50b1N0cmluZygpLmxlbmd0aCArIDE7XG5cdFx0Y29uc3Qgc3JjQnlMaW5lcyA9IHNwbGl0Lm1hcCgobGluZSwgaW5kZXgpID0+IHtcblx0XHRcdHJldHVybiBgJHtmb3JtYXRMaW5lKGluZGV4KzEsIG1heERpZ2l0cyl9ICR7bGluZX1gO1xuXHRcdH0pLmpvaW4oJ1xcbicpO1xuXHRcdGNvbnN0IHNoYWRlckxvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcblx0XHR0aHJvdyBgQW4gZXJyb3Igb2NjdXJyZWQgY29tcGlsaW5nIHRoZSBzaGFkZXI6XFxuXFxuJHtzaGFkZXJMb2cuc2xpY2UoMCwgc2hhZGVyTG9nLmxlbmd0aC0xKX1cXG4ke3NyY0J5TGluZXN9YDtcblx0fVxuXHRyZXR1cm4gc2hhZGVyO1xufTtcblxuY29uc3QgYmluZEF0dHJpYnV0ZUxvY2F0aW9ucyA9IGZ1bmN0aW9uKHNoYWRlcikge1xuXHRjb25zdCBnbCA9IHNoYWRlci5nbDtcblx0c2hhZGVyLmF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cmlidXRlLCBuYW1lKSA9PiB7XG5cdFx0Ly8gYmluZCB0aGUgYXR0cmlidXRlIGxvY2F0aW9uXG5cdFx0Z2wuYmluZEF0dHJpYkxvY2F0aW9uKHNoYWRlci5wcm9ncmFtLCBhdHRyaWJ1dGUuaW5kZXgsIG5hbWUpO1xuXHR9KTtcbn07XG5cbmNvbnN0IGdldFVuaWZvcm1Mb2NhdGlvbnMgPSBmdW5jdGlvbihzaGFkZXIpIHtcblx0Y29uc3QgZ2wgPSBzaGFkZXIuZ2w7XG5cdGNvbnN0IHVuaWZvcm1zID0gc2hhZGVyLnVuaWZvcm1zO1xuXHR1bmlmb3Jtcy5mb3JFYWNoKCh1bmlmb3JtLCBuYW1lKSA9PiB7XG5cdFx0Ly8gZ2V0IHRoZSB1bmlmb3JtIGxvY2F0aW9uXG5cdFx0Y29uc3QgbG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyLnByb2dyYW0sIG5hbWUpO1xuXHRcdC8vIGNoZWNrIGlmIG51bGwsIHBhcnNlIG1heSBkZXRlY3QgdW5pZm9ybSB0aGF0IGlzIGNvbXBpbGVkIG91dCBkdWUgdG9cblx0XHQvLyBub3QgYmVpbmcgdXNlZCwgb3IgZHVlIHRvIGEgcHJlcHJvY2Vzc29yIGV2YWx1YXRpb24uXG5cdFx0aWYgKGxvY2F0aW9uID09PSBudWxsKSB7XG5cdFx0XHR1bmlmb3Jtcy5kZWxldGUobmFtZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHVuaWZvcm0ubG9jYXRpb24gPSBsb2NhdGlvbjtcblx0XHR9XG5cdH0pO1xufTtcblxuY29uc3QgY3JlYXRlRGVmaW5lcyA9IGZ1bmN0aW9uKGRlZmluZXMpIHtcblx0cmV0dXJuIG1hcChkZWZpbmVzLCAodmFsdWUsIG5hbWUpID0+IHtcblx0XHRyZXR1cm4gYCNkZWZpbmUgJHtuYW1lfSAke3ZhbHVlfWA7XG5cdH0pLmpvaW4oJ1xcbicpO1xufTtcblxuY29uc3QgY3JlYXRlUHJvZ3JhbSA9IGZ1bmN0aW9uKHNoYWRlciwgc291cmNlcykge1xuXHQvLyBDcmVhdGVzIHRoZSBzaGFkZXIgcHJvZ3JhbSBvYmplY3QgZnJvbSBzb3VyY2Ugc3RyaW5ncy4gVGhpcyBpbmNsdWRlczpcblx0Ly9cdDEpIENvbXBpbGluZyBhbmQgbGlua2luZyB0aGUgc2hhZGVyIHByb2dyYW0uXG5cdC8vXHQyKSBQYXJzaW5nIHNoYWRlciBzb3VyY2UgZm9yIGF0dHJpYnV0ZSBhbmQgdW5pZm9ybSBpbmZvcm1hdGlvbi5cblx0Ly9cdDMpIEJpbmRpbmcgYXR0cmlidXRlIGxvY2F0aW9ucywgYnkgb3JkZXIgb2YgZGVsY2FyYXRpb24uXG5cdC8vXHQ0KSBRdWVyeWluZyBhbmQgc3RvcmluZyB1bmlmb3JtIGxvY2F0aW9uLlxuXHRjb25zdCBnbCA9IHNoYWRlci5nbDtcblx0Y29uc3QgZGVmaW5lcyA9IGNyZWF0ZURlZmluZXMoc291cmNlcy5kZWZpbmUpO1xuXHRjb25zdCBjb21tb24gPSBkZWZpbmVzICsgKHNvdXJjZXMuY29tbW9uIHx8ICcnKTtcblx0Y29uc3QgdmVydCA9IGNvbW1vbiArIHNvdXJjZXMudmVydDtcblx0Y29uc3QgZnJhZyA9IGNvbW1vbiArIHNvdXJjZXMuZnJhZztcblx0Ly8gY29tcGlsZSBzaGFkZXJzXG5cdGNvbnN0IHZlcnRleFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIHZlcnQsICdWRVJURVhfU0hBREVSJyk7XG5cdGNvbnN0IGZyYWdtZW50U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgZnJhZywgJ0ZSQUdNRU5UX1NIQURFUicpO1xuXHQvLyBwYXJzZSBzb3VyY2UgZm9yIGF0dHJpYnV0ZSBhbmQgdW5pZm9ybXNcblx0c2V0QXR0cmlidXRlc0FuZFVuaWZvcm1zKHNoYWRlciwgdmVydCwgZnJhZyk7XG5cdC8vIGNyZWF0ZSB0aGUgc2hhZGVyIHByb2dyYW1cblx0c2hhZGVyLnByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cdC8vIGF0dGFjaCB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlcnNcblx0Z2wuYXR0YWNoU2hhZGVyKHNoYWRlci5wcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuXHRnbC5hdHRhY2hTaGFkZXIoc2hhZGVyLnByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcblx0Ly8gYmluZCB2ZXJ0ZXggYXR0cmlidXRlIGxvY2F0aW9ucyBCRUZPUkUgbGlua2luZ1xuXHRiaW5kQXR0cmlidXRlTG9jYXRpb25zKHNoYWRlcik7XG5cdC8vIGxpbmsgc2hhZGVyXG5cdGdsLmxpbmtQcm9ncmFtKHNoYWRlci5wcm9ncmFtKTtcblx0Ly8gSWYgY3JlYXRpbmcgdGhlIHNoYWRlciBwcm9ncmFtIGZhaWxlZCwgYWxlcnRcblx0aWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHNoYWRlci5wcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcblx0XHR0aHJvdyBgQW4gZXJyb3Igb2NjdXJlZCBsaW5raW5nIHRoZSBzaGFkZXI6XFxuJHtnbC5nZXRQcm9ncmFtSW5mb0xvZyhzaGFkZXIucHJvZ3JhbSl9YDtcblx0fVxuXHQvLyBnZXQgc2hhZGVyIHVuaWZvcm0gbG9jYXRpb25zXG5cdGdldFVuaWZvcm1Mb2NhdGlvbnMoc2hhZGVyKTtcbn07XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgc2hhZGVyIHByb2dyYW0uXG4gKi9cbmNsYXNzIFNoYWRlciB7XG5cblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlcyBhIFNoYWRlciBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFRoZSBXZWJHTCBjb250ZXh0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHNoYWRlciBwYXJhbXMgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNvbW1vbiAtIENvbW1vbiBnbHNsIHRvIGJlIHNoYXJlZCBieSBib3RoIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVycy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy52ZXJ0IC0gVGhlIHZlcnRleCBzaGFkZXIgZ2xzbC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5mcmFnIC0gVGhlIGZyYWdtZW50IHNoYWRlciBnbHNsLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zLmRlZmluZSAtIEFueSAjZGVmaW5lIGRpcmVjdGl2ZXMgdG8gaW5jbHVkZSBpbiB0aGUgZ2xzbC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKGdsLCBwYXJhbXMgPSB7fSkge1xuXHRcdC8vIGNoZWNrIHNvdXJjZSBhcmd1bWVudHNcblx0XHRpZiAoIXBhcmFtcy52ZXJ0KSB7XG5cdFx0XHR0aHJvdyAnVmVydGV4IHNoYWRlciBhcmd1bWVudCBgdmVydGAgaGFzIG5vdCBiZWVuIHByb3ZpZGVkJztcblx0XHR9XG5cdFx0aWYgKCFwYXJhbXMuZnJhZykge1xuXHRcdFx0dGhyb3cgJ0ZyYWdtZW50IHNoYWRlciBhcmd1bWVudCBgZnJhZ2AgaGFzIG5vdCBiZWVuIHByb3ZpZGVkJztcblx0XHR9XG5cdFx0dGhpcy5nbCA9IGdsO1xuXHRcdHRoaXMucHJvZ3JhbSA9IG51bGw7XG5cdFx0dGhpcy5hdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuXHRcdHRoaXMudW5pZm9ybXMgPSBuZXcgTWFwKCk7XG5cdFx0Ly8gY3JlYXRlIHRoZSBzaGFkZXIgcHJvZ3JhbVxuXHRcdGNyZWF0ZVByb2dyYW0odGhpcywgcGFyYW1zKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaW5kcyB0aGUgc2hhZGVyIHByb2dyYW0gZm9yIHVzZS5cblx0ICpcblx0ICogQHJldHVybnMge1NoYWRlcn0gVGhlIHNoYWRlciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHVzZSgpIHtcblx0XHQvLyB1c2UgdGhlIHNoYWRlclxuXHRcdHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJ1ZmZlciBhIHVuaWZvcm0gdmFsdWUgYnkgbmFtZS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgdW5pZm9ybSBuYW1lIGluIHRoZSBzaGFkZXIgc291cmNlLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHVuaWZvcm0gdmFsdWUgdG8gYnVmZmVyLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7U2hhZGVyfSBUaGUgc2hhZGVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0c2V0VW5pZm9ybShuYW1lLCB2YWx1ZSkge1xuXHRcdGNvbnN0IHVuaWZvcm0gPSB0aGlzLnVuaWZvcm1zLmdldChuYW1lKTtcblx0XHQvLyBlbnN1cmUgdGhhdCB0aGUgdW5pZm9ybSBwYXJhbXMgZXhpc3RzIGZvciB0aGUgbmFtZVxuXHRcdGlmICghdW5pZm9ybSkge1xuXHRcdFx0dGhyb3cgYE5vIHVuaWZvcm0gZm91bmQgdW5kZXIgbmFtZSBcXGAke25hbWV9XFxgYDtcblx0XHR9XG5cdFx0Ly8gY2hlY2sgdmFsdWVcblx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gZW5zdXJlIHRoYXQgdGhlIHVuaWZvcm0gYXJndW1lbnQgaXMgZGVmaW5lZFxuXHRcdFx0dGhyb3cgYFZhbHVlIHBhc3NlZCBmb3IgdW5pZm9ybSBcXGAke25hbWV9XFxgIGlzIHVuZGVmaW5lZCBvciBudWxsYDtcblx0XHR9XG5cdFx0Ly8gc2V0IHRoZSB1bmlmb3JtXG5cdFx0Ly8gTk9URTogY2hlY2tpbmcgdHlwZSBieSBzdHJpbmcgY29tcGFyaXNvbiBpcyBmYXN0ZXIgdGhhbiB3cmFwcGluZ1xuXHRcdC8vIHRoZSBmdW5jdGlvbnMuXG5cdFx0aWYgKHVuaWZvcm0udHlwZSA9PT0gJ21hdDInIHx8IHVuaWZvcm0udHlwZSA9PT0gJ21hdDMnIHx8IHVuaWZvcm0udHlwZSA9PT0gJ21hdDQnKSB7XG5cdFx0XHR0aGlzLmdsW3VuaWZvcm0uZnVuY10odW5pZm9ybS5sb2NhdGlvbiwgZmFsc2UsIHZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5nbFt1bmlmb3JtLmZ1bmNdKHVuaWZvcm0ubG9jYXRpb24sIHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHByZXByb2Nlc3MgPSByZXF1aXJlKCcuL3ByZXByb2Nlc3MnKTtcblxuLy8gQ29uc3RhbnRzXG5cbmNvbnN0IENPTU1FTlRTX1JFR0VYUCA9IC8oXFwvXFwqKFtcXHNcXFNdKj8pXFwqXFwvKXwoXFwvXFwvKC4qKSQpL2dtO1xuY29uc3QgRU5ETElORV9SRUdFWFAgPSAvKFxcclxcbnxcXG58XFxyKS9nbTtcbmNvbnN0IFdISVRFU1BBQ0VfUkVHRVhQID0gL1xcc3syLH0vZztcbmNvbnN0IEJSQUNLRVRfV0hJVEVTUEFDRV9SRUdFWFAgPSAvKFxccyopKFxcWykoXFxzKikoXFxkKykoXFxzKikoXFxdKShcXHMqKS9nO1xuY29uc3QgTkFNRV9DT1VOVF9SRUdFWFAgPSAvKFthLXpBLVpfXVthLXpBLVowLTlfXSopKD86XFxbKFxcZCspXFxdKT8vO1xuY29uc3QgUFJFQ0lTSU9OX1JFR0VYID0gL1xcYnByZWNpc2lvblxccytcXHcrXFxzK1xcdys7L2c7XG5jb25zdCBJTkxJTkVfUFJFQ0lTSU9OX1JFR0VYID0gL1xcYihoaWdocHxtZWRpdW1wfGxvd3ApXFxzKy9nO1xuXG4vLyBQcml2YXRlIE1ldGhvZHNcblxuY29uc3Qgc3RyaXBDb21tZW50cyA9IGZ1bmN0aW9uKHN0cikge1xuXHQvLyByZWdleCBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb2Fncml1cy9zdHJpcGNvbW1lbnRzXG5cdHJldHVybiBzdHIucmVwbGFjZShDT01NRU5UU19SRUdFWFAsICcnKTtcbn07XG5cbmNvbnN0IHN0cmlwUHJlY2lzaW9uID0gZnVuY3Rpb24oc3RyKSB7XG5cdHJldHVybiBzdHJcblx0XHQucmVwbGFjZShQUkVDSVNJT05fUkVHRVgsICcnKSAvLyByZW1vdmUgZ2xvYmFsIHByZWNpc2lvbiBkZWNsYXJhdGlvbnNcblx0XHQucmVwbGFjZShJTkxJTkVfUFJFQ0lTSU9OX1JFR0VYLCAnJyk7IC8vIHJlbW92ZSBpbmxpbmUgcHJlY2lzaW9uIGRlY2xhcmF0aW9uc1xufTtcblxuY29uc3Qgbm9ybWFsaXplV2hpdGVzcGFjZSA9IGZ1bmN0aW9uKHN0cikge1xuXHRyZXR1cm4gc3RyXG5cdFx0LnJlcGxhY2UoRU5ETElORV9SRUdFWFAsICcgJykgLy8gbm9ybWFsaXplIGxpbmUgZW5kaW5nc1xuXHRcdC5yZXBsYWNlKFdISVRFU1BBQ0VfUkVHRVhQLCAnICcpIC8vIG5vcm1hbGl6ZSB3aGl0ZXNwYWNlIHRvIHNpbmdsZSAnICdcblx0XHQucmVwbGFjZShCUkFDS0VUX1dISVRFU1BBQ0VfUkVHRVhQLCAnJDIkNCQ2Jyk7IC8vIHJlbW92ZSB3aGl0ZXNwYWNlIGluIGJyYWNrZXRzXG59O1xuXG5jb25zdCBwYXJzZU5hbWVBbmRDb3VudCA9IGZ1bmN0aW9uKHF1YWxpZmllciwgdHlwZSwgZW50cnkpIHtcblx0Ly8gZGV0ZXJtaW5lIG5hbWUgYW5kIHNpemUgb2YgdmFyaWFibGVcblx0Y29uc3QgbWF0Y2hlcyA9IGVudHJ5Lm1hdGNoKE5BTUVfQ09VTlRfUkVHRVhQKTtcblx0Y29uc3QgbmFtZSA9IG1hdGNoZXNbMV07XG5cdGNvbnN0IGNvdW50ID0gKG1hdGNoZXNbMl0gPT09IHVuZGVmaW5lZCkgPyAxIDogcGFyc2VJbnQobWF0Y2hlc1syXSwgMTApO1xuXHRyZXR1cm4ge1xuXHRcdHF1YWxpZmllcjogcXVhbGlmaWVyLFxuXHRcdHR5cGU6IHR5cGUsXG5cdFx0bmFtZTogbmFtZSxcblx0XHRjb3VudDogY291bnRcblx0fTtcbn07XG5cbmNvbnN0IHBhcnNlU3RhdGVtZW50ID0gZnVuY3Rpb24oc3RhdGVtZW50KSB7XG5cdC8vIHNwbGl0IHN0YXRlbWVudCBvbiBjb21tYXNcblx0Ly9cblx0Ly8gWyd1bmlmb3JtIG1hdDQgQVsxMF0nLCAnQicsICdDWzJdJ11cblx0Ly9cblx0Y29uc3Qgc3BsaXQgPSBzdGF0ZW1lbnQuc3BsaXQoJywnKS5tYXAoZWxlbSA9PiB7XG5cdFx0cmV0dXJuIGVsZW0udHJpbSgpO1xuXHR9KTtcblxuXHQvLyBzcGxpdCBkZWNsYXJhdGlvbiBoZWFkZXIgZnJvbSBzdGF0ZW1lbnRcblx0Ly9cblx0Ly8gWyd1bmlmb3JtJywgJ21hdDQnLCAnQVsxMF0nXVxuXHQvL1xuXHRjb25zdCBoZWFkZXIgPSBzcGxpdC5zaGlmdCgpLnNwbGl0KCcgJyk7XG5cblx0Ly8gcXVhbGlmaWVyIGlzIGFsd2F5cyBmaXJzdCBlbGVtZW50XG5cdC8vXG5cdC8vICd1bmlmb3JtJ1xuXHQvL1xuXHRjb25zdCBxdWFsaWZpZXIgPSBoZWFkZXIuc2hpZnQoKTtcblxuXHQvLyB0eXBlIHdpbGwgYmUgdGhlIHNlY29uZCBlbGVtZW50XG5cdC8vXG5cdC8vICdtYXQ0J1xuXHQvL1xuXHRjb25zdCB0eXBlID0gaGVhZGVyLnNoaWZ0KCk7XG5cblx0Ly8gbGFzdCBwYXJ0IG9mIGhlYWRlciB3aWxsIGJlIHRoZSBmaXJzdCwgYW5kIHBvc3NpYmxlIG9ubHkgdmFyaWFibGUgbmFtZVxuXHQvL1xuXHQvLyBbJ0FbMTBdJywgJ0InLCAnQ1syXSddXG5cdC8vXG5cdGNvbnN0IG5hbWVzID0gaGVhZGVyLmNvbmNhdChzcGxpdCk7XG5cblx0Ly8gaWYgdGhlcmUgYXJlIG90aGVyIG5hbWVzIGFmdGVyIGEgJywnIGFkZCB0aGVtIGFzIHdlbGxcblx0cmV0dXJuIG5hbWVzLm1hcChuYW1lID0+IHtcblx0XHRyZXR1cm4gcGFyc2VOYW1lQW5kQ291bnQocXVhbGlmaWVyLCB0eXBlLCBuYW1lKTtcblx0fSk7XG59O1xuXG5jb25zdCBwYXJzZVNvdXJjZSA9IGZ1bmN0aW9uKHNvdXJjZSwga2V5d29yZHMpIHtcblx0Ly8gc3BsaXRzIHRoZSBzb3VyY2Ugc3RyaW5nIGJ5IHNlbWktY29sb25zIGFuZCBjb25zdHJ1Y3RzIGFuIGFycmF5IG9mXG5cdC8vIGRlY2xhcmF0aW9uIG9iamVjdHMgYmFzZWQgb24gdGhlIHByb3ZpZGVkIHF1YWxpZmllciBrZXl3b3Jkcy5cblxuXHQvLyBnZXQgaW5kaXZpZHVhbCBzdGF0ZW1lbnRzIChhbnkgc2VxdWVuY2UgZW5kaW5nIGluIDspXG5cdGNvbnN0IHN0YXRlbWVudHMgPSBzb3VyY2Uuc3BsaXQoJzsnKTtcblx0Ly8gYnVpbGQgcmVnZXggZm9yIHBhcnNpbmcgc3RhdGVtZW50cyB3aXRoIHRhcmdldHRlZCBrZXl3b3Jkc1xuXHRjb25zdCBrZXl3b3JkU3RyID0ga2V5d29yZHMuam9pbignfCcpO1xuXHRjb25zdCBrZXl3b3JkUmVnZXggPSBuZXcgUmVnRXhwKCdcXFxcYignICsga2V5d29yZFN0ciArICcpXFxcXGIuKicpO1xuXHQvLyBwYXJzZSBhbmQgc3RvcmUgZ2xvYmFsIHByZWNpc2lvbiBzdGF0ZW1lbnRzIGFuZCBhbnkgZGVjbGFyYXRpb25zXG5cdGxldCBtYXRjaGVkID0gW107XG5cdC8vIGZvciBlYWNoIHN0YXRlbWVudFxuXHRzdGF0ZW1lbnRzLmZvckVhY2goc3RhdGVtZW50ID0+IHtcblx0XHQvLyBjaGVjayBmb3Iga2V5d29yZHNcblx0XHQvL1xuXHRcdC8vIFsndW5pZm9ybSBmbG9hdCB1VGltZSddXG5cdFx0Ly9cblx0XHRjb25zdCBrbWF0Y2ggPSBzdGF0ZW1lbnQubWF0Y2goa2V5d29yZFJlZ2V4KTtcblx0XHRpZiAoa21hdGNoKSB7XG5cdFx0XHQvLyBwYXJzZSBzdGF0ZW1lbnQgYW5kIGFkZCB0byBhcnJheVxuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoZWQuY29uY2F0KHBhcnNlU3RhdGVtZW50KGttYXRjaFswXSkpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuY29uc3QgZmlsdGVyRHVwbGljYXRlc0J5TmFtZSA9IGZ1bmN0aW9uKGRlY2xhcmF0aW9ucykge1xuXHQvLyBpbiBjYXNlcyB3aGVyZSB0aGUgc2FtZSBkZWNsYXJhdGlvbnMgYXJlIHByZXNlbnQgaW4gbXVsdGlwbGVcblx0Ly8gc291cmNlcywgdGhpcyBmdW5jdGlvbiB3aWxsIHJlbW92ZSBkdXBsaWNhdGVzIGZyb20gdGhlIHJlc3VsdHNcblx0Y29uc3Qgc2VlbiA9IHt9O1xuXHRyZXR1cm4gZGVjbGFyYXRpb25zLmZpbHRlcihkZWNsYXJhdGlvbiA9PiB7XG5cdFx0aWYgKHNlZW5bZGVjbGFyYXRpb24ubmFtZV0pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0c2VlbltkZWNsYXJhdGlvbi5uYW1lXSA9IHRydWU7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0pO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIHByb3ZpZGVkIEdMU0wgc291cmNlLCBhbmQgcmV0dXJucyBhbGwgZGVjbGFyYXRpb24gc3RhdGVtZW50cyB0aGF0XG4gKiBjb250YWluIHRoZSBwcm92aWRlZCBxdWFsaWZpZXIgdHlwZXMuIFRoaXMgY2FuIGJlIHVzZWQgdG8gZXh0cmFjdCB0aGVcbiAqIGF0dHJpYnV0ZXMgYW5kIHVuaWZvcm0gbmFtZXMgLyB0eXBlcyBmcm9tIGEgc2hhZGVyLlxuICogTk9URTogVGhpcyBpcyBydW4gb25seSBBRlRFUiBjb21waWxhdGlvbiBzdWNjZWVkLCBzbyBpdCBhc3N1bWVzIFZBTElEIHN5bnRheC5cbiAqXG4gKiBFeCwgd2hlbiBwcm92aWRlZCBhICd1bmlmb3JtJyBxdWFsaWZpZXIsIHRoZSBkZWNsYXJhdGlvbjpcbiAqXG4gKiAgICAndW5pZm9ybSBoaWdocCB2ZWMzIHVTcGVjdWxhckNvbG9yOydcbiAqXG4gKiBXb3VsZCBiZSBwYXJzZWQgdG86XG4gKiAgICB7XG4gKiAgICAgICAgcXVhbGlmaWVyOiAndW5pZm9ybScsXG4gKiAgICAgICAgdHlwZTogJ3ZlYzMnXG4gKiAgICAgICAgbmFtZTogJ3VTcGVjdWxhckNvbG9yJyxcbiAqICAgICAgICBjb3VudDogMVxuICogICAgfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VzIC0gVGhlIHNoYWRlciBnbHNsIHNvdXJjZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBxdWFsaWZpZXJzIC0gVGhlIHF1YWxpZmllcnMgdG8gZXh0cmFjdC5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBvZiBxdWFsaWZpZXIgZGVjbGFyYXRpb24gc3RhdGVtZW50cy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzb3VyY2VzID0gW10sIHF1YWxpZmllcnMgPSBbXSkge1xuXHQvLyBpZiBubyBzb3VyY2VzIG9yIHF1YWxpZmllcnMgYXJlIHByb3ZpZGVkLCByZXR1cm4gZW1wdHkgYXJyYXlcblx0aWYgKHNvdXJjZXMubGVuZ3RoID09PSAwIHx8IHF1YWxpZmllcnMubGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cdHNvdXJjZXMgPSBBcnJheS5pc0FycmF5KHNvdXJjZXMpID8gc291cmNlcyA6IFtzb3VyY2VzXTtcblx0cXVhbGlmaWVycyA9IEFycmF5LmlzQXJyYXkocXVhbGlmaWVycykgPyBxdWFsaWZpZXJzIDogW3F1YWxpZmllcnNdO1xuXHQvLyBwYXJzZSBvdXQgdGFyZ2V0dGVkIGRlY2xhcmF0aW9uc1xuXHRsZXQgZGVjbGFyYXRpb25zID0gW107XG5cdHNvdXJjZXMuZm9yRWFjaChzb3VyY2UgPT4ge1xuXHRcdC8vIHJlbW92ZSBjb21tZW50c1xuXHRcdHNvdXJjZSA9IHN0cmlwQ29tbWVudHMoc291cmNlKTtcblx0XHQvLyBydW4gcHJlcHJvY2Vzc29yXG5cdFx0c291cmNlID0gcHJlcHJvY2Vzcyhzb3VyY2UpO1xuXHRcdC8vIHJlbW92ZSBwcmVjaXNpb24gc3RhdGVtZW50c1xuXHRcdHNvdXJjZSA9IHN0cmlwUHJlY2lzaW9uKHNvdXJjZSk7XG5cdFx0Ly8gZmluYWxseSwgbm9ybWFsaXplIHRoZSB3aGl0ZXNwYWNlXG5cdFx0c291cmNlID0gbm9ybWFsaXplV2hpdGVzcGFjZShzb3VyY2UpO1xuXHRcdC8vIHBhcnNlIG91dCBkZWNsYXJhdGlvbnNcblx0XHRkZWNsYXJhdGlvbnMgPSBkZWNsYXJhdGlvbnMuY29uY2F0KHBhcnNlU291cmNlKHNvdXJjZSwgcXVhbGlmaWVycykpO1xuXHR9KTtcblx0Ly8gcmVtb3ZlIGR1cGxpY2F0ZXMgYW5kIHJldHVyblxuXHRyZXR1cm4gZmlsdGVyRHVwbGljYXRlc0J5TmFtZShkZWNsYXJhdGlvbnMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgREVGSU5FRCA9ICdfX0RFRklORURfXyc7XG5cbmNvbnN0IERFRklORV9SRUdFWCA9IC8jZGVmaW5lXFxiL2k7XG5jb25zdCBVTkRFRl9SRUdFWCA9IC8jdW5kZWZcXGIvaTtcbmNvbnN0IElGX1JFR0VYID0gLyNpZlxcYi9pO1xuY29uc3QgSUZERUZfUkVHRVggPSAvI2lmZGVmXFxiL2k7XG5jb25zdCBJRk5ERUZfUkVHRVggPSAvI2lmbmRlZlxcYi9pO1xuY29uc3QgRUxTRV9SRUdFWCA9IC8jZWxzZVxcYi9pO1xuY29uc3QgRUxJRl9SRUdFWCA9IC8jZWxpZlxcYi9pO1xuY29uc3QgRU5ESUZfUkVHRVggPSAvI2VuZGlmXFxiL2k7XG5cbmNvbnN0IFBBUlNFX0RFRklORV9SRUdFWCA9IC8jZGVmaW5lXFxzKyhcXHcrKShcXHMoXFx3Kik/KT8vaTtcbmNvbnN0IFBBUlNFX1VOREVGX1JFR0VYID0gLyN1bmRlZlxccysoXFx3KykvaTtcbmNvbnN0IFBBUlNFX0lGX1JFR0VYID0gLyNpZlxccytcXCg/XFxzKighP1xccypcXHcrKVxccyooPT18IT18Pj18PD18PHw+KT9cXHMqKFxcdyopXFxzKlxcKT8vaTtcbmNvbnN0IFBBUlNFX0lGREVGX1JFR0VYID0gLyNpZmRlZlxccysoXFx3KykvaTtcbmNvbnN0IFBBUlNFX0lGTkRFRl9SRUdFWCA9IC8jaWZuZGVmXFxzKyhcXHcrKS9pO1xuY29uc3QgUEFSU0VfRUxJRl9SRUdFWCA9IC8jZWxpZlxccytcXCg/XFxzKighP1xccypcXHcrKVxccyooPT18IT18Pj18PD18PHw+KT9cXHMqKFxcdyopXFxzKlxcKT8vaTtcbmNvbnN0IFJFTUFJTklOR19SRUdFWCA9IC8jKFtcXFdcXHdcXHNcXGRdKSg/Oi4qXFxcXHI/XFxuKSouKiQvZ207XG5cbmNvbnN0IGV2YWxJZiA9IGZ1bmN0aW9uKGEsIGxvZ2ljLCBiKSB7XG5cdGlmIChsb2dpYyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGFbMF0gPT09ICchJykge1xuXHRcdFx0cmV0dXJuICEoYSA9PT0gJ3RydWUnIHx8IGEgPj0gMSk7XG5cdFx0fVxuXHRcdHJldHVybiBhID09PSAndHJ1ZScgfHwgYSA+PSAxO1xuXHR9XG5cdHN3aXRjaCAobG9naWMpIHtcblx0XHRjYXNlICc9PSc6XG5cdFx0XHRyZXR1cm4gYSA9PT0gYjtcblx0XHRjYXNlICchPSc6XG5cdFx0XHRyZXR1cm4gYSAhPT0gYjtcblx0XHRjYXNlICc+Jzpcblx0XHRcdHJldHVybiBhID4gYjtcblx0XHRjYXNlICc+PSc6XG5cdFx0XHRyZXR1cm4gYSA+PSBiO1xuXHRcdGNhc2UgJzwnOlxuXHRcdFx0cmV0dXJuIGEgPCBiO1xuXHRcdGNhc2UgJzw9Jzpcblx0XHRcdHJldHVybiBhIDw9IGI7XG5cdH1cblx0dGhyb3cgYFVucmVjb2duaXplZCBsb2dpY2FsIG9wZXJhdG9yIFxcYCR7bG9naWN9XFxgYDtcbn07XG5cbmNsYXNzIENvbmRpdGlvbmFsIHtcblx0Y29uc3RydWN0b3IodHlwZSwgY29uZGl0aW9uYWwpIHtcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdHRoaXMuY29uZGl0aW9uYWwgPSBjb25kaXRpb25hbC50cmltKCk7XG5cdFx0dGhpcy5ib2R5ID0gW107XG5cdFx0dGhpcy5jaGlsZHJlbiA9IFtdO1xuXHR9XG5cdGV2YWwoKSB7XG5cdFx0bGV0IHBhcnNlZDtcblx0XHRzd2l0Y2ggKHRoaXMudHlwZSkge1xuXHRcdFx0Y2FzZSAnaWYnOlxuXHRcdFx0XHRwYXJzZWQgPSBQQVJTRV9JRl9SRUdFWC5leGVjKHRoaXMuY29uZGl0aW9uYWwpO1xuXHRcdFx0XHRyZXR1cm4gZXZhbElmKHBhcnNlZFsxXSwgcGFyc2VkWzJdLCBwYXJzZWRbM10pO1xuXHRcdFx0Y2FzZSAnaWZkZWYnOlxuXHRcdFx0XHRwYXJzZWQgPSBQQVJTRV9JRkRFRl9SRUdFWC5leGVjKHRoaXMuY29uZGl0aW9uYWwpO1xuXHRcdFx0XHRyZXR1cm4gcGFyc2VkWzFdID09PSBERUZJTkVEO1xuXHRcdFx0Y2FzZSAnaWZuZGVmJzpcblx0XHRcdFx0cGFyc2VkID0gUEFSU0VfSUZOREVGX1JFR0VYLmV4ZWModGhpcy5jb25kaXRpb25hbCk7XG5cdFx0XHRcdHJldHVybiBwYXJzZWRbMV0gIT09IERFRklORUQ7XG5cdFx0XHRjYXNlICdlbGlmJzpcblx0XHRcdFx0cGFyc2VkID0gUEFSU0VfRUxJRl9SRUdFWC5leGVjKHRoaXMuY29uZGl0aW9uYWwpO1xuXHRcdFx0XHRyZXR1cm4gZXZhbElmKHBhcnNlZFsxXSwgcGFyc2VkWzJdLCBwYXJzZWRbM10pO1xuXHRcdH1cblx0XHR0aHJvdyBgVW5yZWNvZ25pemVkIGNvbmRpdGlvbmFsIHR5cGUgXFxgJHt0aGlzLnR5cGV9XFxgYDtcblx0fVxufVxuXG5jbGFzcyBCbG9jayB7XG5cdGNvbnN0cnVjdG9yKHR5cGUsIGNvbmRpdGlvbmFsLCBsaW5lTnVtKSB7XG5cdFx0dGhpcy5pZiA9IG5ldyBDb25kaXRpb25hbCh0eXBlLCBjb25kaXRpb25hbCk7XG5cdFx0dGhpcy5lbGlmID0gW107XG5cdFx0dGhpcy5lbHNlID0gbnVsbDtcblx0XHR0aGlzLnBhcmVudCA9IG51bGw7XG5cdFx0dGhpcy5jdXJyZW50ID0gdGhpcy5pZjtcblx0XHR0aGlzLnN0YXJ0TGluZSA9IGxpbmVOdW07XG5cdFx0dGhpcy5lbmRMaW5lID0gbnVsbDtcblx0fVxuXHRhZGRFbHNlKGNvbmRpdGlvbmFsKSB7XG5cdFx0dGhpcy5jdXJyZW50ID0gbmV3IENvbmRpdGlvbmFsKCdlbHNlJywgY29uZGl0aW9uYWwpO1xuXHRcdHRoaXMuZWxzZSA9IHRoaXMuY3VycmVudDtcblx0fVxuXHRhZGRFbGlmKGNvbmRpdGlvbmFsKSB7XG5cdFx0dGhpcy5jdXJyZW50ID0gbmV3IENvbmRpdGlvbmFsKCdlbGlmJywgY29uZGl0aW9uYWwpO1xuXHRcdHRoaXMuZWxpZi5wdXNoKHRoaXMuY3VycmVudCk7XG5cdH1cblx0YWRkQm9keShsaW5lLCBsaW5lTnVtKSB7XG5cdFx0dGhpcy5jdXJyZW50LmJvZHkucHVzaCh7XG5cdFx0XHRzdHJpbmc6IGxpbmUudHJpbSgpLFxuXHRcdFx0bGluZTogbGluZU51bVxuXHRcdH0pO1xuXHR9XG5cdG5lc3QoYmxvY2spIHtcblx0XHRibG9jay5wYXJlbnQgPSB0aGlzO1xuXHRcdHRoaXMuY3VycmVudC5jaGlsZHJlbi5wdXNoKGJsb2NrKTtcblx0fVxuXHRleHRyYWN0KCkge1xuXHRcdC8vICNpZlxuXHRcdGxldCBib2R5ID0gW107XG5cdFx0aWYgKHRoaXMuaWYuZXZhbCgpKSB7XG5cdFx0XHRib2R5ID0gYm9keS5jb25jYXQodGhpcy5pZi5ib2R5KTtcblx0XHRcdHRoaXMuaWYuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG5cdFx0XHRcdGJvZHkgPSBib2R5LmNvbmNhdChjaGlsZC5leHRyYWN0KCkpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gYm9keTtcblx0XHR9XG5cdFx0Ly8gI2VsaWZcblx0XHRmb3IgKGxldCBpPTA7IGk8dGhpcy5lbGlmLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBlbGlmID0gdGhpcy5lbGlmW2ldO1xuXHRcdFx0aWYgKGVsaWYuZXZhbCgpKSB7XG5cdFx0XHRcdGJvZHkgPSBib2R5LmNvbmNhdChlbGlmLmJvZHkpO1xuXHRcdFx0XHRmb3IgKGxldCBqPTA7IGo8ZWxpZi5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGNvbnN0IGNoaWxkID0gZWxpZi5jaGlsZHJlbltqXTtcblx0XHRcdFx0XHRib2R5ID0gYm9keS5jb25jYXQoY2hpbGQuZXh0cmFjdCgpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gYm9keTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gI2Vsc2Vcblx0XHRpZiAodGhpcy5lbHNlKSB7XG5cdFx0XHRib2R5ID0gYm9keS5jb25jYXQodGhpcy5lbHNlLmJvZHkpO1xuXHRcdFx0dGhpcy5lbHNlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuXHRcdFx0XHRib2R5ID0gYm9keS5jb25jYXQoY2hpbGQuZXh0cmFjdCgpKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGJvZHk7XG5cdFx0fVxuXHRcdHJldHVybiBbXTtcblx0fVxuXHRldmFsKCkge1xuXHRcdC8vIGVuc3VyZSBleHRyYWN0IHRleHQgaXMgb3JkZXJlZCBjb3JyZWN0bHlcblx0XHRyZXR1cm4gdGhpcy5leHRyYWN0KCkuc29ydCgoYSwgYikgPT4ge1xuXHRcdFx0cmV0dXJuIGEubGluZSAtIGIubGluZTtcblx0XHR9KS5tYXAoYXJnID0+IHtcblx0XHRcdHJldHVybiBhcmcuc3RyaW5nO1xuXHRcdH0pLmpvaW4oJ1xcbicpO1xuXHR9XG59XG5cbmNvbnN0IHBhcnNlTGluZXMgPSBmdW5jdGlvbihsaW5lcykge1xuXG5cdGNvbnN0IGJsb2NrcyA9IFtdO1xuXHRsZXQgY3VycmVudCA9IG51bGw7XG5cblx0bGluZXMuZm9yRWFjaCgobGluZSwgaW5kZXgpID0+IHtcblxuXHRcdGlmIChsaW5lLm1hdGNoKElGX1JFR0VYKSkge1xuXHRcdFx0Ly8gI2lmXG5cdFx0XHRjb25zdCBibG9jayA9IG5ldyBCbG9jaygnaWYnLCBsaW5lLCBpbmRleCk7XG5cdFx0XHRpZiAoIWN1cnJlbnQpIHtcblx0XHRcdFx0YmxvY2tzLnB1c2goYmxvY2spO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3VycmVudC5uZXN0KGJsb2NrKTtcblx0XHRcdH1cblx0XHRcdGN1cnJlbnQgPSBibG9jaztcblxuXHRcdH0gZWxzZSBpZiAobGluZS5tYXRjaChJRkRFRl9SRUdFWCkpIHtcblx0XHRcdC8vICNpZmRlZlxuXHRcdFx0Y29uc3QgYmxvY2sgPSBuZXcgQmxvY2soJ2lmZGVmJywgbGluZSwgaW5kZXgpO1xuXHRcdFx0aWYgKCFjdXJyZW50KSB7XG5cdFx0XHRcdGJsb2Nrcy5wdXNoKGJsb2NrKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN1cnJlbnQubmVzdChibG9jayk7XG5cdFx0XHR9XG5cdFx0XHRjdXJyZW50ID0gYmxvY2s7XG5cblx0XHR9IGVsc2UgaWYgKGxpbmUubWF0Y2goSUZOREVGX1JFR0VYKSkge1xuXHRcdFx0Ly8gI2lmbmRlZlxuXHRcdFx0Y29uc3QgYmxvY2sgPSBuZXcgQmxvY2soJ2lmbmRlZicsIGxpbmUsIGluZGV4KTtcblx0XHRcdGlmICghY3VycmVudCkge1xuXHRcdFx0XHRibG9ja3MucHVzaChibG9jayk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdXJyZW50Lm5lc3QoYmxvY2spO1xuXHRcdFx0fVxuXHRcdFx0Y3VycmVudCA9IGJsb2NrO1xuXG5cdFx0fSBlbHNlIGlmIChsaW5lLm1hdGNoKEVMSUZfUkVHRVgpKSB7XG5cdFx0XHQvLyAjZWxpZlxuXHRcdFx0aWYgKCFjdXJyZW50KSB7XG5cdFx0XHRcdHRocm93ICdJbnZhbGlkIHByZXByb2Nlc3NvciBzeW50YXgsIHVuZXhwZWN0ZWQgYCNlbGlmYCc7XG5cdFx0XHR9XG5cdFx0XHRjdXJyZW50LmFkZEVsaWYobGluZSk7XG5cblx0XHR9IGVsc2UgaWYgKGxpbmUubWF0Y2goRUxTRV9SRUdFWCkpIHtcblx0XHRcdC8vICNlbHNlXG5cdFx0XHRpZiAoIWN1cnJlbnQpIHtcblx0XHRcdFx0dGhyb3cgJ0ludmFsaWQgcHJlcHJvY2Vzc29yIHN5bnRheCwgdW5leHBlY3RlZCBgI2Vsc2VgJztcblx0XHRcdH1cblx0XHRcdGN1cnJlbnQuYWRkRWxzZShsaW5lKTtcblxuXHRcdH0gZWxzZSBpZiAobGluZS5tYXRjaChFTkRJRl9SRUdFWCkpIHtcblx0XHRcdC8vICNlbmRpZlxuXHRcdFx0aWYgKCFjdXJyZW50KSB7XG5cdFx0XHRcdHRocm93ICdJbnZhbGlkIHByZXByb2Nlc3NvciBzeW50YXgsIHVuZXhwZWN0ZWQgYCNlbmRpZmAnO1xuXHRcdFx0fVxuXHRcdFx0Y3VycmVudC5lbmRMaW5lID0gaW5kZXg7XG5cdFx0XHRjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gb3RoZXJcblx0XHRcdGlmIChjdXJyZW50KSB7XG5cdFx0XHRcdGN1cnJlbnQuYWRkQm9keShsaW5lLCBpbmRleCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAoY3VycmVudCkge1xuXHRcdHRocm93ICdJbnZhbGlkIHByZXByb2Nlc3NvciBzeW50YXgsIG1pc3NpbmcgZXhwZWN0ZWQgYCNlbmRpZmAnO1xuXHR9XG5cblx0cmV0dXJuIGJsb2Nrcztcbn07XG5cbmNvbnN0IHJlcGxhY2VEZWZpbmVzID0gZnVuY3Rpb24obGluZXMpIHtcblx0Y29uc3QgZGVmaW5lcyA9IG5ldyBNYXAoKTtcblx0Y29uc3QgcmVwbGFjZWQgPSBbXTtcblx0bGluZXMuZm9yRWFjaChsaW5lID0+IHtcblx0XHRpZiAobGluZS5tYXRjaChERUZJTkVfUkVHRVgpKSB7XG5cdFx0XHQvLyAjZGVmaW5lXG5cdFx0XHRjb25zdCBwYXJzZWQgPSBQQVJTRV9ERUZJTkVfUkVHRVguZXhlYyhsaW5lKTtcblx0XHRcdGRlZmluZXMuc2V0KHBhcnNlZFsxXSwgcGFyc2VkWzJdIHx8IERFRklORUQpO1xuXG5cdFx0fSBlbHNlIGlmIChsaW5lLm1hdGNoKFVOREVGX1JFR0VYKSkge1xuXHRcdFx0Ly8gI3VuZGVmXG5cdFx0XHRjb25zdCBwYXJzZWQgPSBQQVJTRV9VTkRFRl9SRUdFWC5leGVjKGxpbmUpO1xuXHRcdFx0ZGVmaW5lcy5kZWxldGUocGFyc2VkWzFdKTtcblxuXHRcdH0gZWxzZSBpZiAobGluZS5tYXRjaChJRkRFRl9SRUdFWCkpIHtcblx0XHRcdC8vICNpZmRlZlxuXHRcdFx0Y29uc3QgcGFyc2VkID0gUEFSU0VfSUZERUZfUkVHRVguZXhlYyhsaW5lKTtcblx0XHRcdGlmIChkZWZpbmVzLmhhcyhwYXJzZWRbMV0pKSB7XG5cdFx0XHRcdGxpbmUgPSBsaW5lLnJlcGxhY2UocGFyc2VkWzFdLCBERUZJTkVEKTtcblx0XHRcdH1cblx0XHRcdHJlcGxhY2VkLnB1c2gobGluZSk7XG5cblx0XHR9IGVsc2UgaWYgKGxpbmUubWF0Y2goSUZOREVGX1JFR0VYKSkge1xuXHRcdFx0Ly8gI2lmbmRlZlxuXHRcdFx0Y29uc3QgcGFyc2VkID0gUEFSU0VfSUZOREVGX1JFR0VYLmV4ZWMobGluZSk7XG5cdFx0XHRpZiAoZGVmaW5lcy5oYXMocGFyc2VkWzFdKSkge1xuXHRcdFx0XHRsaW5lID0gbGluZS5yZXBsYWNlKHBhcnNlZFsxXSwgREVGSU5FRCk7XG5cdFx0XHR9XG5cdFx0XHRyZXBsYWNlZC5wdXNoKGxpbmUpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHN3YXAgZGVmaW5lc1xuXHRcdFx0ZGVmaW5lcy5mb3JFYWNoKCh2YWwsIGRlZmluZSkgPT4ge1xuXHRcdFx0XHRsaW5lID0gbGluZS5yZXBsYWNlKGRlZmluZSwgdmFsKTtcblx0XHRcdH0pO1xuXHRcdFx0cmVwbGFjZWQucHVzaChsaW5lKTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcmVwbGFjZWQ7XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlcyBHTFNMIHByZXByb2Nlc3NvciBzdGF0ZW1lbnRzLlxuICogTk9URTogYXNzdW1lcyBjb21tZW50cyBoYXZlIGJlZW4gc3RyaXBwZWQsIGFuZCBwcmVwcm9jZXNzb3JzIGFyZSB2YWxpZC5cbiAqXG4gKiAgICAgU3VwcG9ydGVkOlxuICpcbiAqICAgICAgICAgI2RlZmluZSAoc3Vic3RpdHV0aW9ucyBvbmx5KVxuICogICAgICAgICAjdW5kZWZcbiAqICAgICAgICAgI2lmICg9PSBhbmQgIT0gY29tcGFyaXNvbnMgb25seSlcbiAqICAgICAgICAgI2lmZGVmXG4gKiAgICAgICAgICNpZm5kZWZcbiAqICAgICAgICAgI2VsaWZcbiAqICAgICAgICAgI2Vsc2VcbiAqICAgICAgICAgI2VuZGlmXG4gKlxuICogICAgIE5vdCBTdXBwb3J0ZWQ6XG4gKlxuICogICAgICAgICAjZGVmaW5lIChtYWNyb3MpXG4gKiAgICAgICAgICNpZiAoJiYgYW5kIHx8IG9wZXJhdG9ycywgZGVmaW5lZCgpIHByZWRpY2F0ZSlcbiAqICAgICAgICAgI2Vycm9yXG4gKiAgICAgICAgICNwcmFnbWFcbiAqICAgICAgICAgI2V4dGVuc2lvblxuICogICAgICAgICAjdmVyc2lvblxuICogICAgICAgICAjbGluZVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gZ2xzbCAtIFRoZSBnbHNsIHNvdXJjZSBjb2RlLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBwcm9jZXNzZWQgZ2xzbCBzb3VyY2UgY29kZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihnbHNsKSB7XG5cdC8vIHNwbGl0IGxpbmVzXG5cdGxldCBsaW5lcyA9IGdsc2wuc3BsaXQoJ1xcbicpO1xuXHQvLyByZXBsYWNlIGFueSBkZWZpbmVzIHdpdGggdGhlaXIgdmFsdWVzXG5cdGxpbmVzID0gcmVwbGFjZURlZmluZXMobGluZXMpO1xuXHQvLyBwYXJzZSB0aGVtXG5cdGNvbnN0IGJsb2NrcyA9IHBhcnNlTGluZXMobGluZXMpO1xuXHQvLyByZW1vdmUgYmxvY2tzIGluIHJldmVyc2Ugb3JkZXIgdG8gcHJlc2VydmUgbGluZSBudW1iZXJzXG5cdGZvciAobGV0IGk9YmxvY2tzLmxlbmd0aCAtIDE7IGk+PTA7IGktLSkge1xuXHRcdGNvbnN0IGJsb2NrID0gYmxvY2tzW2ldO1xuXHRcdGNvbnN0IHJlcGxhY2VtZW50ID0gYmxvY2suZXZhbCgpO1xuXHRcdGlmIChyZXBsYWNlbWVudC5sZW5ndGggPiAwKSB7XG5cdFx0XHRsaW5lcy5zcGxpY2UoYmxvY2suc3RhcnRMaW5lLCBibG9jay5lbmRMaW5lIC0gYmxvY2suc3RhcnRMaW5lICsgMSwgcmVwbGFjZW1lbnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsaW5lcy5zcGxpY2UoYmxvY2suc3RhcnRMaW5lLCBibG9jay5lbmRMaW5lIC0gYmxvY2suc3RhcnRMaW5lICsgMSk7XG5cdFx0fVxuXHR9XG5cdC8vIHN0cmlwIHJlbWFpbmluZyB1bnN1cHBvcnRlZCBwcmVwcm9jZXNzb3Igc3RhdGVtZW50c1xuXHRyZXR1cm4gbGluZXMuam9pbignXFxuJykucmVwbGFjZShSRU1BSU5JTkdfUkVHRVgsICcnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGRlZmF1bHRUbyA9IHJlcXVpcmUoJ2xvZGFzaC9kZWZhdWx0VG8nKTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSB0ZXh0dXJlLlxuICovXG5jbGFzcyBUZXh0dXJlIHtcblxuXHQvKipcblx0ICogSW5zdGFudGlhdGVzIGEgVGV4dHVyZSBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFRoZSBXZWJHTCBjb250ZXh0LlxuXHQgKiBAcGFyYW0ge0FycmF5QnVmZmVyfENhbnZhc0VsZW1lbnR9IHNyYyAtIFRoZSBkYXRhIHRvIGJ1ZmZlci5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgdGV4dHVyZSBvcHRpb25zLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy53aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgdGV4dHVyZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgdGV4dHVyZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZm9ybWF0IC0gVGhlIHRleHR1cmUgcGl4ZWwgZm9ybWF0LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50eXBlIC0gVGhlIHRleHR1cmUgcGl4ZWwgY29tcG9uZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmZpbHRlciAtIFRoZSBtaW4gLyBtYWcgZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLndyYXAgLSBUaGUgd3JhcHBpbmcgdHlwZSBvdmVyIGJvdGggUyBhbmQgVCBkaW1lbnNpb24uXG5cdCAqIEBwYXJhbSB7Ym9vbH0gb3B0aW9ucy5pbnZlcnRZIC0gV2hldGhlciBvciBub3QgaW52ZXJ0LXkgaXMgZW5hYmxlZC5cblx0ICogQHBhcmFtIHtib29sfSBvcHRpb25zLnByZW11bHRpcGx5QWxwaGEgLSBXaGV0aGVyIG9yIG5vdCBhbHBoYSBwcmVtdWx0aXBseWluZyBpcyBlbmFibGVkLlxuXHQgKi9cblx0Y29uc3RydWN0b3IoZ2wsIHNyYyA9IG51bGwsIG9wdGlvbnMgPSB7fSkge1xuXHRcdHRoaXMuZ2wgPSBnbDtcblx0XHR0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cdFx0Ly8gc2V0IHRleHR1cmUgcHJvcGVydGllc1xuXHRcdHRoaXMuZm9ybWF0ID0gZGVmYXVsdFRvKG9wdGlvbnMuZm9ybWF0LCAnUkdCQScpO1xuXHRcdHRoaXMudHlwZSA9IGRlZmF1bHRUbyhvcHRpb25zLnR5cGUsICdVTlNJR05FRF9CWVRFJyk7XG5cdFx0dGhpcy5maWx0ZXIgPSBkZWZhdWx0VG8ob3B0aW9ucy5maWx0ZXIsICdMSU5FQVInKTtcblx0XHR0aGlzLndyYXAgPSBkZWZhdWx0VG8ob3B0aW9ucy53cmFwLCAnQ0xBTVBfVE9fRURHRScpO1xuXHRcdHRoaXMuaW52ZXJ0WSA9IGRlZmF1bHRUbyhvcHRpb25zLmludmVydFksIGZhbHNlKTtcblx0XHR0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBkZWZhdWx0VG8ob3B0aW9ucy5wcmVtdWx0aXBseUFscGhhLCBmYWxzZSk7XG5cdFx0Ly8gYnVmZmVyIHRoZSBkYXRhXG5cdFx0dGhpcy5idWZmZXJEYXRhKHNyYywgb3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQpO1xuXHRcdC8vIHNldCBwYXJhbWV0ZXJzXG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2xbdGhpcy53cmFwXSk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2xbdGhpcy53cmFwXSk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsW3RoaXMuZmlsdGVyXSk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsW3RoaXMuZmlsdGVyXSk7XG5cdH1cblxuXHQvKipcblx0ICogQmluZHMgdGhlIHRleHR1cmUgb2JqZWN0IHRvIHRoZSBwcm92aWRlZCB0ZXh0dXJlIHVuaXQgbG9jYXRpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsb2NhdGlvbiAtIFRoZSB0ZXh0dXJlIHVuaXQgbG9jYXRpb24gaW5kZXguIE9wdGlvbmFsLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7VGV4dHVyZX0gVGhlIHRleHR1cmUgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRiaW5kKGxvY2F0aW9uID0gMCkge1xuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcblx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsW2BURVhUVVJFJHtsb2NhdGlvbn1gXSk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBVbmJpbmRzIHRoZSB0ZXh0dXJlIG9iamVjdC5cblx0ICpcblx0ICogQHJldHVybnMge1RleHR1cmV9IFRoZSB0ZXh0dXJlIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0dW5iaW5kKCkge1xuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBCdWZmZXIgZGF0YSBpbnRvIHRoZSB0ZXh0dXJlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyVmlld3xudWxsfSBkYXRhIC0gVGhlIGRhdGEgYXJyYXkgdG8gYnVmZmVyLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGRhdGEuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBkYXRhLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7VGV4dHVyZX0gVGhlIHRleHR1cmUgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRidWZmZXJEYXRhKGRhdGEsIHdpZHRoLCBoZWlnaHQpIHtcblx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XG5cdFx0Ly8gYmluZCB0ZXh0dXJlXG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcblx0XHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0aGlzLmludmVydFkpO1xuXHRcdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGhpcy5wcmVtdWx0aXBseUFscGhhKTtcblx0XHQvLyBidWZmZXIgdGhlIGRhdGFcblx0XHRpZiAoZGF0YSAmJiBkYXRhLndpZHRoICYmIGRhdGEuaGVpZ2h0KSB7XG5cdFx0XHQvLyBzdG9yZSB3aWR0aCBhbmQgaGVpZ2h0XG5cdFx0XHR0aGlzLndpZHRoID0gZGF0YS53aWR0aDtcblx0XHRcdHRoaXMuaGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XG5cdFx0XHQvLyBidWZmZXIgdGhlIHRleHR1cmVcblx0XHRcdGdsLnRleEltYWdlMkQoXG5cdFx0XHRcdGdsLlRFWFRVUkVfMkQsXG5cdFx0XHRcdDAsIC8vIG1pcC1tYXAgbGV2ZWxcblx0XHRcdFx0Z2xbdGhpcy5mb3JtYXRdLCAvLyB3ZWJnbCByZXF1aXJlcyBmb3JtYXQgPT09IGludGVybmFsRm9ybWF0XG5cdFx0XHRcdGdsW3RoaXMuZm9ybWF0XSxcblx0XHRcdFx0Z2xbdGhpcy50eXBlXSxcblx0XHRcdFx0ZGF0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHN0b3JlIHdpZHRoIGFuZCBoZWlnaHRcblx0XHRcdHRoaXMud2lkdGggPSB3aWR0aCB8fCB0aGlzLndpZHRoO1xuXHRcdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgdGhpcy5oZWlnaHQ7XG5cdFx0XHQvLyBidWZmZXIgdGhlIHRleHR1cmUgZGF0YVxuXHRcdFx0Z2wudGV4SW1hZ2UyRChcblx0XHRcdFx0Z2wuVEVYVFVSRV8yRCxcblx0XHRcdFx0MCwgLy8gbWlwLW1hcCBsZXZlbFxuXHRcdFx0XHRnbFt0aGlzLmZvcm1hdF0sIC8vIHdlYmdsIHJlcXVpcmVzIGZvcm1hdCA9PT0gaW50ZXJuYWxGb3JtYXRcblx0XHRcdFx0dGhpcy53aWR0aCxcblx0XHRcdFx0dGhpcy5oZWlnaHQsXG5cdFx0XHRcdDAsIC8vIGJvcmRlciwgbXVzdCBiZSAwXG5cdFx0XHRcdGdsW3RoaXMuZm9ybWF0XSxcblx0XHRcdFx0Z2xbdGhpcy50eXBlXSxcblx0XHRcdFx0ZGF0YSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJ1ZmZlciBwYXJ0aWFsIGRhdGEgaW50byB0aGUgdGV4dHVyZS5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlclZpZXd8bnVsbH0gZGF0YSAtIFRoZSBkYXRhIGFycmF5IHRvIGJ1ZmZlci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHhPZmZzZXQgLSBUaGUgeCBvZmZzZXQgYXQgd2hpY2ggdG8gYnVmZmVyLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geU9mZnNldCAtIFRoZSB5IG9mZnNldCBhdCB3aGljaCB0byBidWZmZXIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgZGF0YS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIGRhdGEuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtUZXh0dXJlfSBUaGUgdGV4dHVyZSBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdGJ1ZmZlclN1YkRhdGEoZGF0YSwgeE9mZnNldCA9IDAsIHlPZmZzZXQgPSAwLCB3aWR0aCA9IHVuZGVmaW5lZCwgaGVpZ2h0ID0gdW5kZWZpbmVkKSB7XG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xuXHRcdC8vIGJpbmQgdGV4dHVyZVxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG5cdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGhpcy5pbnZlcnRZKTtcblx0XHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRoaXMucHJlbXVsdGlwbHlBbHBoYSk7XG5cdFx0Ly8gYnVmZmVyIHRoZSBkYXRhXG5cdFx0aWYgKGRhdGEud2lkdGggJiYgZGF0YS5oZWlnaHQpIHtcblx0XHRcdC8vIGJ1ZmZlciB0aGUgdGV4dHVyZVxuXHRcdFx0Z2wudGV4U3ViSW1hZ2UyRChcblx0XHRcdFx0Z2wuVEVYVFVSRV8yRCxcblx0XHRcdFx0MCwgLy8gbWlwLW1hcCBsZXZlbFxuXHRcdFx0XHR4T2Zmc2V0LFxuXHRcdFx0XHR5T2Zmc2V0LFxuXHRcdFx0XHRnbFt0aGlzLmZvcm1hdF0sXG5cdFx0XHRcdGdsW3RoaXMudHlwZV0sXG5cdFx0XHRcdGRhdGEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBidWZmZXIgdGhlIHRleHR1cmUgZGF0YVxuXHRcdFx0Z2wudGV4U3ViSW1hZ2UyRChcblx0XHRcdFx0Z2wuVEVYVFVSRV8yRCxcblx0XHRcdFx0MCwgLy8gbWlwLW1hcCBsZXZlbFxuXHRcdFx0XHR4T2Zmc2V0LFxuXHRcdFx0XHR5T2Zmc2V0LFxuXHRcdFx0XHR3aWR0aCxcblx0XHRcdFx0aGVpZ2h0LFxuXHRcdFx0XHRnbFt0aGlzLmZvcm1hdF0sXG5cdFx0XHRcdGdsW3RoaXMudHlwZV0sXG5cdFx0XHRcdGRhdGEpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNpemUgdGhlIHVuZGVybHlpbmcgdGV4dHVyZS4gVGhpcyBjbGVhcnMgdGhlIHRleHR1cmUgZGF0YS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIG5ldyB3aWR0aCBvZiB0aGUgdGV4dHVyZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7VGV4dHVyZX0gVGhlIHRleHR1cmUgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRyZXNpemUod2lkdGgsIGhlaWdodCkge1xuXHRcdHRoaXMuYnVmZmVyRGF0YShudWxsLCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHR1cmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGRlZmF1bHRUbyA9IHJlcXVpcmUoJ2xvZGFzaC9kZWZhdWx0VG8nKTtcblxuLy8gUHJpdmF0ZSBNZXRob2RzXG5cbmNvbnN0IGNyZWF0ZVRleHR1cmUgPSBmdW5jdGlvbihnbCwgZm9ybWF0LCBzaXplLCB0eXBlLCBmaWx0ZXIsIHdyYXAsIGludmVydFksIHByZW11bHRpcGx5QWxwaGEpIHtcblx0Y29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG5cdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGludmVydFkpO1xuXHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHByZW11bHRpcGx5QWxwaGEpO1xuXHQvLyBidWZmZXIgdGhlIGRhdGFcblx0Z2wudGV4SW1hZ2UyRChcblx0XHRnbC5URVhUVVJFXzJELFxuXHRcdDAsIC8vIG1pcC1tYXAgbGV2ZWxcblx0XHRnbFtmb3JtYXRdLCAvLyB3ZWJnbCByZXF1aXJlcyBmb3JtYXQgPT09IGludGVybmFsRm9ybWF0XG5cdFx0c2l6ZSxcblx0XHRzaXplLFxuXHRcdDAsIC8vIGJvcmRlciwgbXVzdCBiZSAwXG5cdFx0Z2xbZm9ybWF0XSxcblx0XHRnbFt0eXBlXSxcblx0XHRudWxsKTtcblx0Ly8gc2V0IHBhcmFtZXRlcnNcblx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2xbd3JhcF0pO1xuXHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbFt3cmFwXSk7XG5cdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbFtmaWx0ZXJdKTtcblx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsW2ZpbHRlcl0pO1xuXHRyZXR1cm4gdGV4dHVyZTtcbn07XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgdGV4dHVyZSBhcnJheS5cbiAqL1xuY2xhc3MgVGV4dHVyZUFycmF5IHtcblxuXHQvKipcblx0ICogSW5zdGFudGlhdGVzIGEgbmV3IFRleHR1cmVBcnJheSBvYmplY3QuXG5cdCAqXG5cdCAqIE5PVEU6IHdlIHVzZSBhIHRleHR1cmUgYXJyYXkgcmF0aGVyIHRoYW4gYSB0ZXh0dXJlIGF0bGFzIGJlY2F1c2Ugb2Zcblx0ICogdGhlIHN1Yi1waXhlbCBibGVlZGluZyB0aGF0IG9jY3VycyBpbiB0aGUgYXRsYXMgd2hlbiB0ZXh0dXJlcyBhcmVcblx0ICogbm90IHBhZGRlZC4gRHVlIHRvIHRoZSBvdmVyaGVhZCBvZiBwYWRkaW5nIGNsaWVudHNpZGUsIHRoZVxuXHQgKiBmcmVxdWVuY3kgb2YgbG9hZCBsb2FkIGV2ZW50cywgYW5kIHRoZSBhdmVyYWdlIG51bWJlciBvZiB0aWxlcyBvblxuXHQgKiB0aGUgc2NyZWVuIGF0IGFueSBvbmUgdGltZSwgYmluZGluZyBpbmRpdmlkdWFsIHRpbGUgdGV4dHVyZXNcblx0ICogcHJvdmlkZXMgYSBsZXNzIHZvbGF0aWxlIGZyYW1lIHJhdGUgY29tcGFyZWQgdG8gcGFkZGluZyB0ZXh0dXJlcyBhbmRcblx0ICogdXNpbmcgYW4gYXRsYXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFRoZSBXZWJHTCBjb250ZXh0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHRleHR1cmUgcGFyYW1ldGVycy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5mb3JtYXQgLSBUaGUgdGV4dHVyZSBwaXhlbCBmb3JtYXQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMudHlwZSAtIFRoZSB0ZXh0dXJlIHBpeGVsIGNvbXBvbmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmZpbHRlciAtIFRoZSBtaW4gLyBtYWcgZmlsdGVyIHVzZWQgZHVyaW5nIHNjYWxpbmcuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMud3JhcCAtIFRoZSB3cmFwcGluZyB0eXBlIG92ZXIgYm90aCBTIGFuZCBUIGRpbWVuc2lvbi5cblx0ICogQHBhcmFtIHtib29sfSBwYXJhbXMuaW52ZXJ0WSAtIFdoZXRoZXIgb3Igbm90IGludmVydC15IGlzIGVuYWJsZWQuXG5cdCAqIEBwYXJhbSB7Ym9vbH0gcGFyYW1zLnByZW11bHRpcGx5QWxwaGEgLSBXaGV0aGVyIG9yIG5vdCBhbHBoYSBwcmVtdWx0aXBseWluZyBpcyBlbmFibGVkLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSB0ZXh0dXJlIGFycmF5IG9wdGlvbnMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNodW5rU2l6ZSAtIFRoZSBkaW1lbnNpb24gb2YgZWFjaCB0ZXh0dXJlLCBpbiBwaXhlbHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm51bUNodW5rcyAtIFRoZSBzaXplIG9mIHRoZSBhcnJheSwgaW4gdGlsZXMuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihnbCwgcGFyYW1zID0ge30sIG9wdGlvbnMgPSB7fSkge1xuXHRcdHRoaXMuZ2wgPSBnbDtcblx0XHQvLyBzZXQgYXJyYXkgcHJvcGVydGllc1xuXHRcdHRoaXMuY2h1bmtTaXplID0gZGVmYXVsdFRvKG9wdGlvbnMuY2h1bmtTaXplLCAyNTYpO1xuXHRcdHRoaXMubnVtQ2h1bmtzID0gZGVmYXVsdFRvKG9wdGlvbnMubnVtQ2h1bmtzLCAyNTYpO1xuXHRcdC8vIHNldCB0ZXh0dXJlIHBhcmFtZXRlcnNcblx0XHR0aGlzLmZvcm1hdCA9IGRlZmF1bHRUbyhwYXJhbXMuZm9ybWF0LCAnUkdCQScpO1xuXHRcdHRoaXMudHlwZSA9IGRlZmF1bHRUbyhwYXJhbXMudHlwZSwgJ1VOU0lHTkVEX0JZVEUnKTtcblx0XHR0aGlzLmZpbHRlciA9IGRlZmF1bHRUbyhwYXJhbXMuZmlsdGVyLCAnTElORUFSJyk7XG5cdFx0dGhpcy53cmFwID0gZGVmYXVsdFRvKHBhcmFtcy53cmFwLCAnQ0xBTVBfVE9fRURHRScpO1xuXHRcdHRoaXMuaW52ZXJ0WSA9IGRlZmF1bHRUbyhwYXJhbXMuaW52ZXJ0WSwgZmFsc2UpO1xuXHRcdHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IGRlZmF1bHRUbyhwYXJhbXMucHJlbXVsdGlwbHlBbHBoYSwgZmFsc2UpO1xuXHRcdC8vIGNyZWF0ZSB0ZXh0dXJlc1xuXHRcdHRoaXMuYXZhaWxhYmxlID0gbmV3IEFycmF5KHRoaXMubnVtQ2h1bmtzKTtcblx0XHRmb3IgKGxldCBpPTA7IGk8dGhpcy5udW1DaHVua3M7IGkrKykge1xuXHRcdFx0dGhpcy5hdmFpbGFibGVbaV0gPSB7XG5cdFx0XHRcdHRleHR1cmU6IGNyZWF0ZVRleHR1cmUoXG5cdFx0XHRcdFx0dGhpcy5nbCxcblx0XHRcdFx0XHR0aGlzLmZvcm1hdCxcblx0XHRcdFx0XHR0aGlzLmNodW5rU2l6ZSxcblx0XHRcdFx0XHR0aGlzLnR5cGUsXG5cdFx0XHRcdFx0dGhpcy5maWx0ZXIsXG5cdFx0XHRcdFx0dGhpcy53cmFwLFxuXHRcdFx0XHRcdHRoaXMuaW52ZXJ0WSxcblx0XHRcdFx0XHR0aGlzLnByZW11bHRpcGx5QWxwaGEpXG5cdFx0XHR9O1xuXHRcdH1cblx0XHQvLyBjcmVhdGUgdXNlZCBjaHVuayBtYXBcblx0XHR0aGlzLnVzZWQgPSBuZXcgTWFwKCk7XG5cdH1cblxuXHQvKipcblx0ICogVGVzdCB3aGV0aGVyIG9yIG5vdCBhIGtleSBpcyBoZWxkIGluIHRoZSBhcnJheS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgdG8gdGVzdC5cblx0ICpcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBjb29yZCBleGlzdHMgaW4gdGhlIHB5cmFtaWQuXG5cdCAqL1xuXHRoYXMoa2V5KSB7XG5cdFx0cmV0dXJuIHRoaXMudXNlZC5oYXMoa2V5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjaHVuayBtYXRjaGluZyB0aGUgcHJvdmlkZWQga2V5LiBJZiB0aGUgY2h1bmsgZG9lcyBub3Rcblx0ICogZXhpc3QsIHJldHVybnMgdW5kZWZpbmVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBvZiB0aGUgY2h1bmsgdG8gcmV0dXJuLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY2h1bmsgb2JqZWN0LlxuXHQgKi9cblx0Z2V0KGtleSkge1xuXHRcdHJldHVybiB0aGlzLnVzZWQuZ2V0KGtleSk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRoZSB0ZXh0dXJlIGRhdGEgZm9yIHRoZSBwcm92aWRlZCBrZXkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSB0ZXh0dXJlIGRhdGEuXG5cdCAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ8SFRNTENhbnZhc0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudH0gZGF0YSAtIFRoZSB0ZXh0dXJlIGRhdGEuXG5cdCAqL1xuXHRzZXQoa2V5LCBkYXRhKSB7XG5cdFx0aWYgKHRoaXMuaGFzKGtleSkpIHtcblx0XHRcdHRocm93IGBUaWxlIG9mIGNvb3JkICR7a2V5fSBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgYXJyYXlgO1xuXHRcdH1cblx0XHRpZiAodGhpcy5hdmFpbGFibGUubGVuZ3RoID09PSAwKSB7XG5cdFx0XHR0aHJvdyAnTm8gYXZhaWxhYmxlIHRleHR1cmUgY2h1bmtzIGluIGFycmF5Jztcblx0XHR9XG5cdFx0Ly8gZ2V0IGFuIGF2YWlsYWJsZSBjaHVua1xuXHRcdGNvbnN0IGNodW5rID0gdGhpcy5hdmFpbGFibGUucG9wKCk7XG5cdFx0Ly8gYnVmZmVyIHRoZSBkYXRhXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGNodW5rLnRleHR1cmUpO1xuXHRcdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRoaXMuaW52ZXJ0WSk7XG5cdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0aGlzLnByZW11bHRpcGx5QWxwaGEpO1xuXHRcdGlmIChkYXRhLndpZHRoICYmIGRhdGEuaGVpZ2h0KSB7XG5cdFx0XHQvLyBjYW52YXMgdHlwZVxuXHRcdFx0Z2wudGV4SW1hZ2UyRChcblx0XHRcdFx0Z2wuVEVYVFVSRV8yRCxcblx0XHRcdFx0MCwgLy8gbWlwLW1hcCBsZXZlbFxuXHRcdFx0XHRnbFt0aGlzLmZvcm1hdF0sIC8vIHdlYmdsIHJlcXVpcmVzIGZvcm1hdCA9PT0gaW50ZXJuYWxGb3JtYXRcblx0XHRcdFx0Z2xbdGhpcy5mb3JtYXRdLFxuXHRcdFx0XHRnbFt0aGlzLnR5cGVdLFxuXHRcdFx0XHRkYXRhKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gYXJyYXlidWZmZXIgdHlwZVxuXHRcdFx0Z2wudGV4SW1hZ2UyRChcblx0XHRcdFx0Z2wuVEVYVFVSRV8yRCxcblx0XHRcdFx0MCwgLy8gbWlwLW1hcCBsZXZlbFxuXHRcdFx0XHRnbFt0aGlzLmZvcm1hdF0sIC8vIHdlYmdsIHJlcXVpcmVzIGZvcm1hdCA9PT0gaW50ZXJuYWxGb3JtYXRcblx0XHRcdFx0dGhpcy5jaHVua1NpemUsXG5cdFx0XHRcdHRoaXMuY2h1bmtTaXplLFxuXHRcdFx0XHQwLCAvLyBib3JkZXIsIG11c3QgYmUgMFxuXHRcdFx0XHRnbFt0aGlzLmZvcm1hdF0sXG5cdFx0XHRcdGdsW3RoaXMudHlwZV0sXG5cdFx0XHRcdGRhdGEpO1xuXHRcdH1cblx0XHQvLyBhZGQgdG8gdXNlZFxuXHRcdHRoaXMudXNlZC5zZXQoa2V5LCBjaHVuayk7XG5cdH1cblxuXHQvKipcblx0ICogRmxhZ3MgdGhlIGNodW5rIG1hdGNoaW5nIHRoZSBwcm92aWRlZCBrZXkgYXMgdW51c2VkIGluIHRoZSBhcnJheS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGNodW5rIHRvIGZyZWUuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtUZXh0dXJlQXJyYXl9IFRoZSBUZXh0dXJlQXJyYXkgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRkZWxldGUoa2V5KSB7XG5cdFx0aWYgKCF0aGlzLmhhcyhrZXkpKSB7XG5cdFx0XHR0aHJvdyBgVGlsZSBvZiBjb29yZCAke2tleX0gZG9lcyBub3QgZXhpc3QgaW4gdGhlIGFycmF5YDtcblx0XHR9XG5cdFx0Ly8gZ2V0IGNodW5rXG5cdFx0Y29uc3QgY2h1bmsgPSB0aGlzLnVzZWQuZ2V0KGtleSk7XG5cdFx0Ly8gcmVtb3ZlIGZyb20gdXNlZFxuXHRcdHRoaXMudXNlZC5kZWxldGUoa2V5KTtcblx0XHQvLyBhZGQgdG8gYXZhaWxhYmxlXG5cdFx0dGhpcy5hdmFpbGFibGUucHVzaChjaHVuayk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQmluZHMgdGhlIHRleHR1cmUgYXJyYXkgdG8gdGhlIHByb3ZpZGVkIHRleHR1cmUgdW5pdC5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGNodW5rIHRvIGJpbmQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiAtIFRoZSB0ZXh0dXJlIHVuaXQgdG8gYWN0aXZhdGUuIE9wdGlvbmFsLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7VGV4dHVyZUFycmF5fSBUaGUgVGV4dHVyZUFycmF5IG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0YmluZChrZXksIGxvY2F0aW9uID0gMCkge1xuXHRcdGlmICghdGhpcy5oYXMoa2V5KSkge1xuXHRcdFx0dGhyb3cgYFRpbGUgb2YgY29vcmQgJHtrZXl9IGRvZXMgbm90IGV4aXN0IGluIHRoZSBhcnJheWA7XG5cdFx0fVxuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcblx0XHRjb25zdCBjaHVuayA9IHRoaXMudXNlZC5nZXQoa2V5KTtcblx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsW2BURVhUVVJFJHtsb2NhdGlvbn1gXSk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgY2h1bmsudGV4dHVyZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogVW5iaW5kcyB0aGUgdGV4dHVyZSBhcnJheS5cblx0ICpcblx0ICogQHJldHVybnMge1RleHR1cmVBcnJheX0gVGhlIFRleHR1cmVBcnJheSBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHVuYmluZCgpIHtcblx0XHQvLyBuby1vcFxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dHVyZUFycmF5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBkZWZhdWx0VG8gPSByZXF1aXJlKCdsb2Rhc2gvZGVmYXVsdFRvJyk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGluZGV4IGJ1ZmZlci5cbiAqL1xuY2xhc3MgSW5kZXhCdWZmZXIge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYW4gSW5kZXhCdWZmZXIgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBUaGUgV2ViR0wgY29udGV4dC5cblx0ICogQHBhcmFtIHtXZWJHTEJ1ZmZlcnxBcnJheUJ1ZmZlcnxudW1iZXJ9IGFyZyAtIFRoZSBpbmRleCBkYXRhIHRvIGJ1ZmZlci5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcmVuZGVyaW5nIG9wdGlvbnMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnR5cGUgLSBUaGUgYnVmZmVyIGNvbXBvbmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5tb2RlIC0gVGhlIGRyYXcgbW9kZSAvIHByaW1pdGl2ZSB0eXBlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5ieXRlT2Zmc2V0IC0gVGhlIGJ5dGUgb2Zmc2V0IGludG8gdGhlIGRyYXduIGJ1ZmZlci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY291bnQgLSBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIHRvIGRyYXcuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihnbCwgYXJnLCBvcHRpb25zID0ge30pIHtcblx0XHR0aGlzLmdsID0gZ2w7XG5cdFx0dGhpcy50eXBlID0gZGVmYXVsdFRvKG9wdGlvbnMudHlwZSwgJ1VOU0lHTkVEX1NIT1JUJyk7XG5cdFx0dGhpcy5tb2RlID0gZGVmYXVsdFRvKG9wdGlvbnMubW9kZSwgJ1RSSUFOR0xFUycpO1xuXHRcdHRoaXMuY291bnQgPSBkZWZhdWx0VG8ob3B0aW9ucy5jb3VudCwgMCk7XG5cdFx0dGhpcy5ieXRlT2Zmc2V0ID0gZGVmYXVsdFRvKG9wdGlvbnMuYnl0ZU9mZnNldCwgMCk7XG5cdFx0Ly8gY3JlYXRlIGJ1ZmZlclxuXHRcdGlmIChhcmcgaW5zdGFuY2VvZiBXZWJHTEJ1ZmZlcikge1xuXHRcdFx0dGhpcy5idWZmZXIgPSBhcmc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0XHRpZiAoYXJnKSB7XG5cdFx0XHRcdC8vIGJ1ZmZlciB0aGUgZGF0YVxuXHRcdFx0XHR0aGlzLmJ1ZmZlckRhdGEoYXJnKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXBsb2FkIGluZGV4IGRhdGEgdG8gdGhlIEdQVS5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheUJ1ZmZlcnxudW1iZXJ9IGFyZyAtIFRoZSBhcnJheSBvZiBkYXRhIHRvIGJ1ZmZlci5cblx0ICpcblx0ICogQHJldHVybnMge0luZGV4QnVmZmVyfSBUaGUgaW5kZXggYnVmZmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0YnVmZmVyRGF0YShhcmcpIHtcblx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xuXHRcdGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGFyZywgZ2wuU1RBVElDX0RSQVcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwbG9hZCBwYXJ0aWFsIGluZGV4IGRhdGEgdG8gdGhlIEdQVS5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXkgLSBUaGUgYXJyYXkgb2YgZGF0YSB0byBidWZmZXIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBieXRlT2Zmc2V0IC0gVGhlIGJ5dGUgb2Zmc2V0IGF0IHdoaWNoIHRvIGJ1ZmZlci5cblx0ICpcblx0ICogQHJldHVybnMge0luZGV4QnVmZmVyfSBUaGUgaW5kZXggYnVmZmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0YnVmZmVyU3ViRGF0YShhcnJheSwgYnl0ZU9mZnNldCA9IDApIHtcblx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xuXHRcdGdsLmJ1ZmZlclN1YkRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGJ5dGVPZmZzZXQsIGFycmF5KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBkcmF3IGNvbW1hbmQgZm9yIHRoZSBib3VuZCBidWZmZXIuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtJbmRleEJ1ZmZlcn0gVGhlIGluZGV4IGJ1ZmZlciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdGRyYXcoKSB7XG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xuXHRcdGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcblx0XHRnbC5kcmF3RWxlbWVudHMoZ2xbdGhpcy5tb2RlXSwgdGhpcy5jb3VudCwgZ2xbdGhpcy50eXBlXSwgdGhpcy5ieXRlT2Zmc2V0KTtcblx0XHQvLyBubyBuZWVkIHRvIHVuYmluZFxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSW5kZXhCdWZmZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGRlZmF1bHRUbyA9IHJlcXVpcmUoJ2xvZGFzaC9kZWZhdWx0VG8nKTtcbmNvbnN0IGZvckluID0gcmVxdWlyZSgnbG9kYXNoL2ZvckluJyk7XG5cbi8vIENvbnN0YW50c1xuXG5jb25zdCBCWVRFU19QRVJfVFlQRSA9IHtcblx0QllURTogMSxcblx0VU5TSUdORURfQllURTogMSxcblx0U0hPUlQ6IDIsXG5cdFVOU0lHTkVEX1NIT1JUOiAyLFxuXHRGSVhFRDogNCxcblx0RkxPQVQ6IDRcbn07XG5cbi8vIFByaXZhdGUgTWV0aG9kc1xuXG5jb25zdCBjYWxjQ2h1bmtCeXRlU2l6ZSA9IGZ1bmN0aW9uKHBvaW50ZXJzLCBjaHVua1NpemUpIHtcblx0bGV0IGJ5dGVTaXplID0gMDtcblx0cG9pbnRlcnMuZm9yRWFjaChwb2ludGVyID0+IHtcblx0XHRieXRlU2l6ZSArPSBCWVRFU19QRVJfVFlQRVtwb2ludGVyLnR5cGVdICogcG9pbnRlci5zaXplICogY2h1bmtTaXplO1xuXHR9KTtcblx0cmV0dXJuIGJ5dGVTaXplO1xufTtcblxuY29uc3QgY2FsY0J5dGVPZmZzZXRzID0gZnVuY3Rpb24oY2h1bmssIHBvaW50ZXJzLCBjaHVua0J5dGVPZmZzZXQpIHtcblx0bGV0IGJ5dGVPZmZzZXQgPSAwO1xuXHRwb2ludGVycy5mb3JFYWNoKChwb2ludGVyLCBsb2NhdGlvbikgPT4ge1xuXHRcdGNodW5rLmJ5dGVPZmZzZXRzW2xvY2F0aW9uXSA9IGNodW5rQnl0ZU9mZnNldCArIGJ5dGVPZmZzZXQ7XG5cdFx0Ynl0ZU9mZnNldCArPSBCWVRFU19QRVJfVFlQRVtwb2ludGVyLnR5cGVdICogcG9pbnRlci5zaXplO1xuXHR9KTtcbn07XG5cbmNvbnN0IGNhbGNTdHJpZGUgPSBmdW5jdGlvbihwb2ludGVycykge1xuXHRsZXQgc3RyaWRlID0gMDtcblx0cG9pbnRlcnMuZm9yRWFjaChwb2ludGVyID0+IHtcblx0XHRzdHJpZGUgKz0gcG9pbnRlci5zaXplO1xuXHR9KTtcblx0cmV0dXJuIHN0cmlkZTtcbn07XG5cbmNvbnN0IHBhcnNlQXR0cmlidXRlUG9pbnRlcnMgPSBmdW5jdGlvbihwb2ludGVycykge1xuXHRjb25zdCBhdHRyaWJ1dGVQb2ludGVycyA9IG5ldyBNYXAoKTtcblx0bGV0IGJ5dGVPZmZzZXQgPSAwO1xuXHQvLyBjb252ZXJ0IHRvIG1hcFxuXHRmb3JJbihwb2ludGVycywgKHBvaW50ZXIsIGluZGV4KSA9PiB7XG5cdFx0YXR0cmlidXRlUG9pbnRlcnMuc2V0KGluZGV4LCB7XG5cdFx0XHR0eXBlOiBwb2ludGVyLnR5cGUsXG5cdFx0XHRzaXplOiBwb2ludGVyLnNpemUsXG5cdFx0XHRieXRlT2Zmc2V0OiBieXRlT2Zmc2V0LFxuXHRcdFx0Ynl0ZVN0cmlkZTogMFxuXHRcdH0pO1xuXHRcdGJ5dGVPZmZzZXQgKz0gQllURVNfUEVSX1RZUEVbcG9pbnRlci50eXBlXSAqIHBvaW50ZXIuc2l6ZTtcblx0fSk7XG5cdC8vIGFkZCBieXRlIHN0cmlkZVxuXHRhdHRyaWJ1dGVQb2ludGVycy5mb3JFYWNoKHBvaW50ZXIgPT4ge1xuXHRcdHBvaW50ZXIuYnl0ZVN0cmlkZSA9IGJ5dGVPZmZzZXQ7XG5cdH0pO1xuXHRyZXR1cm4gYXR0cmlidXRlUG9pbnRlcnM7XG59O1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHZlcnRleCBhdGxhcy5cbiAqL1xuY2xhc3MgVmVydGV4QXRsYXMge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBuZXcgVmVydGV4QXRsYXMgb2JqZWN0LlxuXHQgKiBOT1RFOiBBc3N1bWVzIGludGVybGVhdmVkIHZlcnRleCBmb3JtYXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFRoZSBXZWJHTCBjb250ZXh0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlcnMgLSBUaGUgdmVydGV4IGF0dHJpYnV0ZSBwb2ludGVycy5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgdmVydGV4IGF0bGFzIG9wdGlvbnMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNodW5rU2l6ZSAtIFRoZSBzaXplIG9mIGEgc2luZ2xlIGNodW5rLCBpbiB2ZXJ0aWNlcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubnVtQ2h1bmtzIC0gVGhlIHNpemUgb2YgdGhlIGF0bGFzLCBpbiB0aWxlcy5cblx0ICovXG5cdGNvbnN0cnVjdG9yKGdsLCBwb2ludGVycywgb3B0aW9ucyA9IHt9KSB7XG5cdFx0Ly8gZ2V0IGNvbnRleHRcblx0XHR0aGlzLmdsID0gZ2w7XG5cdFx0Ly8gZ2V0IHRoZSBleHRlbnNpb24gZm9yIGhhcmR3YXJlIGluc3RhbmNpbmdcblx0XHR0aGlzLmV4dCA9IGdsLmdldEV4dGVuc2lvbignQU5HTEVfaW5zdGFuY2VkX2FycmF5cycpO1xuXHRcdGlmICghdGhpcy5leHQpIHtcblx0XHRcdHRocm93ICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzIFdlYkdMIGV4dGVuc2lvbiBpcyBub3Qgc3VwcG9ydGVkJztcblx0XHR9XG5cdFx0Ly8gc2V0IGF0bGFzIHByb3BlcnRpZXNcblx0XHR0aGlzLmNodW5rU2l6ZSA9IGRlZmF1bHRUbyhvcHRpb25zLmNodW5rU2l6ZSwgMTI4ICogMTI4KTtcblx0XHR0aGlzLm51bUNodW5rcyA9IGRlZmF1bHRUbyhvcHRpb25zLm51bUNodW5rcywgMjU2KTtcblx0XHQvLyBzZXQgdGhlIHBvaW50ZXJzIG9mIHRoZSBhdGxhc1xuXHRcdGlmICghcG9pbnRlcnMpIHtcblx0XHRcdHRocm93ICdObyBhdHRyaWJ1dGUgcG9pbnRlcnMgcHJvdmlkZWQnO1xuXHRcdH1cblx0XHR0aGlzLnBvaW50ZXJzID0gcGFyc2VBdHRyaWJ1dGVQb2ludGVycyhwb2ludGVycyk7XG5cdFx0Ly8gY2FsYyBzdHJpZGUgb2YgdGhlIGF0bGFzXG5cdFx0dGhpcy5zdHJpZGUgPSBjYWxjU3RyaWRlKHRoaXMucG9pbnRlcnMpO1xuXHRcdC8vIGNyZWF0ZSBhdmFpbGFibGUgY2h1bmtzXG5cdFx0dGhpcy5hdmFpbGFibGUgPSBuZXcgQXJyYXkodGhpcy5udW1DaHVua3MpO1xuXHRcdC8vIGNhbGMgdGhlIGNodW5rIGJ5dGUgc2l6ZVxuXHRcdGNvbnN0IGNodW5rQnl0ZVNpemUgPSBjYWxjQ2h1bmtCeXRlU2l6ZShcblx0XHRcdHRoaXMucG9pbnRlcnMsXG5cdFx0XHR0aGlzLmNodW5rU2l6ZSk7XG5cdFx0Ly8gZm9yIGVhY2ggY2h1bmtcblx0XHRmb3IgKGxldCBpPTA7IGk8dGhpcy5udW1DaHVua3M7IGkrKykge1xuXHRcdFx0Y29uc3QgY2h1bmtPZmZzZXQgPSBpICogdGhpcy5jaHVua1NpemU7XG5cdFx0XHRjb25zdCBjaHVua0J5dGVPZmZzZXQgPSBpICogY2h1bmtCeXRlU2l6ZTtcblx0XHRcdGNvbnN0IGF2YWlsYWJsZSA9IHtcblx0XHRcdFx0Y291bnQ6IDAsXG5cdFx0XHRcdGNodW5rT2Zmc2V0OiBjaHVua09mZnNldCxcblx0XHRcdFx0Y2h1bmtCeXRlT2Zmc2V0OiBjaHVua0J5dGVPZmZzZXQsXG5cdFx0XHRcdGJ5dGVPZmZzZXRzOiB7fVxuXHRcdFx0fTtcblx0XHRcdC8vIGNhbGN1bGF0ZSBpbnRlcmxlYXZlZCBvZmZzZXRzIC8gc3RyaWRlLCB0aGlzIG9ubHkgbmVlZHNcblx0XHRcdC8vIHRvIGJlIGRvbmUgb25jZVxuXHRcdFx0Y2FsY0J5dGVPZmZzZXRzKFxuXHRcdFx0XHRhdmFpbGFibGUsXG5cdFx0XHRcdHRoaXMucG9pbnRlcnMsXG5cdFx0XHRcdGNodW5rQnl0ZU9mZnNldCk7XG5cdFx0XHQvLyBhZGQgY2h1bmtcblx0XHRcdHRoaXMuYXZhaWxhYmxlW2ldID0gYXZhaWxhYmxlO1xuXHRcdH1cblx0XHQvLyBjcmVhdGUgdXNlZCBjaHVuayBtYXBcblx0XHR0aGlzLnVzZWQgPSBuZXcgTWFwKCk7XG5cdFx0Ly8gY3JlYXRlIGJ1ZmZlclxuXHRcdHRoaXMuYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0Ly8gY2FsYyB0b3RhbCBzaXplIG9mIHRoZSBidWZmZXJcblx0XHRjb25zdCBieXRlU2l6ZSA9IGNodW5rQnl0ZVNpemUgKiB0aGlzLm51bUNodW5rcztcblx0XHQvLyBidWZmZXIgdGhlIGRhdGFcblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xuXHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBieXRlU2l6ZSwgZ2wuRFlOQU1JQ19EUkFXKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUZXN0IHdoZXRoZXIgb3Igbm90IGEga2V5IGlzIGhlbGQgaW4gdGhlIGF0bGFzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSB0byB0ZXN0LlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGNvb3JkIGV4aXN0cyBpbiB0aGUgcHlyYW1pZC5cblx0ICovXG5cdGhhcyhrZXkpIHtcblx0XHRyZXR1cm4gdGhpcy51c2VkLmhhcyhrZXkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGNodW5rIG1hdGNoaW5nIHRoZSBwcm92aWRlZCBrZXkuIElmIHRoZSBjaHVuayBkb2VzIG5vdFxuXHQgKiBleGlzdCwgcmV0dXJucyB1bmRlZmluZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBjaHVuayB0byByZXR1cm4uXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjaHVuayBvYmplY3QuXG5cdCAqL1xuXHRnZXQoa2V5KSB7XG5cdFx0cmV0dXJuIHRoaXMudXNlZC5nZXQoa2V5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIHZlcnRleCBkYXRhIGZvciB0aGUgcHJvdmlkZWQga2V5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBvZiB0aGUgdmVydGV4IGRhdGEuXG5cdCAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGEgLSBUaGUgdmVydGV4IGRhdGEuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIFRoZSBjb3VudCBvZiB2ZXJ0aWNlcyBhZGRlZC5cblx0ICovXG5cdHNldChrZXksIGRhdGEsIGNvdW50KSB7XG5cdFx0aWYgKHRoaXMuaGFzKGtleSkpIHtcblx0XHRcdHRocm93IGBUaWxlIG9mIGNvb3JkICR7a2V5fSBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgYXRsYXNgO1xuXHRcdH1cblx0XHRpZiAodGhpcy5hdmFpbGFibGUubGVuZ3RoID09PSAwKSB7XG5cdFx0XHR0aHJvdyAnTm8gYXZhaWxhYmxlIHZlcnRleCBjaHVua3MgaW4gYXRsYXMnO1xuXHRcdH1cblx0XHRpZiAoY291bnQgPiB0aGlzLmNodW5rU2l6ZSkge1xuXHRcdFx0dGhyb3cgYERhdGEgY291bnQgb2YgJHtjb3VudH0gaXMgZ3JlYXRlciB0aGF0IGFsbG9jYXRlZCBzaXplIG9mICR7dGhpcy5jaHVua1NpemV9YDtcblx0XHR9XG5cdFx0Ly8gZ2V0IGFuIGF2YWlsYWJsZSBjaHVua1xuXHRcdGNvbnN0IGNodW5rID0gdGhpcy5hdmFpbGFibGUucG9wKCk7XG5cdFx0Ly8gdXBkYXRlIGNodW5rIGNvdW50XG5cdFx0Y2h1bmsuY291bnQgPSBjb3VudDtcblx0XHQvLyBvbmx5IGFjdHVhbGx5IGJ1ZmZlciB0aGUgZGF0YSBpZiB0aGVyZSBpcyAgZGF0YVxuXHRcdGlmIChjb3VudCA+IDApIHtcblx0XHRcdC8vIGJ1ZmZlciB0aGUgZGF0YVxuXHRcdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xuXHRcdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcblx0XHRcdGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBjaHVuay5jaHVua0J5dGVPZmZzZXQsIGRhdGEpO1xuXHRcdH1cblx0XHQvLyBhZGQgdG8gdXNlZFxuXHRcdHRoaXMudXNlZC5zZXQoa2V5LCBjaHVuayk7XG5cdH1cblxuXHQvKipcblx0ICogRmxhZ3MgdGhlIGNodW5rIG1hdGNoaW5nIHRoZSBwcm92aWRlZCBrZXkgYXMgdW51c2VkIGluIHRoZSBhdGxhcy5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGNodW5rIHRvIGZyZWUuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtWZXJ0ZXhBdGxhc30gVGhlIFZlcnRleEF0bGFzIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0ZGVsZXRlKGtleSkge1xuXHRcdGlmICghdGhpcy5oYXMoa2V5KSkge1xuXHRcdFx0dGhyb3cgYFRpbGUgb2YgY29vcmQgJHtrZXl9IGRvZXMgbm90IGV4aXN0IGluIHRoZSBhdGxhc2A7XG5cdFx0fVxuXHRcdC8vIGdldCBjaHVua1xuXHRcdGNvbnN0IGNodW5rID0gdGhpcy51c2VkLmdldChrZXkpO1xuXHRcdC8vIHJlbW92ZSBmcm9tIHVzZWRcblx0XHR0aGlzLnVzZWQuZGVsZXRlKGtleSk7XG5cdFx0Ly8gYWRkIHRvIGF2YWlsYWJsZVxuXHRcdHRoaXMuYXZhaWxhYmxlLnB1c2goY2h1bmspO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpbmRzIHRoZSB2ZXJ0ZXggYXRsYXMgYW5kIGFjdGl2YXRlcyB0aGUgYXR0cmlidXRlIGFycmF5cy5cblx0ICpcblx0ICogQHJldHVybnMge1ZlcnRleEF0bGFzfSBUaGUgVmVydGV4QXRsYXMgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRiaW5kKCkge1xuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcblx0XHQvLyBiaW5kIHRoZSBidWZmZXJcblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xuXHRcdC8vIGZvciBlYWNoIGF0dHJpYnV0ZSBwb2ludGVyXG5cdFx0dGhpcy5wb2ludGVycy5mb3JFYWNoKChwb2ludGVyLCBpbmRleCkgPT4ge1xuXHRcdFx0Ly8gZW5hYmxlIGF0dHJpYnV0ZSBpbmRleFxuXHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xuXHRcdFx0Ly8gc2V0IGF0dHJpYnV0ZSBwb2ludGVyXG5cdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuXHRcdFx0XHRpbmRleCxcblx0XHRcdFx0cG9pbnRlci5zaXplLFxuXHRcdFx0XHRnbFtwb2ludGVyLnR5cGVdLFxuXHRcdFx0XHRmYWxzZSxcblx0XHRcdFx0cG9pbnRlci5ieXRlU3RyaWRlLFxuXHRcdFx0XHRwb2ludGVyLmJ5dGVPZmZzZXQpO1xuXHRcdH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpbmRzIHRoZSB2ZXJ0ZXggYXRsYXMgYW5kIGFjdGl2YXRlcyB0aGUgYXR0cmlidXRlIGFycmF5cyBmb3Jcblx0ICogaW5zdGFuY2luZy5cblx0ICpcblx0ICogQHJldHVybnMge1ZlcnRleEF0bGFzfSBUaGUgVmVydGV4QXRsYXMgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRiaW5kSW5zdGFuY2VkKCkge1xuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcblx0XHRjb25zdCBleHQgPSB0aGlzLmV4dDtcblx0XHQvLyBiaW5kIHRoZSBidWZmZXJcblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xuXHRcdC8vIGZvciBlYWNoIGF0dHJpYnV0ZSBwb2ludGVyXG5cdFx0dGhpcy5wb2ludGVycy5mb3JFYWNoKChwb2ludGVyLCBpbmRleCkgPT4ge1xuXHRcdFx0Ly8gZW5hYmxlIGF0dHJpYnV0ZSBpbmRleFxuXHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xuXHRcdFx0Ly8gZW5hYmxlIGluc3RhbmNpbmcgdGhpcyBhdHRyaWJ1dGVcblx0XHRcdGV4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoaW5kZXgsIDEpO1xuXHRcdH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVuYmluZHMgdGhlIHZlcnRleCBhdGxhcyBhbmQgZGlzYWJsZXMgdGhlIHZlcnRleCBhcnJheXMuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtWZXJ0ZXhBdGxhc30gVGhlIFZlcnRleEF0bGFzIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0dW5iaW5kKCkge1xuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcblx0XHQvLyBmb3IgZWFjaCBhdHRyaWJ1dGUgcG9pbnRlclxuXHRcdHRoaXMucG9pbnRlcnMuZm9yRWFjaCgocG9pbnRlciwgaW5kZXgpID0+IHtcblx0XHRcdC8vIGRpc2FibGUgYXR0cmlidXRlIGluZGV4XG5cdFx0XHRnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xuXHRcdH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVuYmluZHMgdGhlIHZlcnRleCBhdGxhcyBhbmQgZGlzYWJsZXMgdGhlIHZlcnRleCBhcnJheXMgZm9yXG5cdCAqIGluc3RhbmNpbmcuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtWZXJ0ZXhBdGxhc30gVGhlIFZlcnRleEF0bGFzIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0dW5iaW5kSW5zdGFuY2VkKCkge1xuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcblx0XHRjb25zdCBleHQgPSB0aGlzLmV4dDtcblx0XHQvLyBmb3IgZWFjaCBhdHRyaWJ1dGUgcG9pbnRlclxuXHRcdHRoaXMucG9pbnRlcnMuZm9yRWFjaCgocG9pbnRlciwgaW5kZXgpID0+IHtcblx0XHRcdC8vIGRpc2FibGUgYXR0cmlidXRlIGluZGV4XG5cdFx0XHRnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xuXHRcdFx0Ly8gZGlzYWJsZSBpbnN0YW5jaW5nIHRoaXMgYXR0cmlidXRlXG5cdFx0XHRleHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKGluZGV4LCAwKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBkcmF3IGNvbW1hbmQgYXQgdGhlIGNvcnJlY3Qgb2Zmc2V0IGFuZCBjb3VudCB3aXRoaW4gdGhlXG5cdCAqIGF0bGFzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBvZiB0aGUgY2h1bmsgdG8gZHJhdy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgLSBUaGUgcHJpbWl0aXZlIGRyYXdpbmcgbW9kZSB0byB1c2UuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGludG8gdGhlIGNodW5rLiBPcHRpb25hbC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gVGhlIGNvdW50IG9mIHByaW1pdGl2ZXMgdG8gcmVuZGVyLiBPcHRpb25hbC5cblx0ICpcblx0ICogQHJldHVybnMge1ZlcnRleEJ1ZmZlcn0gVGhlIHZlcnRleCBidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRkcmF3KGtleSwgbW9kZSwgb2Zmc2V0ID0gMCwgY291bnQgPSAwKSB7XG5cdFx0aWYgKCF0aGlzLmhhcyhrZXkpKSB7XG5cdFx0XHR0aHJvdyBgVGlsZSBvZiBjb29yZCAke2tleX0gZG9lcyBub3QgZXhpc3QgaW4gdGhlIGF0bGFzYDtcblx0XHR9XG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xuXHRcdGNvbnN0IGNodW5rID0gdGhpcy51c2VkLmdldChrZXkpO1xuXHRcdC8vIG9ubHkgYWN0dWFsbHkgZHJhdyBpZiBjb3VudCA+IDBcblx0XHRpZiAoY2h1bmsuY291bnQgPiAwKSB7XG5cdFx0XHQvLyBkcmF3IHRoZSBjaHVua1xuXHRcdFx0Z2wuZHJhd0FycmF5cyhnbFttb2RlXSwgY2h1bmsuY2h1bmtPZmZzZXQgKyBvZmZzZXQsIGNvdW50ID8gY291bnQgOiBjaHVuay5jb3VudCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEV4ZWN1dGUgdGhlIGluc3RhbmNlZCBkcmF3IGNvbW1hbmQgYXQgdGhlIGNvcnJlY3Qgb2Zmc2V0IGFuZCBjb3VudCB3aXRoaW5cblx0ICogdGhlIGF0bGFzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBvZiB0aGUgY2h1bmsgdG8gZHJhdy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgLSBUaGUgcHJpbWl0aXZlIGRyYXdpbmcgbW9kZSB0byB1c2UuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIFRoZSBjb3VudCBvZiBwcmltaXRpdmVzIHRvIHJlbmRlci4gT3B0aW9uYWwuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtWZXJ0ZXhCdWZmZXJ9IFRoZSB2ZXJ0ZXggYnVmZmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0ZHJhd0luc3RhbmNlZChrZXksIG1vZGUsIGNvdW50KSB7XG5cdFx0aWYgKCF0aGlzLmhhcyhrZXkpKSB7XG5cdFx0XHR0aHJvdyBgVGlsZSBvZiBjb29yZCAke2tleX0gZG9lcyBub3QgZXhpc3QgaW4gdGhlIGF0bGFzYDtcblx0XHR9XG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xuXHRcdGNvbnN0IGV4dCA9IHRoaXMuZXh0O1xuXHRcdGNvbnN0IGNodW5rID0gdGhpcy51c2VkLmdldChrZXkpO1xuXHRcdC8vIGZvciBlYWNoIGF0dHJpYnV0ZSBwb2ludGVyXG5cdFx0dGhpcy5wb2ludGVycy5mb3JFYWNoKChwb2ludGVyLCBpbmRleCkgPT4ge1xuXHRcdFx0Ly8gc2V0IGF0dHJpYnV0ZSBwb2ludGVyXG5cdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuXHRcdFx0XHRpbmRleCxcblx0XHRcdFx0cG9pbnRlci5zaXplLFxuXHRcdFx0XHRnbFtwb2ludGVyLnR5cGVdLFxuXHRcdFx0XHRmYWxzZSxcblx0XHRcdFx0cG9pbnRlci5ieXRlU3RyaWRlLFxuXHRcdFx0XHRjaHVuay5ieXRlT2Zmc2V0c1tpbmRleF0pO1xuXHRcdH0pO1xuXHRcdC8vIG9ubHkgYWN0dWFsbHkgZHJhdyBpZiBjb3VudCA+IDBcblx0XHRpZiAoY2h1bmsuY291bnQgPiAwKSB7XG5cdFx0XHQvLyBkcmF3IHRoZSBib3VuZCB2ZXJ0ZXggYXJyYXlcblx0XHRcdGV4dC5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoZ2xbbW9kZV0sIDAsIGNvdW50LCBjaHVuay5jb3VudCk7XG5cdFx0fVxuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVmVydGV4QXRsYXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGRlZmF1bHRUbyA9IHJlcXVpcmUoJ2xvZGFzaC9kZWZhdWx0VG8nKTtcbmNvbnN0IGZvckluID0gcmVxdWlyZSgnbG9kYXNoL2ZvckluJyk7XG5cbi8vIENvbnN0YW50c1xuXG5jb25zdCBCWVRFU19QRVJfVFlQRSA9IHtcblx0QllURTogMSxcblx0VU5TSUdORURfQllURTogMSxcblx0U0hPUlQ6IDIsXG5cdFVOU0lHTkVEX1NIT1JUOiAyLFxuXHRGSVhFRDogNCxcblx0RkxPQVQ6IDRcbn07XG5cbi8vIFByaXZhdGUgTWV0aG9kc1xuXG5jb25zdCBnZXRTdHJpZGUgPSBmdW5jdGlvbihwb2ludGVycykge1xuXHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBhdHRyaWJ1dGUgcG9pbnRlciBhc3NpZ25lZCB0byB0aGlzIGJ1ZmZlcixcblx0Ly8gdGhlcmUgaXMgbm8gbmVlZCBmb3Igc3RyaWRlLCBzZXQgdG8gZGVmYXVsdCBvZiAwXG5cdGlmIChwb2ludGVycy5zaXplID09PSAxKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblx0bGV0IG1heEJ5dGVPZmZzZXQgPSAwO1xuXHRsZXQgYnl0ZVNpemVTdW0gPSAwO1xuXHRsZXQgYnl0ZVN0cmlkZSA9IDA7XG5cdHBvaW50ZXJzLmZvckVhY2gocG9pbnRlciA9PiB7XG5cdFx0Y29uc3QgYnl0ZU9mZnNldCA9IHBvaW50ZXIuYnl0ZU9mZnNldDtcblx0XHRjb25zdCBzaXplID0gcG9pbnRlci5zaXplO1xuXHRcdGNvbnN0IHR5cGUgPSBwb2ludGVyLnR5cGU7XG5cdFx0Ly8gdHJhY2sgdGhlIHN1bSBvZiBlYWNoIGF0dHJpYnV0ZSBzaXplXG5cdFx0Ynl0ZVNpemVTdW0gKz0gc2l6ZSAqIEJZVEVTX1BFUl9UWVBFW3R5cGVdO1xuXHRcdC8vIHRyYWNrIHRoZSBsYXJnZXN0IG9mZnNldCB0byBkZXRlcm1pbmUgdGhlIGJ5dGUgc3RyaWRlIG9mIHRoZSBidWZmZXJcblx0XHRpZiAoYnl0ZU9mZnNldCA+IG1heEJ5dGVPZmZzZXQpIHtcblx0XHRcdG1heEJ5dGVPZmZzZXQgPSBieXRlT2Zmc2V0O1xuXHRcdFx0Ynl0ZVN0cmlkZSA9IGJ5dGVPZmZzZXQgKyAoc2l6ZSAqIEJZVEVTX1BFUl9UWVBFW3R5cGVdKTtcblx0XHR9XG5cdH0pO1xuXHQvLyBjaGVjayBpZiB0aGUgbWF4IGJ5dGUgb2Zmc2V0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgdGhlIHN1bVxuXHQvLyBvZiB0aGUgc2l6ZXMuIElmIHNvIHRoaXMgYnVmZmVyIGlzIG5vdCBpbnRlcmxlYXZlZCBhbmQgZG9lcyBub3QgbmVlZFxuXHQvLyBhIHN0cmlkZS5cblx0aWYgKG1heEJ5dGVPZmZzZXQgPj0gYnl0ZVNpemVTdW0pIHtcblx0XHQvLyBUT0RPOiB0ZXN0IHdoYXQgc3RyaWRlID09PSAwIGRvZXMgZm9yIGFuIGludGVybGVhdmVkIGJ1ZmZlciBvZlxuXHRcdC8vIGxlbmd0aCA9PT0gMS5cblx0XHRyZXR1cm4gMDtcblx0fVxuXHRyZXR1cm4gYnl0ZVN0cmlkZTtcbn07XG5cbmNvbnN0IGdldEF0dHJpYnV0ZVBvaW50ZXJzID0gZnVuY3Rpb24oYXR0cmlidXRlUG9pbnRlcnMpIHtcblx0Ly8gcGFyc2UgcG9pbnRlcnMgdG8gZW5zdXJlIHRoZXkgYXJlIHZhbGlkXG5cdGNvbnN0IHBvaW50ZXJzID0gbmV3IE1hcCgpO1xuXHRmb3JJbihhdHRyaWJ1dGVQb2ludGVycywgKHBvaW50ZXIsIGtleSkgPT4ge1xuXHRcdC8vIHBhcnNlIGluZGV4IGZyb20gc3RyaW5nIHRvIGludFxuXHRcdGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoa2V5LCAxMCk7XG5cdFx0Ly8gZW5zdXJlIGJ5dGUgb2Zmc2V0IGV4aXN0c1xuXHRcdHBvaW50ZXIuYnl0ZU9mZnNldCA9IGRlZmF1bHRUbyhwb2ludGVyLmJ5dGVPZmZzZXQsIDApO1xuXHRcdC8vIGFkZCB0byBtYXBcblx0XHRwb2ludGVycy5zZXQoaW5kZXgsIHBvaW50ZXIpO1xuXHR9KTtcblx0cmV0dXJuIHBvaW50ZXJzO1xufTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSB2ZXJ0ZXggYnVmZmVyLlxuICovXG5jbGFzcyBWZXJ0ZXhCdWZmZXIge1xuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYW4gVmVydGV4QnVmZmVyIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gVGhlIFdlYkdMIGNvbnRleHQuXG5cdCAqIEBwYXJhbSB7V2ViR0xCdWZmZXJ8QXJyYXlCdWZmZXJ8bnVtYmVyfSBhcmcgLSBUaGUgYnVmZmVyIG9yIGxlbmd0aCBvZiB0aGUgYnVmZmVyLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlcnMgLSBUaGUgYXJyYXkgcG9pbnRlciBtYXAuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHZlcnRleCBidWZmZXIgb3B0aW9ucy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubW9kZSAtIFRoZSBkcmF3IG1vZGUgLyBwcmltaXRpdmUgdHlwZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuaW5kZXhPZmZzZXQgLSBUaGUgaW5kZXggb2Zmc2V0IGludG8gdGhlIGRyYXduIGJ1ZmZlci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY291bnQgLSBUaGUgbnVtYmVyIG9mIGluZGljZXMgdG8gZHJhdy5cblx0ICovXG5cdGNvbnN0cnVjdG9yKGdsLCBhcmcsIHBvaW50ZXJzID0ge30sIG9wdGlvbnMgPSB7fSkge1xuXHRcdHRoaXMuZ2wgPSBnbDtcblx0XHR0aGlzLm1vZGUgPSBkZWZhdWx0VG8ob3B0aW9ucy5tb2RlLCAnVFJJQU5HTEVTJyk7XG5cdFx0dGhpcy5jb3VudCA9IGRlZmF1bHRUbyhvcHRpb25zLmNvdW50LCAwKTtcblx0XHR0aGlzLmluZGV4T2Zmc2V0ID0gZGVmYXVsdFRvKG9wdGlvbnMuaW5kZXhPZmZzZXQsIDApO1xuXHRcdC8vIGZpcnN0LCBzZXQgdGhlIGF0dHJpYnV0ZSBwb2ludGVyc1xuXHRcdHRoaXMucG9pbnRlcnMgPSBnZXRBdHRyaWJ1dGVQb2ludGVycyhwb2ludGVycyk7XG5cdFx0Ly8gc2V0IHRoZSBieXRlIHN0cmlkZVxuXHRcdHRoaXMuYnl0ZVN0cmlkZSA9IGdldFN0cmlkZSh0aGlzLnBvaW50ZXJzKTtcblx0XHQvLyBjcmVhdGUgYnVmZmVyXG5cdFx0aWYgKGFyZyBpbnN0YW5jZW9mIFdlYkdMQnVmZmVyKSB7XG5cdFx0XHR0aGlzLmJ1ZmZlciA9IGFyZztcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRcdGlmIChhcmcpIHtcblx0XHRcdFx0Ly8gYnVmZmVyIHRoZSBkYXRhXG5cdFx0XHRcdHRoaXMuYnVmZmVyRGF0YShhcmcpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBVcGxvYWQgdmVydGV4IGRhdGEgdG8gdGhlIEdQVS5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheUJ1ZmZlcnxudW1iZXJ9IGFyZyAtIFRoZSBhcnJheSBvZiBkYXRhIHRvIGJ1ZmZlciwgb3Igc2l6ZSBvZiB0aGUgYnVmZmVyIGluIGJ5dGVzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7VmVydGV4QnVmZmVyfSBUaGUgdmVydGV4IGJ1ZmZlciBvYmplY3QsIGZvciBjaGFpbmluZy5cblx0ICovXG5cdGJ1ZmZlckRhdGEoYXJnKSB7XG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xuXHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XG5cdFx0Z2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGFyZywgZ2wuU1RBVElDX0RSQVcpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwbG9hZCBwYXJ0aWFsIHZlcnRleCBkYXRhIHRvIHRoZSBHUFUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5IC0gVGhlIGFycmF5IG9mIGRhdGEgdG8gYnVmZmVyLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYnl0ZU9mZnNldCAtIFRoZSBieXRlIG9mZnNldCBhdCB3aGljaCB0byBidWZmZXIuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtWZXJ0ZXhCdWZmZXJ9IFRoZSB2ZXJ0ZXggYnVmZmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0YnVmZmVyU3ViRGF0YShhcnJheSwgYnl0ZU9mZnNldCA9IDApIHtcblx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcblx0XHRnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYnl0ZU9mZnNldCwgYXJyYXkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpbmRzIHRoZSB2ZXJ0ZXggYnVmZmVyIG9iamVjdC5cblx0ICpcblx0ICogQHJldHVybnMge1ZlcnRleEJ1ZmZlcn0gVGhlIHZlcnRleCBidWZmZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRiaW5kKCkge1xuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcblx0XHQvLyBiaW5kIGJ1ZmZlclxuXHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XG5cdFx0Ly8gZm9yIGVhY2ggYXR0cmlidXRlIHBvaW50ZXJcblx0XHR0aGlzLnBvaW50ZXJzLmZvckVhY2goKHBvaW50ZXIsIGluZGV4KSA9PiB7XG5cdFx0XHQvLyBzZXQgYXR0cmlidXRlIHBvaW50ZXJcblx0XHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG5cdFx0XHRcdGluZGV4LFxuXHRcdFx0XHRwb2ludGVyLnNpemUsXG5cdFx0XHRcdGdsW3BvaW50ZXIudHlwZV0sXG5cdFx0XHRcdGZhbHNlLFxuXHRcdFx0XHR0aGlzLmJ5dGVTdHJpZGUsXG5cdFx0XHRcdHBvaW50ZXIuYnl0ZU9mZnNldCk7XG5cdFx0XHQvLyBlbmFibGUgYXR0cmlidXRlIGluZGV4XG5cdFx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogVW5iaW5kcyB0aGUgdmVydGV4IGJ1ZmZlciBvYmplY3QuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtWZXJ0ZXhCdWZmZXJ9IFRoZSB2ZXJ0ZXggYnVmZmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0dW5iaW5kKCkge1xuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcblx0XHR0aGlzLnBvaW50ZXJzLmZvckVhY2goKHBvaW50ZXIsIGluZGV4KSA9PiB7XG5cdFx0XHQvLyBkaXNhYmxlIGF0dHJpYnV0ZSBpbmRleFxuXHRcdFx0Z2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcblx0XHR9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBFeGVjdXRlIHRoZSBkcmF3IGNvbW1hbmQgZm9yIHRoZSBib3VuZCBidWZmZXIuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtWZXJ0ZXhCdWZmZXJ9IFRoZSB2ZXJ0ZXggYnVmZmVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0ZHJhdygpIHtcblx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XG5cdFx0Z2wuZHJhd0FycmF5cyhnbFt0aGlzLm1vZGVdLCB0aGlzLmluZGV4T2Zmc2V0LCB0aGlzLmNvdW50KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZlcnRleEJ1ZmZlcjtcbiJdfQ==
